
#### 查看 Linux 临时端口号的范围
```
cat /proc/sys/net/ipv4/ip_local_port_range
32768   60999
``

* [0, 1024) 公认端口号, 需要 root 启动, 比如 80
* [1024, 32768) 注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
* [60990, 65535)

# 查询 域名 对应 的 IP
* nslookup baidu.com

tee
!!                 # 执行上一条命令
!l                 # 执行最近使用的以 l 打头的命令
!l:p               # 输出最近使用的以 l 打头的命令
!num               # 执行历史命令列表的第 num 条命令
!$                 # 表示上一条命令的最后一个参数

\command # 忽略别名

##
jobs
history

-----------------------------------------------

## bash 基础
bash file_name # 执行文件内的命令
bash -c "ls"   # 将字符串的内容交由 bash 执行, 字符串里可包含重定向和管道

#### 重定向
bash  < 1.txt
bash 1< 1.txt       # 标准输入重定向
ls    > 1.txt
ls   1> 1.txt       # 标准输出重定向
ls   >> 1.txt
ls  1>> 1.txt       # 标准输出添加重定向
ls   2> 1.txt       # 标准错误重定向
ls  2>> 1.txt       # 标准错误添加重定向
ls > 1.txt 2> 2.txt # 标准输出重定向到 1.txt, 标准错误重定向到 2.txt
ls >&2 2> 2.txt     # 标准输出重定向到和标准错误相同, 即屏幕, 标准错误重定向到 2.txt
ls > 1.txt 2>&1     # 标准输出重定向到 1.txt, 标准错误重定向到 和 标准输出相同, 即 1.txt
ls &> 1.txt         # 同时重定向标准输出和标准错误 到 1.txt
exec &>> lyb.log    # 脚本内重定向, 将 当前 shell 的标准输出 和 标准错误 重定向到 lyb.log

建议使用:
* ls > 1.txt  2> 2.txt
* ls &> /dev/null
* exec &>> lyb.log

#### 各种括号的作用
* 小括号
    * 单个小括号
        * lyb=(1 2 3)  # 数组
        * (ls)         # 子shell执行命令, 输出到屏幕上
        * lyb=$(ls)    # 子shell执行命令, 存入变量
        * cat <(ls)    # 将命令 或 函数的输出做为 文件, 命令要有打开 文件 的动作
    * 双小括号
        * ((1+2))      # 数学计算, 变量不需要加 $, 计算结果不为 0 时, 表示状态正常
        * lyb=$((1+2)) # 数学计算, 变量不需要加 $, 计算结果存入变量
* 中括号
    * 单中括号
        * [ -a file ]    # 判断文件的各种状态, < 等会有问题
        * lyb=$[lyb+lyb] # 数学计算, 变量不需要加 $, 计算结果存入变量
    * 双中括号
        * [[ -a file ]]    # 判断文件的各种状态, < 等不会有问题, 支持正则
* 大括号
    * 代码块
    * 作为变量的分割符
    * {1..10..2}  # 获取字符序列

括号很复杂, 建议:
* 使用双小括号进行数学计算, 比如: lyb=$((123+456))
* 使用双中括号进行文件判断, 支持正则: [[ lyb =~ ^l ]]

#### 字符串
length=${#val}       # 输出字符串的长度
${val:起始位置:长度} # 获取子串
lyb=123
lyb=$lyb+123 # lyb 将变成 123+123

${var}          # 取变量的值
${var:-word}    # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 返回 word
${var:=word}    # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 设置 var=word, 然后返回 word
${var:+word}    # 如果 var 存在, 且不为空, 则返回 word 的值, 否则, 返回 空
${var:?message} # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 返回 输出 message, 并退出

lyb=123.456.txt
lyb=${lyb%.*}       # 后缀非贪婪匹配, lyb 为 123.456
lyb=${lyb%%.*}      # 后缀  贪婪匹配, lyb 为 123
lyb=${lyb#*.}       # 前缀非贪婪匹配, lyb 为 txt
lyb=${lyb##*.}      # 前缀  贪婪匹配, lyb 为 456.txt
lyb=${lyb/*./str}   # 全文  贪婪匹配, lyb 为 txt, 匹配一次
lyb=${lyb//*./str}  # 全文  贪婪匹配, lyb 为 txt, 匹配多次
lyb=${lyb^^}        # 变为大写
lyb=${lyb,,}        # 变为小写

和 变量的区别
* 在复制号左边的只能是变量
* 以 $ 开头的, 也是变量
* 其他的无论加不加引号, 都是字符串


#### 数组
v=(1 2 3) # 定义数组
${v[1]}   # 数组中指定元素的值
${v[*]}   # 数组中所有元素的值, "1 2 3"
${v[@]}   # 数组中所有元素的值, "1" "2" "3"
${#v[*]}  # 数组中元素的个数
${#v[@]}  # 数组中元素的个数
${!v[@]}  # 获取所有的 key
${!v[*]}  # 获取所有的 key

declare -A v # 关联数组, map
v[a]=a
v[b]=b

#### 子shell
source .bashrc # 当前 shell 执行, 变量等会影响当前 shell
     . .bashrc # 同上
./bin.sh       # 在子 shell 中执行, 变量等不会影响当前 shell
exec ls        # 替换当前 shell, 执行后不再执行之后的命令
exec &>1.txt   # 打开文件描述符, 然后继续执行之后的命令
env            # 设置环境变量, 然后执行程序

#### 通配符
? # 代表一个字符
* # 代表零个或多个字符
[123]
[1-5]
[!a]

#### 正则表达式
^      : 开头
$      : 结尾
.      : 任意字符
[]     :  中括号中      的任意字符
[^]    : 中括号中字符外的任意字符
?      : 前面字符出现 0 次 或 一次
*      : 前面字符出现 0 次 或 多次
+      : 前面字符出现 1 次 或 多次
{n}    : 前面字符出现 n 次
{n,}   : 前面字符出现 n 次 及以上
{n, m} : 前面字符出现 n 次 到 m 次
()     : 将括号内的内容看成一个整体
|      : 或

## 脚本
$0 # 脚本名称
$1 # 第一个参数
$* # 所有参数拼成一个字符串
$@ # 参数序列
$# # 参数个数

#### 脚本上重定向
cat << EOF
    $lyb
EOF

