
## 建议
* 查看二进制一般使用 xxd 或 xxd -g 即可, 其他经常需要考虑字节序
* 优先使用无 BOM 的 UTF-8 编码, 使用 vim 的 set nobomb 可以去掉 BOM
* 使用 iconv 进行编码规则转换, vim 也可以, 只是没有 iconv 方便
* 文件编码不一定能精确获取

## 查看二进制
xxd        1.txt 2.txt # 字符文件 => 二进制
xxd -r     1.txt 2.txt # 二进制 => 字符文件
xxd -b     1.txt       # 输出二进制而不是十六进制
xxd -e     1.txt       # 交换大小端
xxd -g ... 1.txt       # 每组的字节数

hd         1.txt # 每组一个字节 显示十六进制+ASCII
hexdump -b 1.txt # 每组一个字节 显示八进制
hexdump -c 1.txt # 每组一个字节 显示字符
hexdump -C 1.txt # 每组一个字节 显示十六进制+ASCII
hexdump -d 1.txt # 每组两个字节 显示  十进制
hexdump -o 1.txt # 每组两个字节 显示  八进制
hexdump -x 1.txt # 每组两个字节 显示十六进制

od -t a   1.txt # 每组一个字节, 显示字符(nl)
od -t c   1.txt # 每组一个字节, 显示字符(\n)
od -t d4  1.txt # 每组四个字节, 显示有符号的十进制数字
od -t f4  1.txt # 每组四个字节, 显示浮点数
od -t o4  1.txt # 每组四个字节, 显示  八进制数字
od -t u4  1.txt # 每组四个字节, 显示无符号的十进制数字
od -t x4  1.txt # 每组四个字节, 显示十六进制数字
od -t d4z 1.txt # 每组四个字节, 显示十进制数字, 并显示原始字符
od -a     1.txt # 同 -t a
od -b     1.txt # 同 -t o1
od -c     1.txt # 同 -t c
od -d     1.txt # 同 -t u2
od -f     1.txt # 同 -t f
od -i     1.txt # 同 -t dI
od -l     1.txt # 同 -t dL
od -o     1.txt # 同 -t o2
od -s     1.txt # 同 -t d2
od -x     1.txt # 同 -t x2
od --endian={big|little} 1.txt # 指明大小端

## 字符
BOM(Byte Order Mark), 字节序标识

编码: 字符串 -> 计算机存储
解码: 计算机存储 -> 字符串
字符集: ASCII (和编码规则一一对应)
        GB2312 => GBK(cp936) => GB18030 (和编码规则一一对应)
        BIG5
        Unicode
        Latin1(ISO-8859-1) 单字节使用完整的八位字节, 所以可以将其他编码当作 Latin1 来传输不会丢失数据
编码规则:
        UTF-8  -- 不需要 BOM, 存在也成(FE FF => EF BB BF)
        UTF-16 --   需要 BOM(FE FF 或 FF FE)
        UTF-32 --   需要 BOM(00 00 FE FF 或 FF FE 00 00)

        windows 的 记事本 的 ASCI   : 本地编码
        windows 的 记事本 的 unicode: 带 BOM 的小端的 UTF-16
        windows 的 记事本 的 utf-8  : 带 BOM 的 UTF-8

file  1.txt   # 查看文件编码规则, 并不准确

iconv -f gbk -t utf-8 1.txt -o 1.txt # gbk => utf-8
iconv -t gbk -f utf-8 1.txt -o 1.txt # utf-8 => gbk

