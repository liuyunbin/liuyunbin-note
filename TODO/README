
## 文件时间
atime # 内容读取时间, 更新可能不及时
mtime # 内容修改时间
ctime # 状态修改时间: 内容 名称 权限 所属者 所属组

## 文件权限
* 读, 写, 执行
* SUID:
    文件执行时, 拥有此文件所有者的权限
    只对二进制有效
* SGID:
    二进制文件: 文件执行时, 拥有此文件所属组的权限
          目录: 新增的文件所属的组是此目录所属的组
* SBIT: 此目录下的文件只有文件或目录所有者才可以删除
* 权限判断: 依次判断所属用户, 所属组和其他权限
                前者失败时, 不判断后者
            假如 1.cc 的权限为 0070,
                所属主无权限, 所属组有权限时,
                对所属主也将判断为无权限
* 在目录下新增或删除文件时, 至少拥有此目录的写和执行权限

## 换行符
* Linux/iOS => \n
* windows   => \r\n
* 移除文件末尾的换行符: vim -c 'set binary noeol' -c 'wq!' 1.txt

## 相关命令
             # 文件如果是符号链接, 将使用符号链接对应的文件
cat -n 1.txt # 显示行号
cat -b 1.txt # 显示行号, 行号不包括空行
cat -s 1.txt # 去掉多余的连续的空行
cat -T 1.txt # 显示 TAB

             # 文件如果是符号链接, 将使用符号链接对应的文件
tac          # 最后一行 => 第一行

                                                       # 文件如果是符号链接, 将使用符号链接对应的文件
comm                        1.c 2.c                    # 要求文件已排序, 以行比较
comm --check-order          1.c 2.c                    #   检测文件是否已排序
comm --nocheck-order        1.c 2.c                    # 不检测文件是否已排序
comm --output-delimiter=... 1.c 2.c                    # 指定列分割, 默认是 TAB
comm                        1.c 2.c       | tr -d '\t' # 全集
comm                        1.c 2.c -1 -2 | tr -d '\t' # 交集
comm                        1.c 2.c -3    | tr -d '\t' # B - A 和 A - B
comm                        1.c 2.c -1 -3              # B - A
comm                        1.c 2.c -2 -3              # A - B

cp    123 456      # 拷贝文件时, 使用符号链接所指向的文件
                   # 拷贝目录时, 目录中的符号链接将使用符号链接本身
                   # 456 只使用符号链接所指向的文件
cp -r 123 456      # 递归复制
cp -P 123 456      # 总是拷贝符号链接本身
cp -L 123 456      # 总是拷贝符号链接所指的文件
cp --parents a/b t # 全路径复制, 将生成 t/a/b

                                      # 文件如果是符号链接, 将使用符号链接对应的文件
cut                        -b 2   1.c # 按字节切割, 输出第 2 个字节
cut                        -c 2-  1.c # 按字符切割, 输出 [2, 末尾] 字符
cut                        -f 2-5 1.c # 按列切割,   输出 [2,5] 列
cut -d STR                 -f 2,5 1.c # 设置输入字段的分隔符, 默认为 TAB, 输出 第 2 列和第 5 列
cut -s                     -f  -5 1.c # 不输出不包含字段分隔符的列, 输出 [开头, 5] 的列
cut --output-delimiter=STR -f  -5 1.c # 设置输出的字段分隔符, 默认使用输入的字段分隔符

echo -n "123"                # 不换行
echo -e "\e[1;33m lyb \e[0m" # 文本黄色 加粗

diff    1.txt 2.txt # 比较两个文件的不同
diff -u 1.txt 2.txt # 一体化输出, 比较两个文件的不同

basename $(readlink -f $0) # 获取脚本的名称
dirname  $(readlink -f $0) # 获取脚本的目录

df   -Th                # 查看磁盘挂载情况

-------------------------------


du                      # 列出目录大小
du -0                   # 输出以 \0 分割, 默认是换行符
du -a                   # 列出目录和文件大小
du -d 1                 # 最大目录深度
du -sh                  # 只列出整体使用大小
du --exclude="*.txt"    # 忽略指定文件, 支持通配符


dd if=/dev/zero of=junk.data bs=1M count=1

find . -name  lyb                     # 以文件名查找文件, 不包括路径, 可以使用通配符
find . -iname lyb                     # 同上, 忽略大小写
find . -path   "*/bash/*"             # 以全路径名查找文件, 可包括文件名, 可以使用通配符
find . -ipath  "*/bash/*"             # 同上, 忽略大小写
find . -regex ".*p+"                  # 同上, 使用正则表达式
find . -iregex ".*p+"                 # 同上, 忽略大小写
find . -maxdepth 5 –mindepth 2 -name lyb # 使用目录深度过滤
find . -L -name lyb                   # 是否跟着符号链接跳
find . -type  f                       # 以类型查找文件
find . -type f -atime -7              #     7天内访问过的文件
find . -type f -mtime  7              # 恰好7天前修改过的文件
find . -type f -ctime +7              #     7天前变化过的文件
find . -type f -newer file.txt        # 查找修改时间比 file.txt 新的文件
find . -type f -size +2G              # 以文件大小查找
find . -type f -perm 644              # 以权限查找
find . -type f -user lyb              # 以用户查找
find . -name '.git' -prune -o -type f # -prune 将前面匹配到的文件 或 目录 忽略掉
find . ! -type f -o   -name lyb       # ! 只否定最近的条件
find . \( -type f -and -name lyb \)   # 且, 多个条件必须同时成立
find . \( -type f -a   -name lyb \)   # 同上
find .    -type f      -name lyb      # 同上, 默认多个条件同时成立
find . \( -type f -or  -name lyb \)   # 或, 多个条件成立一个即可
find . \( -type f -o   -name lyb \)   # 同上

grep -v                   # 输出不匹配的内容
grep -c                   # 输出匹配的行的次数, 同一行只输出一次
grep -o                   # 只输出匹配的内容
grep -n                   # 输出匹配的行号
grep -l                   # 输出匹配的文件
grep -f                   # 从文件中读取匹配模式
grep -i                   # 忽略大小写
grep -h                   # 不输出文件名
grep -q                   # 静默输出
grep -A 5                 # 输出之前的行
grep -B 5                 # 输出之后的行
grep -C 5                 # 输出之前之后的行
grep -e .. -e ..          # 多个模式取或
grep -E ..                # 使用扩展的正则表达式, 同 egrep
grep -W ..                # 单词匹配
grep -X ..                # 行匹配
grep ... --inclue "*.c"   # 指定文件
grep ... --exclue "*.c"   # 忽略文件
grep ... --exclue-dir src # 忽略目录

less # 空格   : 下一页
     # ctrl+F : 下一页
     # b      : 上一页
     # ctrl+b : 上一页
     # 回车   : 下一行
     # =      : 当前行号
     # y      : 上一行

ln -s target symbolic_link_name # 创建符号链接

ls -a        # 列出当前目录中的元素, 包括隐藏的文件
ls -S        # 使用 文件大小 排序, 大 --> 小
ls -v        # 使用 版本号 排序
ls -X        # 使用 扩展名 排序
ls -d        # 只列出目录本身，而不列出目录内元素
ls -l        # 列出当前目录中的元素的详细信息
ls -h        # 使用人类可读的形式
ls -F        # 在目录后添加 /，在可执行文件后添加 *
ls -r        # 逆序
ls -R        # 递归
ls -1        # 在每一行列出文件名
ls -L        # 符号链接所指向的文件, 而不是符号链接本身
ls -I "*.sh" # 忽略文件, 使用通配符
ls -clt      # 使用 ctime 排序和展示, 新 -> 旧
ls -tl       # 使用 mtime 排序和展示, 新 -> 旧
ls -ult      # 使用 atime 排序和展示, 新 -> 旧

md5sum 1.txt # MD5 检验

mkdir    abc   # 创建目录
mkdir -p a/b/c # 递归创建目录, 目录已存在时不报错

mktemp         # 临时文件
mktemp -d      # 临时目录

more    # 空格   : 下一页
        # ctrl+F : 下一页
        # b      : 上一页
        # ctrl+b : 上一页
        # 回车   : 下一行
        # =      : 当前行号

mv a b # a 是符号链接时, 将使用符号链接本身
       # b 是指向目录  的符号链接时， 相当于 移到 b 本身
       # b 是指向目录  的符号链接时， 相当于 移到 b 最终所指向的目录下
       # b 是指向不存在的符号链接时， 相当于 重命名

patch     1.txt diff.pathc  # 恢复文件
patch -p1 1.txt diff.pathc  # 恢复文件, 忽略 diff.pathc 的第一个路径

readlink    1.c.link  # 读取符号链接
readlink -f 1.c.link  # 读取符号链接, 递归

rm -r  a    # 递归删除
rm -rf a    # 强行删除, 文件不存在时, 忽略

sort            # 排序
sort -b         # 忽略前置空白
sort -c         # 检查是否已排序
sort -d         # 字典序排序
sort -f         # 忽略大小写
sort -k 4       # 指定排序的列字段
sort -k 4.1,4.2 # 指定排序的列字段
sort -h         # 以 K, M, G 排序
sort -i         # 忽略不可打印字符
sort -m         # 合并排序过的文件
sort -n         # 以数字进行排序
sort -r         # 逆序
sort -t :       # 指定列的分割符
sort -u         # 重复项只输出一次
sort -V         # 以版本号排序
sort lyb -o lyb # 排序并存入原文件


stat    1.c # 列出 birth atime mtime ctime
stat -L 1.c # 符号链接所指向的文件, 而不是符号链接本身

tail -f * # 动态查看新增内容

tee    1.txt # 管道中把文件拷贝到文件
tee -a 1.txt # 管道中把文件添加到文件

tree -p "*.cc"       # 只显示  匹配到的文件
tree -I "*.cc"       # 只显示没匹配到的文件
tree -H . -o 1.html  # 指定目录生成 html 文件

tr    'a-z' 'A-Z' # 小写转大写
tr -d 'a-z'       # 删除字符
tr -s ' '         # 压缩字符

touch        1.c # 修改 atime mtime ctime
touch -a     1.c # 修改 atime
touch -m     1.c # 修改       mtime ctime
touch -c     1.c # 文件不存在时, 不创建文件
touch -h     1.c # 改变符号链接本身, 而不是所指向的文件
touch -r 2.c 1.c # 以 2.c 的时间修改 1.c
touch -d ... 1.c # 指定时间, 格式同 date
touch -t ... 1.c # 指定时间
                 # 依次是: 时区-年-月-日-时-分-秒

uniq    # 删除重复的行
uniq -c # 输出统计的次数
uniq -d # 只输出重复的行, 重复的项只输出一次
uniq -D # 只输出重复的行, 重复的项只输出多次
uniq -i # 忽略大小写
uniq -u # 只输出没重复的行

wc    # 输出 换行符数 字符串数 字节数
wc -l #   行数
wc -w # 字符串数
wc -c # 字节数
wc -m # 字符数


## 换行符转换
dos2unix 1.txt
unix2doc 1.txt

## 查看换行符
file 1.txt


#### 方法二 == 不建议, 只适用于只有一行且换行符为 \n 的情况
echo -n $(cat 1.txt | tr -d '\n') > 1.txt

## 添加文件末尾的换行符
vim -c 'set eol' -c 'wq!' 1.txt

## 查看文件时间
stat -c %w # 列出 birth 人类可读形式
stat -c %W # 列出 birth 距离 Epoch 的秒数
stat -c %x # 列出 atime 人类可读形式
stat -c %X # 列出 atime 距离 Epoch 的秒数
stat -c %y # 列出 mtime 人类可读形式
stat -c %Y # 列出 mtime 距离 Epoch 的秒数
stat -c %z # 列出 ctime 人类可读形式
stat -c %Z # 列出 ctime 距离 Epoch 的秒数

## 修改文件时间
touch        1.c # 修改 atime mtime ctime
touch -a     1.c # 修改 atime
touch -m     1.c # 修改       mtime ctime
touch -r 2.c 1.c # 以 2.c 的时间修改 1.c
touch -d ... 1.c # 指定时间, 格式同 date
touch -t ... 1.c # 指定时间
                 # 依次是: 时区-年-月-日-时-分-秒


## 相关命令
chattr +i 1.c # 设置文件不可修改
chattr -i 1.c # 取消文件不可修改

chmod  755    1.c # 设置权限, 不足四位时, 补前缀 0
chmod  644 -R 1.c # 递归
chmod 4755    1.c # 设置 SUID(4)
chmod 2755    1.c # 设置 SGID(2)
chmod 1755    1.c # 设置 SBIT(1)

chown lyb:lyb 1.c # 修改文件所属的组和用户



IFS 默认值: " \t\n"
IFS 包含转义字符时, 需要在开头添加 $, IFS=$'\n'

ntpdate -s time-b.nist.gov # 使用时间服务器更新时间

nohup sleep 1000 & # 脱离终端, 在后台运行
read name     # 读取, 如果参数值小于字段数, 多余的值放入最后一个字段
redis flushdb

rz          #  windows 向 虚拟机  发送数据

od -Ax  -tx1z 1.c # 每组一个字节, 显示十六进制
od      -c    1.c # 每组一个字节, 显示字符

set -o nounset  # 使用未初始化的变量报错, 同 -u
set -o errexit  # 只要发生错误就退出, 同 -e
set -o pipefail # 只要管道发生错误就退出
set -o errtrace # 函数报错时, 也处理 trap ERR, 同 set -E
set -o  xtrace  # 执行前打印命令, 同 -x
set -o verbose  # 读取前打印命令, 同 -v
set -o vi       # 使用 vi 快捷键
set -- ....     # 重新排列参数

sleep 30   # 前台运行
sleep 30 & # 后台运行

trap ... ERR  # 发生错误退出时, 执行指定命令
trap ... EXIT # 任意情况退出时, 执行指定命令

cat lyb | xargs -i vim {} # 以此编辑 lyb 中的每一个文件

xxd -g1 1.c # 每组一个字节, 显示十六进制
xxd -b  1.c # 每组一个字节, 显示  二进制

c++filt  a.out   # 可以解析动态库里的符号

--------------------------------------
## 时间戳 字符串形式 等待

## 学习一个命令需要注意的点
* 不需要了解命令的所有选项, 目的是为了使用, 有一些命令一辈子也用不到, 切记切记
* 支持 通配符, 还是基础的正则表达式 还是 扩展的正则表达式
* 各个选项之间是 且 还是 或
* 如何处理符号连接

#### 获取命令源码
yum install yum-utils
rpm -qf /usr/sbin/pidof        # 查看 命令所属的包
yumdownloader --source ...     # 下载源码包
rpm2cpio ...src.rpm | cpio -id # 转换
tar xvf ...                    # 解压

----------------------------------------
文件名称建议: 大小写字母 数字 下划线 短横线 点

errno 是线程安全的, 如何检验

#### 查看 Linux 临时端口号的范围
```
cat /proc/sys/net/ipv4/ip_local_port_range
32768   60999
``

* [0, 1024) 公认端口号, 需要 root 启动, 比如 80
* [1024, 32768) 注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
* [60990, 65535)

# 查询 域名 对应 的 IP
* nslookup baidu.com

\command # 忽略别名

bc <<< "scale=2; 10/2" # 设置使用两位小数, 输出: 5.00
bc <<< "ibase=2;  100" # 输入使用二进制, 输出: 4
bc <<< "obase=2;   10" # 输出使用二进制, 输出: 1010


date "+%Y-%m-%d %H:%M:%S"   # 输出: 年-月-日 时-分-秒
date "+%Y-%m-%d %H:%M"      # 输出: 年-月-日 时-分
date "+%s"                  # 输出: 时间戳
date -d "20200202 01:01:01" # 使用: 指定输入日期
date -d "@...."             # 使用: 时间戳
date -r 1.c                 # 使用: 文件的 mtime
date -s "20200202 10:10:10" # 更新系统时间, 需要 root


exec ls      # 替换当前 shell, 执行后不再执行之后的命令
exec &>1.txt # 打开文件描述符, 然后继续执行之后的命令
env          # 设置环境变量, 然后执行程序

flock    1.c ls # 设置文件互斥锁 执行命令, 设置锁失败, 等待
flock -n 1.c ls # 设置文件互斥锁 执行命令, 设置锁失败, 退出

脚本内使用, 保证脚本最多执行一次
[[ "$FLOCKER" != "$0" ]] && exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || :

解释:
1. 第一次进入脚本, 由于变量未设置, 会执行 exec
2. 调用 exec, 使用 env 设置 变量名
3. 执行 flock, 重新执行这个脚本, 执行完脚本后会退出, 不会执行之后的命令
    * 使用脚本名作为 文件锁, 脚本名使用绝对路径, 所以不会重复
4. 第二次进入脚本, 由于变量已设置, 直接往下执行就可以了
5. 在此期间, 如果, 有其他脚本进入, 文件锁获取失败, 就直接退出了

getconf NAME_MAX /
getconf PATH_MAX /

getopt  # a  无参数, a: 有参数
        # -- 表示可选参数的终止
        # 会重新排列参数
        # 可以解析 --bug
        # 可以区分无参数, 有参数, 可选参数的情况
        # -kval 可以当作 -k val 处理
        # 参数带空格可能出问题

getopts # -o 短选项, -l 长选项
        # a 无参数, a: 有参数, a:: 参数可选
        #  -- 表示可选参数的终止
        # 不会重排参数
        # 只能解析 -k, -k val, 不能解析 --bug, -kval
        # 只能区分有参数和无参数的情况
        # 参数带空格也能处理

hd            1.c # 每组一个字节, 显示十六进制
hexdump -C    1.c # 每组一个字节, 显示十六进制
hexdump -c    1.c # 每组一个字节, 显示字符

history

iconv

ip addr
ip route


nohup  # 忽略信号 SIGHUP
setsid # 以新的 session 执行命令

strace               # 追踪进程的系统调用和信号处理
strace cmd argv      # strace 和命令 同时启动
strace -p pid        # 追踪正在运行的程序, 多个进程, 指定 -p 多次
strace -c            # 统计系统调用的时间, 次数
strace -o ...        # 输出到指定的文件
strace -tt           # 显示调用时间 时分秒.毫秒
strace -T            # 显示系统调用的耗时
strace -f            # 跟踪子进程, 不包括 vfork
strace -F            # 跟踪 vfork
strace -e trace=...  # 跟踪指定信号调用
strace -s ...        # 参数是字符串时, 最大输出长度, 默认是32个字节
strace -e signal=... # 跟踪指定信号

top     # 第一行 系统时间 运行时间 用户数 平均负载
        # 第二行 进程总结
        # 第三行 CPU 总结
        # 第四行 物理内存总结
        # 第五行 虚拟内存总结
        # 交互命令
        #   空格 或 回车 刷新
        #   l 切换负载的显示
        #   t 切换任务的显示
        #   m 切换内存的显示
        #   f 选择展示的字段
        #   R 反向排序
        #   c 显示命令名称 或 完整命令行
        #   i 显示空闲任务
        #   u 显示特定用户的进程
        #   k 结束任务
        #   h 帮助
        #   L 搜索字符串
        #   H 显示线程
        #   0 不显示统计值为 0 的项
        #   1   显示所有的cpu信息
        #   < 排序字段左移
        #   > 排序字段右移
        #   M 内存排序
        #   P CPU 排序
        #   T 时间排序
top -n 1   # 刷新次数
top -b     # 方便写入文件
top -c     # 显示完整命令行
top -p ... # 指定 PID
top -u lyb # 指定用户


###################
#
# Bash 基础
#
##################

## 通配符
?      # 代表一个字符
*      # 代表零个或多个字符
[123]
[1-5]
[!a]
[^a]

## 基础正则表达式
^     # 开头
$     # 结尾
.     # 除换行符以外的任意字符
[]    # 中括号中      的任意字符
[^]   # 中括号中字符外的任意字符
?     # 前面字符出现 0 次 或 一次
*     # 前面字符出现 0 次 或 多次
<abc  # 单词以 abc 开头
abc>  # 单词以 abc 结尾

## 扩展正则表达式
+      # 前面字符出现 1 次 或 多次
{n}    # 前面字符出现 n 次
{n,}   # 前面字符出现 n 次 及以上
{n, m} # 前面字符出现 n 次 到 m 次
()     # 将括号内的内容看成一个整体
|      # 或

bash file_name # 执行文件内的命令
bash -c "ls"   # 将字符串的内容交由 bash 执行, 字符串里可包含重定向和管道

* ls &> /dev/null # 重定向
* exec &>> 1.log  # 脚本内重定向

* (ls)            # 子shell执行命令, 输出到屏幕上
* lyb=$(ls)       # 子shell执行命令, 存入变量
* cat <(ls)       # 将命令或函数的输出做为 文件
* lyb=$((1+2))    # 数学计算, 变量不需要加 $
* [[ -a 1.c ]]    # 判断文件的各种状态
* [[ lyb =~ ^l ]] # 扩展的正则表达式
* {ls ... }       # 代码块
* {1..10..2}      # 获取字符序列

length=${#val}       # 输出字符串的长度
${val:起始位置:长度} # 获取子串
lyb=123
lyb=$lyb+123         # lyb 将变成 123+123

${v:-w} # v 不为空, 返回 $v, 否则, 返回 w
${v:=w} # v 不为空, 返回 $v, 否则, 令 v=w, 返回 w
${v:+w} # v 不为空, 返回  w, 否则, 返回空
${v:?w} # v 不为空, 返回 $v, 否则, 输出 w, 退出

lyb=123.456.txt
lyb=${lyb%.*}      # 后缀非贪婪匹配, lyb 为 123.456
lyb=${lyb%%.*}     # 后缀  贪婪匹配, lyb 为 123
lyb=${lyb#*.}      # 前缀非贪婪匹配, lyb 为 456.txt
lyb=${lyb##*.}     # 前缀  贪婪匹配, lyb 为 txt
lyb=${lyb/*./str}  # 全文  贪婪匹配, lyb 为 strtxt, 匹配一次 - TODO
lyb=${lyb//*./str} # 全文  贪婪匹配, lyb 为 strtxt, 匹配多次
lyb=${lyb^^}       # 变为大写
lyb=${lyb,,}       # 变为小写

v=(1 2 3) # 定义数组
${v[1]}   # 数组中指定元素的值
${v[@]}   # 数组中所有元素的值, "1" "2" "3"
${#v[@]}  # 数组中元素的个数
${!v[@]}  # 获取所有的 key

declare -A v # 关联数组, map
v[a]=a
v[b]=b

$0 # 脚本名称
$1 # 第一个参数
$@ # 参数序列
$# # 参数个数

## 脚本上重定向
cat << EOF
    $lyb
EOF

!!    # 上一条命令
!l    # 执行最近使用的以 l 打头的命令
!l:p  # 输出最近使用的以 l 打头的命令
!num  # 执行历史命令列表的第 num 条命令
!$    # 上一条命令的最后一个参数
^1^2  # 将前一条命令中的 1 变成 2

bg %jobspec # 后台暂停 --> 后台运行, 有无 % 都成
fg %jobspec # 后台     --> 前台运行, 有无 % 都成

jobs          # 列出后台作业
jobs %jobspec # 作业号有无 % 都成
jobs -l       #   列出后台作业的 PID
jobs -p       # 只列出后台作业的 PID
jobs -n       # 只列出进程改变的作业
jobs -s       # 只列出停止的作业
jobs -r       # 只列出运行中的作业

Ctrl+A      # 将光标移到行首
Ctrl+B      # 将光标向左移动一个字符
Ctrl+C      # 向前台进程组发送 SIGINT, 默认终止进程
Ctrl+D      # 删除光标前的字符 或 产生 EOF 或 退出终端
Ctrl+E      # 将光标移到行尾
Ctrl+F      # 将光标向右移动一个字符
Ctrl+G      # 响铃
Ctrl+H      # 删除光标前的一个字符
Ctrl+I      # 相当于TAB
Ctrl+J      # 相当于回车
Ctrl+K      # 删除光标处到行尾的字符
Ctrl+L      # 清屏
Ctrl+M      # 相当于回车
Ctrl+N      # 查看历史命令中的下一条命令
Ctrl+O      # 类似回车，但是会显示下一行历史
Ctrl+P      # 查看历史命令中的上一条命令
Ctrl+Q      # 解锁终端
Ctrl+R      # 历史命令反向搜索, 使用 Ctrl+G 退出搜索
Ctrl+S      # 锁定终端 -- TODO 历史命令正向搜索, 使用 Ctrl+G 退出搜索
Ctrl+T      # 交换前后两个字符
Ctrl+U      # 删除光标处到行首的字符
Ctrl+V      # 输入控制字符
Ctrl+W      # 删除光标左边的一个单词
Ctrl+X      #   TODO-列出可能的补全 ?
Ctrl+Y      # 粘贴被删除的字符
Ctrl+Z      # 前台运行的程序 --> 后台暂停
Ctrl+/      # 撤销之前的操作
Ctrl+\      # 产生 SIGQUIT, 默认杀死进程, 并生成 core 文件
Ctrl+xx     # 光标和行首来回切换

Esc+B              # 移动到当前单词的开头(左边)
Esc+F              # 移动到当前单词的结尾(右边)
Esc+.              # 获取上一条命令的最后的部分

Alt+B              # 向后（左边）移动一个单词
Alt+C              # 光标处字符转为大写
Alt+D              # 删除光标后（右边）一个单词
Alt+F              # 向前（右边）移动一个单词
Alt+L              # 光标处到行尾转为小写
Alt+R              # 取消变更
Alt+T              # 交换光标两侧的单词
Alt+U              # 光标处到行尾转为大写
Alt+BACKSPACE      # 删除光标前面一个单词，类似 Ctrl+W，但不影响剪贴板
Alt+.              # 使用上条命令的最后一个单词

Ctrl+X Ctrl+X      # 连续按两次 Ctrl+X，光标在当前位置和行首来回跳转
Ctrl+X Ctrl+E      # 用你指定的编辑器，编辑当前命令
Ctrl+insert        # 复制命令行内容
shift+insert       # 粘贴命令行内容

c++filt  a.out   # 可以解析动态库里的符号

--------------------------------------
## 时间戳 字符串形式 等待

## 学习一个命令需要注意的点
* 不需要了解命令的所有选项, 目的是为了使用, 有一些命令一辈子也用不到, 切记切记
* 支持 通配符, 还是基础的正则表达式 还是 扩展的正则表达式
* 各个选项之间是 且 还是 或
* 如何处理符号连接

#### 获取命令源码
yum install yum-utils
rpm -qf /usr/sbin/pidof        # 查看 命令所属的包
yumdownloader --source ...     # 下载源码包
rpm2cpio ...src.rpm | cpio -id # 转换
tar xvf ...                    # 解压

----------------------------------------
文件名称建议: 大小写字母 数字 下划线 短横线 点

errno 是线程安全的, 如何检验

#### 查看 Linux 临时端口号的范围
```
cat /proc/sys/net/ipv4/ip_local_port_range
32768   60999
``

* [0, 1024) 公认端口号, 需要 root 启动, 比如 80
* [1024, 32768) 注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
* [60990, 65535)

# 查询 域名 对应 的 IP
* nslookup baidu.com

\command # 忽略别名

bc <<< "scale=2; 10/2" # 设置使用两位小数, 输出: 5.00
bc <<< "ibase=2;  100" # 输入使用二进制, 输出: 4
bc <<< "obase=2;   10" # 输出使用二进制, 输出: 1010

flock    1.c ls # 设置文件互斥锁 执行命令, 设置锁失败, 等待
flock -n 1.c ls # 设置文件互斥锁 执行命令, 设置锁失败, 退出

脚本内使用, 保证脚本最多执行一次
[[ "$FLOCKER" != "$0" ]] && exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || :

解释:
1. 第一次进入脚本, 由于变量未设置, 会执行 exec
2. 调用 exec, 使用 env 设置 变量名
3. 执行 flock, 重新执行这个脚本, 执行完脚本后会退出, 不会执行之后的命令
    * 使用脚本名作为 文件锁, 脚本名使用绝对路径, 所以不会重复
4. 第二次进入脚本, 由于变量已设置, 直接往下执行就可以了
5. 在此期间, 如果, 有其他脚本进入, 文件锁获取失败, 就直接退出了

getconf NAME_MAX /
getconf PATH_MAX /

getopt  # a  无参数, a: 有参数
        # -- 表示可选参数的终止
        # 会重新排列参数
        # 可以解析 --bug
        # 可以区分无参数, 有参数, 可选参数的情况
        # -kval 可以当作 -k val 处理
        # 参数带空格可能出问题

getopts # -o 短选项, -l 长选项
        # a 无参数, a: 有参数, a:: 参数可选
        #  -- 表示可选参数的终止
        # 不会重排参数
        # 只能解析 -k, -k val, 不能解析 --bug, -kval
        # 只能区分有参数和无参数的情况
        # 参数带空格也能处理

hd            1.c # 每组一个字节, 显示十六进制
hexdump -C    1.c # 每组一个字节, 显示十六进制
hexdump -c    1.c # 每组一个字节, 显示字符

history

iconv

IFS 默认值: " \t\n"
IFS 包含转义字符时, 需要在开头添加 $, IFS=$'\n'

ip addr
ip route

cat lyb | xargs -i vim {} # 以此编辑 lyb 中的每一个文件


#### 本目录的目的:
* 本目录用于列举最佳实践, 而不是列举所有的可选项, 后者可以查看 man 之类的东西
* 本目录不会列举所有的最佳实践, 只是列举不常见的 或 容易忘记 的可选项, 有些可选项已经是肌肉记忆了

#### 常用命令
apt show    vim # 列出软件包的信息
apt install vim # 安装软件包
apt remove  vim # 卸载软件包
apt purge   vim # 卸载软件包, 删除数据和配置文件
apt update      # 更新软件源
apt upgrade     # 更新软件

dpkg -L vim        # 列出 vim 软件包安装的全部文件
dpkg --search /... # 查看该文件是哪个软件包安装的, 使用绝对路径

df -Th # 所挂载的系统的使用情况
du -sh # 某一目录的使用大小

gcc -0g main.cc
gcc -01 main.cc
gcc -02 main.cc
gcc -03 main.cc

ls     # 列出当前目录中的元素
ls -a  # 列出当前目录中的元素（包括隐藏的文件）
ls -l  # 列出当前目录中的元素的详细信息
ls -F  # 在目录后添加 /，在可执行文件后添加 *
ls -d  # 只列出目录本身，而不列出目录内元素
ls -r  # 逆序列出当前目录中的元素
ls -R  # 递归列出当前目录中的元素
ls -1  # 在每一行列出文件名

ps -ef                  # 显示所有进程的详细信息
ps -o pid,ppid,command  # 按指定格式显示进程的信息
ps -f 123               # 显示指定进程的信息

sort       # 排序
sort -k 4  # 指定排序的列字段
sort -t :  # 指定列的分割符
sort -n    # 以数字进行排序
sort -r    # 逆序
sort -f    # 忽略大小写

yum list installed       # 列出已安装的软件
yum list vim             # 列出某软件包的详细信息
yum list updates         # 列出可用更新
yum provides file_name   # 查看文件属于哪个软件包
yum update package_name  # 更新某个软件包
yum update               # 更新所有软件包
yum install package_name # 安装软件
yum remove  package_name # 卸载软件
yum erase   package_name # 卸载软件，删除数据和文件

