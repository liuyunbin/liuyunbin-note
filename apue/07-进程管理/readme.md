
## 存储布局
* 正文段(text)
    * 存储程序本身, 只读, 可共享
    * 内存中只存储一份, 磁盘中需要存储
* 数据段(data)
    * 存储初始化的全局变量或静态变量
    * 内存中每个进程一份, 磁盘中需要存储
* bss
    * 存储未初始化的全局变量或静态变量
    * 内存中每个进程一份, 磁盘中不需要存储
    * 程序启动时初始化为 0
* 栈: 磁盘中不需要存储
* 堆: 磁盘中不需要存储
    * malloc(): 存储空间分配, 未初始化
    * calloc(): 存储空间分配, 初始化为 0
    * realloc(): 重新存储空间分配
    * free(): 释放内存
* 使用 size 可以查看各个部分的大小

## 共享库
* 静态库: 编译到可执行文件
* 动态库: 启动或运行时, 加载到可执行文件

## 状态及改变
* 就绪
* 运行(R)
* 休眠(S)(可被信号打断)(指被捕获的信号)
    * pause() 只有收到未忽略的信号才返回
    * sleep() 只有收到未忽略的信号 或 到达指定秒数才返回 -- 01.cc
        1. 使用 fork() 产生子进程
        2. 子进程设置信号(SIGUSR1)处理函数
        3. 子进程休眠10s
        4. 父进程休眠1s
        5. 此时, 可以看到, 子进程处于休眠状态
        6. 向子进程发送信号(SIGUSR1)
        7. 此时, 子进程被唤醒(休眠时间小于10s)
* 休眠(D)(不可被信号打断)(指被捕获的信号)
   * 调用 vfork() 后的父进程 -- 02.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程设置信号(SIGUSR1)处理函数
        3. 测试的父进程使用 vfork() 产生测试的子进程
        4. 测试的子进程休眠10s
        5. 测试的父进程休眠1s
        6. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        7. 向测试的父进程发送信号(SIGUSR1)
        8. 此时, 父进程处于不可打断的状态, 所以不会处理
        9. 测试的子进程休眠完成(休眠时间为10s)
        10. 测试的父进程处理信号, 直到结束
   * SIGSTOP 也会被阻塞 -- 03.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程使用 vfork() 产生测试的子进程
        3. 测试的子进程休眠10s
        4. 测试的父进程休眠1s
        5. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        6. 向测试的父进程发送信号(SIGSTOP)
        7. 此时, 父进程处于不可打断的状态, 所以不会处理
        8. 向测试的父进程发送信号(SIGCONT)
        9. 此时, 父进程处于不可打断的状态, 所以不会处理
        10. 测试的子进程休眠完成(休眠时间为10s)
        11. 测试的父进程继续运行, 直到结束
   * SIGKILL 不会被阻塞 -- 04.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程使用 vfork() 产生测试的子进程
        3. 测试的子进程休眠10s
        4. 测试的父进程休眠1s
        5. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        6. 向测试的父进程发送信号(SIGKILL)
        7. 测试的父进程退出
        8. 测试的子进程休眠完成(休眠时间为10s)
        9. 主进程结束
* 暂停(T)(作业控制)
    * 收到信号 SIGSTOP
    * 收到信号 SIGTSTP, 可由 ctrl+z 产生
    * 收到信号 SIGTTIN, 处于后台进程时读终端
    * 收到信号 SIGTTOT, 处于后台进程时写终端, 这个得看设置是否允许后台进程写终端
    * 继续, 收到信号 SIGCONT -- 05.cc
        1. 使用 fork() 产生子进程
        2. 子进程设置信号(SIGUSR1)处理函数
        3. 子进程空循环
        4. 父进程发送信号给子进程(SIGSTOP)
        5. 子进程暂停
        6. 父进程发送信号给子进程(SIGUSR1)
        7. 此时, 子进程处于暂停, 不会处理该信号
        8. 父进程发送信号给子进程(SIGCONT)
        9. 子进程继续, 然后处理 SIGUSR1, 直到结束
* 暂停(t)(由于 DEBUG 产生)
* 空闲(I)
    * 处于不可被打断的休眠状态时, 有时 CPU 是空闲的
* 僵尸(Z)
    * 子进程已退出, 父进程还未处理
* 退出(X)

## 状态变化及原因
```
waitpid(&status) --------- 获取子进程的状态变化的信息
    * WIFEXITED() -------- 正常终止
        * WEXITSTATUS() -- 正常退出的状态
    * WIFSIGNALED() ------ 信号导致退出
        * WTERMSIG() ----- 导致退出的信号
        * WCOREDUMP() ---- 导致产生 core 的信号
    * WIFSTOPPED() ------- 暂停
        * WSTOPSIG() ----- 导致暂停的信号
    * WIFCONTINUED() ----- 继续
    * WNOHANG ------------ 没有子进程退出时, 立刻返回
    * WUNTRACED ---------- 子进程暂停时, 也检测
    * WCONTINUED --------- 子进程继续时, 也检测
```

## 进程启动
```
* fork() --- 产生子进程, 父子进程使用各自的空间
             父子进程的执行顺序不确定
             进程数太多或者超出自己的限制会报错
             实际用户, 有效用户, 保存的 UID, 进程组, 会话, 信号处理等保持不变
             文件锁, 未处理的信号集, 进程时间将被清空
* vfork() -- 产生子进程, 父子进程共享空间
             子进程退出或调用 exec 前, 父进程处于不可被信号打断的休眠状态
* exec() --- 执行命令
             实际用户, 实际组不变
             设置了用户ID, 有效用户变为文件所有者, 否则不变
```

## 进程终止
```
1. 主函数返回
2. 调用 exit():
    * 调用 atexit() 登记的函数
    * 调用析构函数
    * 刷新标准IO流, 关闭文件描述符
3. 调用 _exit() 或 _Exit()
    * 直接进入内核, 关闭文件描述符
4. 最后一个线程返回
5. 最后一个线程退出: 调用 pthread_exit()
6. 调用 abort() -- 异常终止
7. 最后一个线程被取消: 调用 pthread_cancel()
```

## 环境变量
* getenv(): 获取环境变量
* putenv(): 设置环境变量

## 跨函数跳转
* longjmp()
*  setjmp()

## 资源使用
* getrlimit(): 获取资源使用的限制
* setrlimit(): 设置资源使用的限制
    * 软限制值可以任意修改, 只要小于等于硬限制值即可
    * 硬限制值可以降低, 只要大于等于软限制值即可
    * 只有超级用户才可以提高硬限制值

## 进程的用户和组信息
* 实际用户
    * getuid()
    * setuid(uid)
    * setreuid()
* 进程的实际组
    * getgid()
* 进程的有效用户
    * geteuid()
    * seteuid()
* 进程的有效组
    * getegid()
* 进程的附属组ID
* 进程的设置的用户ID
* 进程的设置的组ID

## 进程时间
* 时间耗时
* 用户 CPU 时间
* 相同 CPU 时间

## 工作目录
* getcwd()
* getwd()
* `get_current_dir_name()`
* chdir() ----- 修改当前目录
* fchdir() ---- 修改当前目录

## 优先级 -- 值越小, 优先级越高
* nice()
* getpriority()
* setpriority()

## 其他信息
* 进程ID ---------- getpid()
* 父进程ID -------- getppid()
* getlogin() ------ 获取登录名称, 登录名称可有多个
* uname() --------- 主机信息

## 解释器文件
* 第一行以 `#!` 开头
* 等价于: 解释器文件第一行(不包括 #!) + 解释器文件 + 其他参数

## 常用文件
```
/proc/loadavg     # 系统负载
/proc/cpuinfo     # cpu 信息
/proc/uptime      # 运行时间
/proc/sys

/proc/PID/cmdline # 完整的启动命令
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/comm    # 进程名称, 不包含路径名称, 最多 15 位
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/cwd     # 进程当前的目录
/proc/PID/exe     # 符号链接, 指向运行的进程
/proc/PID/environ # 进程使用的环境变量
/proc/PID/fd      # 进程所打开的文件描述符
/proc/PID/limits  # 进程对各种资源的限制
/proc/PID/task    # 进程使用的线程情况
```

