
## 动态库
* 内存中只存储一份
* 磁盘中只存储一份


## 静态库

## 进程间通信
* 文件
* 信号
* 信号量
* 匿名管道
* 命名管道
* socket
* 域 socket
* 消息队列
* 共享内存

# 计算机操作系统
## 进程管理
### 存储布局
* 正文段(text)
    * 存储程序本身, 只读, 可共享
    * 内存中只存储一份, 磁盘中需要存储
* 数据段(data)
    * 存储初始化的全局变量或静态变量
    * 内存中每个进程一份, 磁盘中需要存储
* bss
    * 存储未初始化的全局变量或静态变量
    * 内存中每个进程一份, 磁盘中不需要存储
    * 程序启动时初始化为 0
* 栈: 磁盘中不需要存储
* 堆: 磁盘中不需要存储
* 使用 size 可以查看各个部分的大小

### 共享库
* 静态库: 编译到可执行文件
* 动态库: 启动或运行时, 加载到可执行文件

## 状态及改变
* 就绪
* 运行(R)
* 休眠(S)(可被信号打断)(指被捕获的信号)
    * pause() 只有收到未忽略的信号才返回
    * sleep() 只有收到未忽略的信号 或 到达指定秒数才返回 -- 01.cc
        1. 使用 fork() 产生子进程
        2. 子进程设置信号(SIGUSR1)处理函数
        3. 子进程休眠10s
        4. 父进程休眠1s
        5. 此时, 可以看到, 子进程处于休眠状态
        6. 向子进程发送信号(SIGUSR1)
        7. 此时, 子进程被唤醒(休眠时间小于10s)
* 休眠(D)(不可被信号打断)(指被捕获的信号)
   * 调用 vfork() 后的父进程 -- 02.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程设置信号(SIGUSR1)处理函数
        3. 测试的父进程使用 vfork() 产生测试的子进程
        4. 测试的子进程休眠10s
        5. 测试的父进程休眠1s
        6. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        7. 向测试的父进程发送信号(SIGUSR1)
        8. 此时, 父进程处于不可打断的状态, 所以不会处理
        9. 测试的子进程休眠完成(休眠时间为10s)
        10. 测试的父进程处理信号, 直到结束
   * SIGSTOP 也会被阻塞 -- 03.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程使用 vfork() 产生测试的子进程
        3. 测试的子进程休眠10s
        4. 测试的父进程休眠1s
        5. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        6. 向测试的父进程发送信号(SIGSTOP)
        7. 此时, 父进程处于不可打断的状态, 所以不会处理
        8. 向测试的父进程发送信号(SIGCONT)
        9. 此时, 父进程处于不可打断的状态, 所以不会处理
        10. 测试的子进程休眠完成(休眠时间为10s)
        11. 测试的父进程继续运行, 直到结束
   * SIGKILL 不会被阻塞 -- 04.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程使用 vfork() 产生测试的子进程
        3. 测试的子进程休眠10s
        4. 测试的父进程休眠1s
        5. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        6. 向测试的父进程发送信号(SIGKILL)
        7. 测试的父进程退出
        8. 测试的子进程休眠完成(休眠时间为10s)
        9. 主进程结束
* 暂停(T)(作业控制)
    * 收到信号 SIGSTOP
    * 收到信号 SIGTSTP, 可由 ctrl+z 产生
    * 收到信号 SIGTTIN, 处于后台进程时读终端
    * 收到信号 SIGTTOT, 处于后台进程时写终端, 这个得看设置是否允许后台进程写终端
    * 继续, 收到信号 SIGCONT -- 05.cc
        1. 使用 fork() 产生子进程
        2. 子进程设置信号(SIGUSR1)处理函数
        3. 子进程空循环
        4. 父进程发送信号给子进程(SIGSTOP)
        5. 子进程暂停
        6. 父进程发送信号给子进程(SIGUSR1)
        7. 此时, 子进程处于暂停, 不会处理该信号
        8. 父进程发送信号给子进程(SIGCONT)
        9. 子进程继续, 然后处理 SIGUSR1, 直到结束
* 暂停(t)(由于 DEBUG 产生)
* 空闲(I)
    * 处于不可被打断的休眠状态时, 有时 CPU 是空闲的
* 僵尸(Z)
    * 子进程已退出, 父进程还未处理
* 退出(X)

## 进程启动
```
* fork() --- 产生子进程, 父子进程使用各自的空间
             父子进程的执行顺序不确定
             进程数太多或者超出自己的限制会报错
             实际用户, 有效用户, 保存的 UID, 进程组, 会话, 信号处理等保持不变
             文件锁, 未处理的信号集, 进程时间将被清空
* vfork() -- 产生子进程, 父子进程共享空间
             子进程退出或调用 exec 前, 父进程处于不可被信号打断的休眠状态
* exec() --- 执行命令
             实际用户, 实际组不变
             设置了用户ID, 有效用户变为文件所有者, 否则不变
```

## 进程的用户和组信息
* 实际用户
* 进程的实际组
* 进程的有效用户
* 进程的有效组
* 进程的附属组ID
* 进程的设置的用户ID
* 进程的设置的组ID

## 常用文件
```
/proc/loadavg     # 系统负载
/proc/cpuinfo     # cpu 信息
/proc/uptime      # 运行时间
/proc/sys

/proc/PID/cmdline # 完整的启动命令
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/comm    # 进程名称, 不包含路径名称, 最多 15 位
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/cwd     # 进程当前的目录
/proc/PID/exe     # 符号链接, 指向运行的进程
/proc/PID/environ # 进程使用的环境变量
/proc/PID/fd      # 进程所打开的文件描述符
/proc/PID/limits  # 进程对各种资源的限制
/proc/PID/task    # 进程使用的线程情况
```



## 进程表项
* 文件描述符
* 文件描述符标志(`close_on_exec`)
   * 执行 exec 时, 是否关闭
   * 可由 fcntl() 修改
* 指向文件表项的指针

## 文件表项
* 文件状态标志(读 写 添加 非阻塞等)
    * 可由 fcntl() 修改
* 文件偏移量
* 指向v节点的指针
* 子进程复制文件表项
* 使用 dup2() 也可以复制文件表项

## 不带缓冲的IO
* umask() ---- 新建文件时, 权限的屏蔽位
* open() ----- 打开文件, 原子操作
* close() ---- 关闭文件, 原子操作
* read() ----- 读文件
* readv() ---- 读文件, 使用不连续的存储结构
* readn() ---- 读文件, 全部读取
* write() ---- 写文件
* writev() --- 写文件, 使用不连续的存储结构
* writen() --- 写文件, 全部写入
* lseek() ---- 移动文件偏移量, 可能生产空洞, 空洞不占磁盘空间
* dup2() ----- 复制文件描述符
* fcntl()
    * 复制文件描述符(包括 exec 时, 是否关闭)
    * 查看和设置文件描述符(exec 时, 是否关闭)
    * 查看和设置文件状态标志(读写添加等等)
    * 异步属性
    * 文件锁
* ioctl() ----- 主要处理终端
* truncate() -- 文件截断
* select()
    * 返回已就绪的文件描述符的个数
    * 超时精确到微秒
    * 需要从头开始遍历文件描述符
* pselect()
    * 返回已就绪的文件描述符的个数
    * 超时精确到纳秒
    * 需要从头开始遍历文件描述符
    * 可选择屏蔽的信号
* poll()
    * 返回已就绪的文件描述符的数组
* epoll()
    * 操作某一个文件描述符, 结构在内核, 提高了效率

## 标准IO
* 打开文件
    * fopen() ---- 使用文件名
    * freopen() -- 重新打开
    * fdopen() --- 使用文件描述符
* 关闭文件: fclose()
* 读写数据(字符)
    * getc() ----- 读取字符, 可能是宏
    * fgetc() ---- 读取字符
    * getchar() -- 读取字符
    * ungetc() --- 压回字符
    * putc() ----- 输出字符, 可能是宏
    * fputc() ---- 输出字符
    * putchar() -- 输出字符
* 读写数据(行)
    * gets() ----- 读取, 不建议使用
    * puts() ----- 输出字符串, 然后输出换行符, 不建议使用
    * fgets() ---- 换行符也会被读取, 不一定能读取完整的行
    * fputs() ---- 输出字符串
* 读写数据(二进制)
    * fread() ---- 读数据
    * fwrite() --- 写数据
    * ftell() ---- 获取流位置
    * fseek() ---- 设置流位置
    * rewind() --- 重置流位置
* 格式化 IO
    * printf() ----- 输出到标准输出
    * fprintf() ---- 输出到标准IO
    * dprintf() ---- 输出到文件描述符
    * sprintf() ---- 输出到字符串
    * snprintf() --- 输出到字符串
    * vprintf() ---- 使用可变参数 va
    * vfprintf() --- 使用可变参数 va
    * vdprintf() --- 使用可变参数 va
    * vsprintf() --- 使用可变参数 va
    * vsnprintf() -- 使用可变参数 va
    * scanf() ------ 输入(标准输入)
    * fscanf() ----- 输入(流)
    * sscanf() ----- 输入(字符串)
    * vscanf() ----- 使用可变参数 va
    * vfscanf() ---- 使用可变参数 va
    * vsscanf() ---- 使用可变参数 va
* 错误
    * ferror() ----------- 发生错误
    * feof() ------------- 读到文件结尾
    * clearerr() --------- 清除错误
    * strerror() --------- 错误码 => 提示信息
    * errno -------------- 错误码, 线程安全
    * error() ------------ 打印错误并退出
    * `error_at_line()` -- 打印错误并退出
    * perror() ----------- 输出字符串, 以及错误的原因, 一般将程序名称作为参数
* fileno() 流 --> 文件描述符
* 缓冲 -- 1.cc
    * 全缓冲(磁盘)
        * 填满缓冲区才缓冲
    * 行缓冲(终端)
        * 要到换行符或填满缓冲区才缓冲
        * 遇到读操作(从内核)
    * 不缓冲
        * 输出错误
    * setvbuf() -- 设置缓冲类型
    * fflush() --- 强行刷新缓冲


