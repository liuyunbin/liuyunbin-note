
## 目标:
* 周期执行脚本
* 保证脚本不会同时运行多个
* 保证 log 正常输出到指定位置

## 技术准备
### crontab 用于固定时间 或 间隔 启动任务

#### 常用命令
* 查询任务表: crontab -l
* 编辑任务表: crontab -e
* 删除任务表: crontab -r

#### 注意
* 如果需要 .bashrc 的内容, 需要在脚本中执行

#### 配置格式: f1 f2 f3 f4 f5 exe
* 分别表示 分钟(0-59), 小时(0-23), 日(1-31), 月(1-12), 星期几(0-6, 星期天为 0)
* `*` 表示每分钟等都执行
* `1-3` 表示 1 到 3分钟内执行, 每分钟执行
* `*/3` 表示每 3 分钟执行一次
* `1-10/3` 表示 1-10 分钟内, 每 3 分钟执行一次
* `1,3,5` 表示 1,3,5 分钟执行

### exec
* `exec ls`: 执行后面的命令, 然后退出, 不再执行之后的命令
* `exec &>> 1.log`: 在当前的 shell, 将标准输出, 标准错误 输出到文件, 会继续执行后续的命令

### env: 设置环境变量, 然后执行之后的命令

### flock: 设置文件锁
#### 常用参数
* -n 表示, 如果获取文件锁失败, 直接退出, 不再等待
* -e 表示, 使用互斥锁, 默认即是互斥锁
* -c 执行一个单独的命令

#### 常用命令解释
```
[[ "$FLOCKER" != "$0" ]] && exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || :
```

解释:

1. 第一次进入脚本, 由于变量未设置, 会执行 exec
2. 调用 exec, 使用 env 设置 变量名
3. 执行 flock, 重新执行这个脚本, 执行完脚本后会退出, 不会执行之后的命令
    * 使用脚本名作为 文件锁, 脚本名使用绝对路径, 所以不会重复
4. 第二次进入脚本, 由于变量已设置, 直接往下执行就可以了
5. 在此期间, 如果, 有其他脚本进入, 文件锁获取失败, 就直接退出了

### readlink
#### 常用命令
* -f 递归获取符号链接对应的文件

## 实践:
### 第一步: 写一个脚本 /opt/kds/bin/test.sh, 模拟其耗时 3 分钟
```
#!/bin/bash
echo -n "休眠 180s 中..."
sleep 180
echo "完成"
```

### 第二步: 使用 crontab 将其加入到循环执行中, 每分钟执行一次, 并重定向 log
```
$ crontab -e
* * * * * /opt/kds/bin/test.sh &>> /opt/kds/bin/test.log
```

### 第三步: 查看日志发现, 日志混乱
由于脚本的执行周期是一分钟, 而脚本的耗时是 3 分钟, 所有, 某一时刻, 有多个脚本同时在运行

### 第四步: 确保脚本只运行一个
#### 在脚本开头增加这一行, 解释见上:
```
[[ "$FLOCKER" != "$0" ]] && exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || :
```

### 第五步, 在脚本中重定向 log, 可以省去在 crontab 的时候, 指定日志目录
```
cmd_path=$(dirname $(readlink -f $0))
exec &>> $cmd_path/test.log
```

### 第六步, 重新编辑 crontab 命令, 简化不少
```
$ crontab -e
* * * * * /opt/kds/bin/test.sh
```

至此, 就实现了上述目标

## 总结:
### 完整脚本如下:
```
#!/bin/bash

# 使用文件锁, 保证脚本最多运行一个
[[ "$FLOCKER" != "$0" ]] && exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || :

# 指定 log 路径
cmd_path=$(dirname $(readlink -f $0))
exec &>> $cmd_path/test.log

echo -n "休眠 180s 中..."
sleep 180
echo "完成"
```

### 使用 crontab 周期执行
```
$ crontab -e
* * * * * /opt/kds/bin/test.sh
```

