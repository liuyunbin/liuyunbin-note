
## 简介
* Bash 是 Linux 的默认 shell
* Bash 是脚本, 一门编程语言

## 特殊字符 -- 要使用原字符必须转义
* 没引号包含
    * {} => 变量分割符 或 将语句封装成块
    * [] => 通配符 或 数字计算等等
    * () => 子shell
    * $  => 读取变量, 无值时默认忽略
    * !  => 一些快捷的方式获取命令或参数
    * ;  => 命令的分割符
    * #  => 每行第一个非空字符表示该行是注释
    * -  => 字符串以 - 开头表示是可选参数
    * -- => 后面的字符串都不是可选参数
    * '  => 单引号
    * "  => 双引号
* 单引号包含:
    * '  => 单引号
* 双引号包含:
    * $  => 读取变量, 无值时默认忽略
    * !  => 一些快捷的方式获取命令或参数
    * "  => 双引号

## 括号 -- 只列举常用的情况
* ls [1-5]*       # 通配符
* (ls)            # 子shell执行命令, 输出到屏幕上
* lyb=$(ls)       # 子shell执行命令, 存入变量
* cat <(ls)       # 将命令或函数的输出做为 文件
* lyb=$((1+2))    # 数学计算, 变量不需要加 $
* [[ -a 1.c ]]    # 判断文件的各种状态
* [[ lyb =~ ^l ]] # 扩展的正则表达式匹配
* {ls ... }       # 代码块
* {1..10..2}      # 获取字符序列

## IFS 字段分割符
IFS 默认值: " \t\n"
IFS 包含转义字符时, 需要在开头添加 $, IFS=$'\n'

## 基本类型
* 变量:
    * 跟在 $ 后的字符串, 比如, $lyb, ${lyb}
    * 一些特殊的语法里, 字符串前有无 $ 都表示是变量
    * ${v:-w}              # v 不为空, 返回 $v, 否则, 返回 w
    * ${v:=w}              # v 不为空, 返回 $v, 否则, 令 v=w, 返回 w
    * ${v:+w}              # v 不为空, 返回  w, 否则, 返回空
    * ${v:?w}              # v 不为空, 返回 $v, 否则, 输出 w, 退出
    * ${#val}              # 输出字符串的长度
    * ${val:起始位置:长度} # 获取子串
    * lyb=123
    * lyb=$lyb+123         # lyb 将变成 123+123
    * lyb=123.456.txt
    * lyb=${lyb%.*}        # 后缀非贪婪匹配, lyb 为 123.456
    * lyb=${lyb%%.*}       # 后缀  贪婪匹配, lyb 为 123
    * lyb=${lyb#*.}        # 前缀非贪婪匹配, lyb 为 456.txt
    * lyb=${lyb##*.}       # 前缀  贪婪匹配, lyb 为 txt
    * lyb=${lyb/*./str}    # 全文  贪婪匹配, lyb 为 strtxt, 匹配一次 - TODO
    * lyb=${lyb//*./str}   # 全文  贪婪匹配, lyb 为 strtxt, 匹配多次
    * lyb=${lyb^^}         # 变为大写
    * lyb=${lyb,,}         # 变为小写
* 字符串:
    * 单引号 或 双引号包含的字符串
    * 无引号包含且前面没有 $ 时, 不绝对
* 索引数组:
    * v=(1 2 3) # 初始化数组, 以空字符分割多个元素
    * ${v[1]}   # 数组中指定元素的值
    * ${v[-1]}  # 数组中最后一个元素的值
    * ${v[@]}   # 数组中所有元素的值, "1" "2" "3"
    * ${#v[@]}  # 数组中元素的个数
    * ${!v[@]}  # 获取所有的 key
* 关联数组:
    * declare -A v # 关联数组, map
    * v[a]=a       # 赋值
    * v[-1]=b      # 以 -1 作为 key
                   # 其他同索引数组

## 脚本相关

$0 # 脚本名称
$1 # 第一个参数
$@ # 参数序列
$# # 参数个数

set -o nounset  # 使用未初始化的变量报错, 同 -u
set -o errexit  # 只要发生错误就退出, 同 -e
set -o pipefail # 只要管道发生错误就退出
set -o errtrace # 函数报错时, 也处理 trap ERR, 同 set -E
set -o  xtrace  # 执行前打印命令, 同 -x
set -o verbose  # 读取前打印命令, 同 -v
set -o vi       # 使用 vi 快捷键
set -- ....     # 重新排列参数

建议使用: set -ueo pipefail

### 脚本上重定向
解释变量 lyb
cat << EOF
    $lyb
EOF

不解释变量 lyb
cat << 'EOF'
    $lyb
EOF

### 脚本参数
getopt  # a  无参数, a: 有参数
        # -- 表示可选参数的终止
        # 会重新排列参数
        # 可以解析 --bug
        # 可以区分无参数, 有参数, 可选参数的情况
        # -kval 可以当作 -k val 处理
        # 参数带空格可能出问题
getopts # -o 短选项, -l 长选项 -- 一般使用这个, 要求参数在前, 参数不包括空格
        # a 无参数, a: 有参数, a:: 参数可选
        #  -- 表示可选参数的终止
        # 不会重排参数
        # 只能解析 -k, -k val, 不能解析 --bug, -kval
        # 只能区分有参数和无参数的情况
        # 参数带空格也能处理

### exec
exec &>> 1.log  # 脚本内重定向
exec ls         # 替换当前 shell, 执行后不再执行之后的命令
exec &>  1.txt  # 打开文件描述符, 然后继续执行之后的命令

### trap
trap ... ERR  # 发生错误退出时, 执行指定命令
trap ... EXIT # 任意情况退出时, 执行指定命令

## 其他 bash 操作
bash file_name # 执行文件内的命令
bash -c "ls"   # 将字符串的内容交由 bash 执行, 字符串里可包含重定向和管道

ls &> /dev/null # 重定向

!!    # 上一条命令
!l    # 执行最近使用的以 l 打头的命令
!l:p  # 输出最近使用的以 l 打头的命令
!num  # 执行历史命令列表的第 num 条命令
!$    # 上一条命令的最后一个参数
^1^2  # 将前一条命令中的 1 变成 2

bg %jobspec # 后台暂停 --> 后台运行, 有无 % 都成
fg %jobspec # 后台     --> 前台运行, 有无 % 都成

jobs          # 列出后台作业
jobs %jobspec # 作业号有无 % 都成
jobs -l       #   列出后台作业的 PID
jobs -p       # 只列出后台作业的 PID
jobs -n       # 只列出进程改变的作业
jobs -s       # 只列出停止的作业
jobs -r       # 只列出运行中的作业

read name     # 读取, 如果参数值小于字段数, 多余的值放入最后一个字段

sleep 30   # 前台运行
sleep 30 & # 后台运行

\command # 忽略别名

env          # 设置环境变量, 然后执行程序

getconf NAME_MAX / # 获取变量的值
getconf PATH_MAX /

history

## 常用快捷键
Ctrl+A      # 将光标移到行首
Ctrl+B      # 将光标向左移动一个字符
Ctrl+C      # 向前台进程组发送 SIGINT, 默认终止进程
Ctrl+D      # 删除光标前的字符 或 产生 EOF 或 退出终端
Ctrl+E      # 将光标移到行尾
Ctrl+F      # 将光标向右移动一个字符
Ctrl+G      # 响铃
Ctrl+H      # 删除光标前的一个字符
Ctrl+I      # 相当于TAB
Ctrl+J      # 相当于回车
Ctrl+K      # 删除光标处到行尾的字符
Ctrl+L      # 清屏
Ctrl+M      # 相当于回车
Ctrl+N      # 查看历史命令中的下一条命令
Ctrl+O      # 类似回车，但是会显示下一行历史
Ctrl+P      # 查看历史命令中的上一条命令
Ctrl+Q      # 解锁终端
Ctrl+R      # 历史命令反向搜索, 使用 Ctrl+G 退出搜索
Ctrl+S      # 锁定终端 -- TODO 历史命令正向搜索, 使用 Ctrl+G 退出搜索
Ctrl+T      # 交换前后两个字符
Ctrl+U      # 删除光标处到行首的字符
Ctrl+V      # 输入控制字符
Ctrl+W      # 删除光标左边的一个单词
Ctrl+X      #   TODO-列出可能的补全 ?
Ctrl+Y      # 粘贴被删除的字符
Ctrl+Z      # 前台运行的程序 --> 后台暂停
Ctrl+/      # 撤销之前的操作
Ctrl+\      # 产生 SIGQUIT, 默认杀死进程, 并生成 core 文件
Ctrl+xx     # 光标和行首来回切换

Esc+B              # 移动到当前单词的开头(左边)
Esc+F              # 移动到当前单词的结尾(右边)
Esc+.              # 获取上一条命令的最后的部分

Alt+B              # 向后（左边）移动一个单词
Alt+C              # 光标处字符转为大写
Alt+D              # 删除光标后（右边）一个单词
Alt+F              # 向前（右边）移动一个单词
Alt+L              # 光标处到行尾转为小写
Alt+R              # 取消变更
Alt+T              # 交换光标两侧的单词
Alt+U              # 光标处到行尾转为大写
Alt+BACKSPACE      # 删除光标前面一个单词，类似 Ctrl+W，但不影响剪贴板
Alt+.              # 使用上条命令的最后一个单词

Ctrl+X Ctrl+X      # 连续按两次 Ctrl+X，光标在当前位置和行首来回跳转
Ctrl+X Ctrl+E      # 用你指定的编辑器，编辑当前命令
Ctrl+insert        # 复制命令行内容
shift+insert       # 粘贴命令行内容

