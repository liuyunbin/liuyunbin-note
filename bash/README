
#TODO
jobs 
history

cp 时间, 如何处理符号链接
more
less
unix2dos
iconv
col

## Bash 内置
bash 文件名   # 执行文件内的命令
bash -c "ls"  # 将字符串的内容交由 bash 执行, 字符串里可包含重定向和管道

set -o nounset  # 使用未初始化的变量报错, 同 -u
set -o errexit  # 只要发生错误就退出 -e
set -o pipefail # 只要管道发生错误就退出
set -E          # 即使意外退出, 也会执行 trap 命令
set -o xtrace   # 执行前打印命令i, 同 -x

<, 1<            # 重定向标准输入
>, 1>, >>, 1>>   # 重定向标准输出
   2>,     2>>   # 重定向标准错误
   &>,     &>>   # 同时重定向标准输出和标准错误
    >&2          # 重定向到文件描述符对应的文件上, > 必须和 & 紧挨着
exec &>> lyb.log # 脚本内重定向
exec 3<> lyb.log # 脚本内重定向, 创建读写文件描述符
exec 3>&-        # 关闭文件描述符

!!                 # 执行上一条命令
!l                 # 执行最近使用的以 l 打头的命令
!l:p               # 输出最近使用的以 l 打头的命令
!num               # 执行历史命令列表的第 num 条命令
!$                 # 表示上一条命令的最后一个参数

\command # 忽略别名

### 字符串
length=${#val}       # 输出字符串的长度
${val:起始位置:长度} # 获取子串

${var}          # 取变量的值
${var:-word}    # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 返回 word
${var:=word}    # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 设置 var=word, 然后返回 word
${var:+word}    # 如果 var 存在, 且不为空, 则返回 word 的值, 否则, 返回 空
${var:?message} # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 返回 输出 message, 并退出

lyb=123.456.txt
lyb=${lyb%.*}       # 后缀非贪婪匹配, lyb 为 123.456
lyb=${lyb%%.*}      # 后缀  贪婪匹配, lyb 为 123
lyb=${lyb#*.}       # 前缀非贪婪匹配, lyb 为 txt
lyb=${lyb##*.}      # 前缀  贪婪匹配, lyb 为 456.txt
lyb=${lyb/*./str}   # 全文  贪婪匹配, lyb 为 txt, 匹配一次
lyb=${lyb//*./str}  # 全文  贪婪匹配, lyb 为 txt, 匹配多次
lyb=${lyb^^}        # 变为大写
lyb=${lyb,,}        # 变为小写

### IFS
* IFS 的默认值是: " \t\n"
* 查看 IFS 值: echo -n "$IFS" | hexdump
* IFS 包含转义字符时, 需要在开头添加 $, IFS=$'\n'
* IFS 为默认值 或 " \t\n" 时
    * 整个对象开头和结尾的空字符都将忽略
        * for 遍历 str="   123 456 789  " 时, 将生成 3 个串: 123 456 789
    * 对象内部连续的空字符都将当作一个字符
        * for 遍历 str="123   456    789" 时, 将生成 3 个串: 123 456 789
* IFS 为其他值时, 假定: IFS="a "
    * 如果, IFS 包含空字符, 对象内部连续的空字符都将当作一个字符
        * for 遍历 str="123      456a789" 时, 将生成 3 个串: 123 456 789
    * 其他字符连续出现时, 将当作多个分隔符
        * for 遍历 str="123aa456a789" 时, 将生成 4 个串: 123 空字符串 456 789
    * $*, ${str[*]}: 将使用 IFS 的第一个字符连起来
        * str=(1 2 3); echo "${str[*]" 将输出: 1a2a3
    * 对象末尾的分割符将被忽略
        * for 遍历 str="123aa456a789a" 时, 将生成 4 个串: 123 空字符串 456 789

### 内置的 echo 将以 IFS 切分参数, 输出以空格隔开
* echo  123   456   789  # 将输出: 123 456 789
* echo "123   456   789" # 将输出: 123   456  789, 原样输出

### 数组
v=(1 2 3) # 定义数组
${v[1]}   # 数组中指定元素的值
${v[*]}   # 数组中所有元素的值, "1 2 3"
${v[@]}   # 数组中所有元素的值, "1" "2" "3"
${#v[*]}  # 数组中元素的个数
${#v[@]}  # 数组中元素的个数
${!v[@]}  # 获取所有的 key
${!v[*]}  # 获取所有的 key

declare -A v # 关联数组, map
v[a]=a
v[b]=b

{1..10..2}  # 获取字符序列

### 条件判断
[[]]        # 字符串判断

### 运算
v=$[1+3]       # v == 4
 ((1+3))       # 数字表达式求值, 返回 0 或 1
$((1+3))       # 数字表达式求值, 返回 求值的结果 4

### 子shell
(ls)
v=`ls`   # v 为 ls 的结果
v=$(ls)  # v 为 ls 的结果
<()      # 将命令 或 函数的输出做为 文件, 命令要有打开 文件 的动作

source .bashrc # 当前 shell 执行, 变量等会影响当前 shell
     . .bashrc # 同上
./bin.sh       # 在子 shell 中执行, 变量等不会影响当前 shell
exec ls        # 替换当前 shell, 执行后不再执行之后的命令
exec 3<>1.txt  # 打开文件描述符, 然后继续执行之后的命令
env            # 设置环境变量, 然后执行程序

### 通配符
?: 代表一个字符
*: 代表零个或多个字符
[123]
[1-5]
[!a]

### 正则表达式 ##TODO

### 脚本
#### 解析命令行参数
* -- 表示可选参数的终止
* getopt
    * 会重新排列参数
    * 可以解析 --bug
    * 可以区分无参数, 有参数, 可选参数的情况
    * -kval 可以当作 -k val 处理
    * 参数带空格可能出问题
* getopts
    * 不会重排参数
    * 只能解析 -k, -k val, 不能解析 --bug, -kval
    * 只能区分有参数和无参数的情况
    * 参数带空格也能处理

$0 # 脚本名称
$1 # 第一个参数
$* # 所有参数拼成一个字符串
$@ # 参数序列
$# # 参数个数

## 定时任务
crontab -l # 查询任务表
crontab -e # 编辑任务表
crontab -r # 删除任务表
f1 f2 f3 f4 f5 exe # 分别表示 分钟(0-59), 小时(0-23), 日(1-31),
                   #          月(1-12), 星期几(0-6, 星期天为 0), 执行的程序
                   # * 表示每分钟等都执行
                   # 1-3 表示 1 到 3分钟内执行
                   # */3 表示每 3 分钟执行一次
                   # 1-10/3 表示 1-10 分钟内, 每 3 分钟执行一次
                   # 1,3,5 表示 1,3,5 分钟执行

## 安装程序
apt show    vim # 列出软件包的信息
apt install vim # 安装软件包
apt remove  vim # 卸载软件包
apt purge   vim # 卸载软件包, 删除数据和配置文件
apt update      # 更新软件源
apt upgrade     # 更新软件

dpkg -L vim        # 列出 vim 软件包安装的全部文件
dpkg --search /... # 查看该文件是哪个软件包安装的, 使用绝对路径

yum list installed       # 列出已安装的软件
yum list vim             # 列出某软件包的详细信息
yum list updates         # 列出可用更新
yum provides file_name   # 查看文件属于哪个软件包
yum update package_name  # 更新某个软件包
yum update               # 更新所有软件包
yum install package_name # 安装软件
yum remove  package_name # 卸载软件
yum erase   package_name # 卸载软件，删除数据和文件

## 计算器 bc
echo "scale=2; 10/2" | bc # 设置使用两位小数, 输出: 5.00
echo "ibase=2;  100" | bc # 输入使用二进制, 输出: 4
echo "obase=2;   10" | bc # 输出使用二进制, 输出: 1010

## 文件
* mtime 修改时间: 文件内容的变化, 修改文件时, 另外两个时间也会变化
* atime 访问时间: 读文件的时间变化
* ctime 状态时间: 修改权限, 所有者, 大小等等

chmod u=rwx g=rw o=r filename # 修改文件权限
chmod a+x filename            # 添加 用户, 组, 其他的 可执行 权限
chmod  +x filename            # 添加 用户, 组, 其他的 可执行 权限
chmod  -x filename            # 删除 用户, 组, 其他的 可执行 权限
chmod 655 filename            # 使用数字设置权限
chmod u+s executable_file     # 设置 setuid权限, 允许其他用户以文件所有者的身份来执行文件
chmod g+s executable_file     # 设置 setgid权限, 允许其他用户以文件所属组的身份来执行文件
chmod o+t directory_name      # 设置 粘滞位, 只有目录的所有者才能够删除目录中的文件
chown lyb:lyb  filename       # 修改文件所属的用户和组

chattr +i file # 设置文件不可修改
chattr -i file # 取消文件不可修改的属性

tail -f * # 动态查看新增内容

kill PID    # 进程ID
killall vim # 进程名称

## SUIG, SGID, SGID
suid:
* 只针对文件生效
* 只针对二进制文件生效
* 命令运行时, 拥有命令所属用户的权限
* chmod  u+s filename
* chmod 4755 filename
* 没有可执行权限时, 展示 S
*   有可执行权限时, 展示 s

sgid:
* 对文件:
    * 只针对二进制文件生效
    * 命令运行时, 拥有命令所属组的权限
* 对目录:
    * 在此目录下新增的文件所属的组是此目录所属的组, 而不是此用户所属的组
* chmod  g+s filename
* chmod 2755 filename
* 没有可执行权限时, 展示 S
*   有可执行权限时, 展示 s

sbit:
* 只针对目录生效
* 此目录下的文件只有自己可以删除
* chmod  o+t filename
* chmod 1755 filename
* 没有可执行权限时, 展示 T
*   有可执行权限时, 展示 t

## docker
docker run ubuntu:15.10     /bin/ls                 # 启动 docker 并执行命令 ls
docker run ubuntu:15.10 -it /bin/bash               # 使用交互式终端
docker run ubuntu:15.10 -d                          # 使用后台模式, 返回容器 ID
docker run ubuntu:15.10 -d --name "lyb"             # 给 docker 起一个名字
docker run ubuntu:15.10 -d --net=host               # 主机和 docker 共享 IP 和 端口号
docker run ubuntu:15.10 -d -P                       # docke 内使用随机端口映射主机端口
docker run ubuntu:15.10 -d -p 2000:3000             # 将本机的端口号 2000 绑定到docker 的 3000
docker run ubuntu:15.10 -d -v /home/123:/home/456   # 将本机目录 /home/123 绑定到 docker 的 /home/456

docker port     容器ID                   # 查看端口号映射
docker ps                                # 列出当前运行的容器
docker ps -a                             # 列出所有容器
docker logs     容器ID                   # 查看容器的输出
docker start    容器ID                   # 启动容器
docker stop     容器ID                   # 停止容器
docker restart  容器ID                   # 重新启动容器
docker rm -f    容器ID                   # 删除容器
docker attach   容器ID                   # 进入在后台运行的容器
docker exec -it 容器ID /bin/bash         # 对于在后台运行的容器, 开启交互式终端, 终端退出, docker 不会终止
docker exec     容器ID ls                # 对于在后台运行的容器, 执行命令

## 文件操作
comm 1.txt 2.txt       | tr -d '\t' # 求两个文件的全集
comm 1.txt 2.txt -1 -2 | tr -d '\t' # 求两个文件的交集
comm 1.txt 2.txt -1 -2              # 同上
comm 1.txt 2.txt -3    | tr -d '\t' # 求不同时出现在两个文件中的部分
comm 1.txt 2.txt -1 -3              # B - A
comm 1.txt 2.txt -2 -3              # A - B

diff    1.txt 2.txt              # 比较两个文件的不同
diff -u 1.txt 2.txt              # 一体化输出, 比较两个文件的不同
diff    1.txt 2.txt > diff.pathc
patch   1.txt diff.pathc         # 恢复文件 2.txt

cut -f 1,2  # 按列切割
cut -d ":"  # 设置分割符

## 网络
curl -I ... # 只打印头部信息

## 日期
date -s "20200202 10:10:10" # 更新系统时间, 需要 root 权限
date "+%Y-%m-%d %H:%M:%S"   # 指定输出的格式, 年-月-日 时-分-秒
date "+%F %T"               # 同上
date "+%Y-%m-%d %H:%M"      # 指定输出的格式, 年-月-日 时-分
date "+%F %R"               # 同上
date "+%s"                  # 使用纪元
date -d "20200202 01:01:01" # 指定输入日期

ntpdate -s time-b.nist.gov # 使用时间服务器更新时间

## 系统状态
df -Th # 所挂载的系统的使用情况
du -sh # 某一目录的使用大小

echo       "123"    #   换行
echo    -n "123"    # 不换行
echo -e -n "123\t"  # 解析转义字符

## 查找文件
find . -name  lyb                     # 以文件名 或 通配符 查找文件
find . -iname lyb                     # 以文件名 或 通配符 查找文件, 忽略大小写
find . -regex ".*p+"                  # 以文件名 或 正则表达式 查找文件, 忽略大小写
find . -type  f                       # 以类型查找文件
find . \( -type f -and -name lyb \)   # 且, 多个条件必须同时成立
find . \( -type f -a   -name lyb \)   # 同上
find .    -type f      -name lyb      # 同上
find . \( -type f -or  -name lyb \)   # 或, 多个条件成立一个即可
find . \( -type f -o   -name lyb \)   # 同上
find . ! -type f -o   -name lyb       # ! 只否定最近的条件
find . -name '.git' -prune -o -type f # 忽略 .git 目录

## 防火墙相关
firewall-cmd --list-ports                       # 查看所有打开的端口
firewall-cmd --get-services                     # 查看所有的服务
firewall-cmd --permanent --add-service=http     # 添加服务, 永久生效
firewall-cmd --permanent --add-service=https    # 添加服务, 永久生效
firewall-cmd             --add-service=https    # 添加服务
firewall-cmd             --remove-service=http  # 移除服务
firewall-cmd --permanent --add-port=8080/tcp    # 添加端口, 永久生效
firewall-cmd             --add-port=8080/tcp    # 添加端口
firewall-cmd             --remove-port=8080/tcp # 移除端口
firewall-cmd --reload                           # 重新加载配置

## 文件锁
flock    123.txt ls # 使用 123.txt 设置文件互斥锁 并执行命令, 如果获取锁失败, 将等待
flock -n 123.txt ls # 使用 123.txt 设置文件互斥锁 并执行命令, 如果获取锁失败, 将退出
flock -e 123.txt ls # 使用 123.txt 设置文件共享锁 并执行命令, 默认为互斥锁

## gcc
gcc -0g main.cc
gcc -01 main.cc
gcc -02 main.cc
gcc -03 main.cc

## grep
grep -v                   # 输出不匹配的内容
grep -c                   # 输出匹配的行的次数, 同一行只输出一次
grep -o                   # 只输出匹配的内容
grep -n                   # 输出匹配的行号
grep -l                   # 输出匹配的文件
grep -i                   # 忽略大小写
grep -h                   # 不输出文件名
grep -q                   # 静默输出
grep -A 5                 # 输出之前的行
grep -B 5                 # 输出之后的行
grep -C 5                 # 输出之前之后的行
grep -e .. -e ..          # 多个模式取或
grep -E ..                # 使用扩展的正则表达式
grep -W ..                # 单词匹配
grep -X ..                # 行匹配
grep ... --inclue "*.c"   # 指定文件
grep ... --exclue "*.c"   # 忽略文件
grep ... --exclue-dir src # 忽略目录

## 符号链接
ln -s target symbolic_link_name # 创捷符号链接
readlink symbolic_link_name     # 读取符号链接

## ls
ls     # 列出当前目录中的元素
ls -a  # 列出当前目录中的元素（包括隐藏的文件）
ls -l  # 列出当前目录中的元素的详细信息
ls -F  # 在目录后添加 /，在可执行文件后添加 *
ls -d  # 只列出目录本身，而不列出目录内元素
ls -r  # 逆序列出当前目录中的元素
ls -R  # 递归列出当前目录中的元素
ls -1  # 在每一行列出文件名

## lsof -- sudo yum install lsof
lsof -iTCP         # 查看 TCP 信息
lsof -i :22        # 查看指定 端口号 的信息
lsof -i@1.2.3.4:22 # 查看是否连接到指定 IP 和 端口号上
lsof -p 1234       # 查看 进程 1234 打开的文件信息
lsof -t            # 仅获取进程ID

## pgrep
pgrep vim         # 列出 使用 vim 的进程号
pgrep vim  -l     # 列出 使用 vim 的进程号和进程名称
pgrep vim  -a     # 列出 使用 vim 的进程号和全路径的完整的进程名称
pgrep vim  -f     # 只要完整进程路径匹配到即可, 而不是进程名的前缀匹配
pgrep vim  -u lyb # 列出有效用户ID 是 lyb 的进程 ID
pgrep vim  -U lyb # 列出真正用户ID 是 lyb 的进程 ID

## ps
ps -ef                  # 显示所有进程的详细信息
ps -o pid,ppid,command  # 按指定格式显示进程的信息
ps -f 123               # 显示指定进程的信息

## tar
tar -cvf  /path/to/foo.tar --exclude=\*.o /path/to/foo/ # foo         --> foo.tar, 忽略 .o 文件
tar -cvf  /path/to/foo.tar                /path/to/foo/ # foo         --> foo.tar
tar -czvf /path/to/foo.tgz                /path/to/foo/ # foo         --> foo.tgz
tar -czvf /path/to/foo.tar.gz             /path/to/foo/ # foo         --> foo.tar.gz
tar -cjvf /path/to/foo.tar.bz2            /path/to/foo/ # foo         --> foo.tar.bz2
tar -xvf  /path/to/foo.tar                              # foo.tar     --> foo
tar -xzvf /path/to/foo.tgz                              # foo.tgz     --> foo
tar -xzvf /path/to/foo.tar.gz                           # foo.tar.gz  --> foo
tar -xjvf /path/to/foo.tar.bz2                          # foo.tar.bz2 --> foo
tar -xjvf /path/to/foo.tar.bz2 -C /path/to/destination/ # foo.tar.bz2 --> foo, 指定工作目录
tar -acf /path/to/foo.tgz --exclude="*.o" /path/to/foo/ # 根据后缀自动 打包 或 压缩, 并忽略指定文件
tar -acf /path/to/foo.tgz -X file         /path/to/foo/ # 根据后缀自动 打包 或 压缩, 并忽略 file 内的文件
tar -xf  /path/to/foo.tgz -C /path/to/destination/      # 根据后缀 解包 或 解压 到指定目录

## tee
tee    1.txt # 管道中把文件拷贝到文件
tee -a 1.txt # 管道中把文件添加到文件

## tr
tr    'a-z' 'A-Z' # 小写转大写
tr -d 'a-z'       # 删除字符
tr -s ' '         # 压缩字符

## sort
sort            # 排序
sort -k 4       # 指定排序的列字段
sort -t :       # 指定列的分割符
sort -n         # 以数字进行排序
sort -r         # 逆序
sort -f         # 忽略大小写
sort -u         # 重复项只输出一次
sort lyb -o lyb # 排序并存入原文件

## ssh
ssh -D # TODO
ssh -L # TODO
ssh -N # TODO
ssh -R # TODO
ssh -X # TODO
ssh -p port
ssh -q             # 不输出任何警告信息
ssh -l lyb 1.2.3.4
ssh        1.2.3.4
ssh    lyb@1.2.3.4
ssh -i ~/.ssh/id_rsa lyb # 指定私钥文件名

### 配置: ~/.ssh/config
Host *
    Port 2222

Host 123
    HostName 1.2.3.4
    User lyb
    Port 2222
    IdentityFile ~/.ssh/id.rsa # 密钥文件

使用 ssh 123 相当于使用 ssh -p 2222 lyb@1.2.3.4

### 免密码登录
* ssh-keygen -t rsa # 生成密钥对, 一路回车即可
* 将生成的公钥 ~/.ssh/id_rsa.pub 添加到服务器的文件中 ~/.ssh/authorized_keys
* 可使用 ssh-copy-id -i 公钥文件 lyb@1.2.3.4 添加公钥到服务器中

## systemctl
systemctl start      nginx   启动 nginx
systemctl stop       nginx   停止 nginx
systemctl restart    nginx   重启 nginx
systemctl status     nginx   查看 nginx 状态
systemctl enable     nginx   开机自动启动 nginx
systemctl disable    nginx   开机禁止启动 nginx
systemctl is-active  nginx   查看 nginx 是否已启动
systemctl is-enabled nginx   查看 nginx 是否开机启动
systemctl list-unit-files    列出所有可用单元

## 去重
uniq    # 删除重复的行
uniq -c # 输出统计的次数
uniq -d # 只输出重复的行, 重复的项只输出一次
uniq -D # 只输出重复的行, 重复的项只输出多次
uniq -i # 忽略大小写
uniq -u # 只输出没重复的行

## sed
sed    "s/123/456/g"          1.txt
sed -i "s/123/456/g"          1.txt # 直接在原文件上修改
sed -i "s|123|456|g"          1.txt # 使用不同的分割符
sed -i "/^$/d"                1.txt # 删除空行
sed -i "s/.*/[&]/g"           1.txt # & 用于表示所匹配到的内容
sed -i "s/\([0-9]*\).*/\1/g"  1.txt # \1 表示第一个字串
sed -i "s/\([0-9]\+\).*/\1/g" 1.txt # \1 表示第一个字串, 为什么 + 要转义 * 不用

## awk
awk 'BEGIN{ print "start" } pattern { commands } END{ print "end" }' file
* BEGIN 和 END 都是可选的
* print 以逗号分割
* NR 当前行号
*NF 字段数量
* $0 当前记录的内容
*$1 第一个字段的内容
*$2 第二个字段的内容
* getline 读取一行
* ls | getline 从命令中读取
* -F: 或 FS=":" 或 OFS=":" # 设置分割符
awk 'NR < 5'      # 行号小于5的行
awk 'NR==1,NR==4' # 行号在 1 到 5 之间的行
awk '/linux/'     # 包含模式为linux的行
awk '!/linux/'    # 不包含模式为linux的行
awk -v lyb=$SHELL ... # 将外部变量的值传给 awk
awk ..... lyb=$SHELL  # 将外部变量的值传给 awk
awk '/start_pattern/, /end_pattern/' filename

## 用户切换
su              # 切换 root, 输入 root 密码
su root         # 同 su
su -            # 切换 root, 更新主目录, 环境变量等等
su -l           # 同 su -
su - root       # 同 su -
su - root -c ls # 使用 root 执行命令 ls

sudo                                                 # 权限管理文件: /etc/sudoers, 使用 visudo 编辑
                                                     # 使用当前用户的密码
sudo -u USERNAME COMMAND                             # 指定用户执行命令
echo "654321" | sudo -S date -s "20210722 10:10:10"  # 脚本中免密码使用

cat lyb | xargs -i vim {} # 以此编辑 lyb 中的每一个文件

#### 查看 Linux 临时端口号的范围
```
cat /proc/sys/net/ipv4/ip_local_port_range
32768   60999
``

* [0, 1024) 公认端口号, 需要 root 启动, 比如 80
* [1024, 32768) 注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
* [60990, 65535)

# 查询 域名 对应 的 IP
* nslookup baidu.com

## Bash 常用快捷键

Ctrl+A             # 将光标移到行首
Ctrl+B             # 将光标向左移动一个字符
Ctrl+C             # 向前台进程组发送 SIGINT, 默认终止进程
Ctrl+D             # 删除光标前的字符 或 产生 EOF 或 退出终端
Ctrl+E             # 将光标移到行尾
Ctrl+F             # 将光标向右移动一个字符
Ctrl+G             # 退出当前编辑
Ctrl+H             # 删除光标前的一个字符
Ctrl+K             # 删除光标处到行尾的字符
Ctrl+L             # 清屏
Ctrl+N             # 查看历史命令中的下一条命令
Ctrl+O             # 类似回车，但是会显示下一行历史
Ctrl+P             # 查看历史命令中的上一条命令
Ctrl+Q             # 解锁终端
Ctrl+R             # 历史命令反向搜索, 使用 Ctrl+G 退出搜索
Ctrl+S             # 锁定终端 或 历史命令正向搜索, 使用 Ctrl+G 退出搜索
Ctrl+T             # 交换前后两个字符
Ctrl+U             # 删除光标处到行首的字符
Ctrl+V                          # 输入字符字面量，先按 Ctrl+V 再按任意键 ?
Ctrl+W             # 删除光标左边的一个单词
Ctrl+X                          # 列出可能的补全 ?
Ctrl+Y             # 粘贴被删除的字符
Ctrl+Z             # 暂停前台进程返回 bash，需要时可用 fg 将其切换回前台
Ctrl+/             # 撤销之前的操作
Ctrl+\             # 产生 SIGQUIT, 默认杀死进程, 并生成 core 文件

Esc+B              # 移动到当前单词的开头(左边)
Esc+F              # 移动到当前单词的结尾(右边)

Alt+B              # 向后（左边）移动一个单词
Alt+d              # 删除光标后（右边）一个单词
Alt+F              # 向前（右边）移动一个单词
Alt+t              # 交换字符 ?
Alt+BACKSPACE      # 删除光标前面一个单词，类似 Ctrl+W，但不影响剪贴板
Ctrl+X Ctrl+X      # 连续按两次 Ctrl+X，光标在当前位置和行首来回跳转
Ctrl+X Ctrl+E      # 用你指定的编辑器，编辑当前命令
Ctrl+insert        # 复制命令行内容
shift+insert       # 粘贴命令行内容

Esc+.              # 获取上一条命令的最后的部分

## bash 输出颜色
echo -e "\e[1;30m lyb \e[0m" # 文本颜色:   黑色
echo -e "\e[1;31m lyb \e[0m" # 文本颜色:   红色
echo -e "\e[1;32m lyb \e[0m" # 文本颜色:   绿色
echo -e "\e[1;33m lyb \e[0m" # 文本颜色:   黄色
echo -e "\e[1;34m lyb \e[0m" # 文本颜色:   蓝色
echo -e "\e[1;35m lyb \e[0m" # 文本颜色: 洋红色
echo -e "\e[1;36m lyb \e[0m" # 文本颜色:   青色
echo -e "\e[1;37m lyb \e[0m" # 文本颜色:   白色

echo -e "\e[1;40m lyb \e[0m" # 背景颜色:   黑色
echo -e "\e[1;41m lyb \e[0m" # 背景颜色:   红色
echo -e "\e[1;42m lyb \e[0m" # 背景颜色:   绿色
echo -e "\e[1;43m lyb \e[0m" # 背景颜色:   黄色
echo -e "\e[1;44m lyb \e[0m" # 背景颜色:   蓝色
echo -e "\e[1;45m lyb \e[0m" # 背景颜色: 洋红色
echo -e "\e[1;46m lyb \e[0m" # 背景颜色:   青色
echo -e "\e[1;47m lyb \e[0m" # 背景颜色:   白色

echo -e "\e[1;37m lyb \e[0m" # 文本加粗
echo -e "\e[4;37m lyb \e[0m" # 文本下划线
echo -e "\e[5;37m lyb \e[0m" # 文本闪烁
echo -e "\e[7;37m lyb \e[0m" # 反向选择

