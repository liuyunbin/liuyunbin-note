
#### Bash 常用快捷键

Ctrl+A             # 将光标移到行首
Ctrl+B             # 将光标向左移动一个字符
Ctrl+C             # 向前台进程组发送 SIGINT, 默认终止进程
Ctrl+D             # 删除光标前的字符 或 产生 EOF 或 退出终端
Ctrl+E             # 将光标移到行尾
Ctrl+F             # 将光标向右移动一个字符
Ctrl+G             # 退出当前编辑
Ctrl+H             # 删除光标前的一个字符
Ctrl+K             # 删除光标处到行尾的字符
Ctrl+L             # 清屏
Ctrl+N             # 查看历史命令中的下一条命令
Ctrl+O             # 类似回车，但是会显示下一行历史
Ctrl+P             # 查看历史命令中的上一条命令
Ctrl+Q             # 解锁终端
Ctrl+R             # 历史命令反向搜索, 使用 Ctrl+G 退出搜索
Ctrl+S             # 锁定终端 或 历史命令正向搜索, 使用 Ctrl+G 退出搜索
Ctrl+T             # 交换前后两个字符
Ctrl+U             # 删除光标处到行首的字符
Ctrl+V                          # 输入字符字面量，先按 Ctrl+V 再按任意键 ?
Ctrl+W             # 删除光标左边的一个单词
Ctrl+X                          # 列出可能的补全 ?
Ctrl+Y             # 粘贴被删除的字符
Ctrl+Z             # 暂停前台进程返回 bash，需要时可用 fg 将其切换回前台
Ctrl+/             # 撤销之前的操作
Ctrl+\             # 产生 SIGQUIT, 默认杀死进程, 并生成 core 文件

Esc+B              # 移动到当前单词的开头(左边)
Esc+F              # 移动到当前单词的结尾(右边)

Alt+B              # 向后（左边）移动一个单词
Alt+d              # 删除光标后（右边）一个单词
Alt+F              # 向前（右边）移动一个单词
Alt+t              # 交换字符 ?
Alt+BACKSPACE      # 删除光标前面一个单词，类似 Ctrl+W，但不影响剪贴板
Ctrl+X Ctrl+X      # 连续按两次 Ctrl+X，光标在当前位置和行首来回跳转
Ctrl+X Ctrl+E      # 用你指定的编辑器，编辑当前命令
Ctrl+insert        # 复制命令行内容
shift+insert       # 粘贴命令行内容

Esc+.              # 获取上一条命令的最后的部分

#### bash 输出颜色
echo -e "\e[1;30m lyb \e[0m" # 文本颜色:   黑色
echo -e "\e[1;31m lyb \e[0m" # 文本颜色:   红色
echo -e "\e[1;32m lyb \e[0m" # 文本颜色:   绿色
echo -e "\e[1;33m lyb \e[0m" # 文本颜色:   黄色
echo -e "\e[1;34m lyb \e[0m" # 文本颜色:   蓝色
echo -e "\e[1;35m lyb \e[0m" # 文本颜色: 洋红色
echo -e "\e[1;36m lyb \e[0m" # 文本颜色:   青色
echo -e "\e[1;37m lyb \e[0m" # 文本颜色:   白色

echo -e "\e[1;40m lyb \e[0m" # 背景颜色:   黑色
echo -e "\e[1;41m lyb \e[0m" # 背景颜色:   红色
echo -e "\e[1;42m lyb \e[0m" # 背景颜色:   绿色
echo -e "\e[1;43m lyb \e[0m" # 背景颜色:   黄色
echo -e "\e[1;44m lyb \e[0m" # 背景颜色:   蓝色
echo -e "\e[1;45m lyb \e[0m" # 背景颜色: 洋红色
echo -e "\e[1;46m lyb \e[0m" # 背景颜色:   青色
echo -e "\e[1;47m lyb \e[0m" # 背景颜色:   白色

echo -e "\e[1;37m lyb \e[0m" # 文本加粗
echo -e "\e[4;37m lyb \e[0m" # 文本下划线
echo -e "\e[5;37m lyb \e[0m" # 文本闪烁
echo -e "\e[7;37m lyb \e[0m" # 反向选择

## 文件内容
* mtime 修改时间: 文件内容的变化, 修改文件时, 另外两个时间也会变化
* atime 访问时间: 读文件的时间变化
* ctime 状态时间: 修改权限, 所有者, 大小等等



#### 查看 Linux 临时端口号的范围
```
cat /proc/sys/net/ipv4/ip_local_port_range
32768   60999
``

* [0, 1024) 公认端口号, 需要 root 启动, 比如 80
* [1024, 32768) 注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
* [60990, 65535)

# 查询 域名 对应 的 IP
* nslookup baidu.com

tee
!!                 # 执行上一条命令
!l                 # 执行最近使用的以 l 打头的命令
!l:p               # 输出最近使用的以 l 打头的命令
!num               # 执行历史命令列表的第 num 条命令
!$                 # 表示上一条命令的最后一个参数

\command # 忽略别名

## 
jobs 
history

-----------------------------------------------

## bash 基础
bash file_name # 执行文件内的命令
bash -c "ls"   # 将字符串的内容交由 bash 执行, 字符串里可包含重定向和管道

#### 重定向
bash  < 1.txt
bash 1< 1.txt       # 标准输入重定向
ls    > 1.txt
ls   1> 1.txt       # 标准输出重定向
ls   >> 1.txt
ls  1>> 1.txt       # 标准输出添加重定向
ls   2> 1.txt       # 标准错误重定向
ls  2>> 1.txt       # 标准错误添加重定向
ls > 1.txt 2> 2.txt # 标准输出重定向到 1.txt, 标准错误重定向到 2.txt
ls >&2 2> 2.txt     # 标准输出重定向到和标准错误相同, 即屏幕, 标准错误重定向到 2.txt
ls > 1.txt 2>&1     # 标准输出重定向到 1.txt, 标准错误重定向到 和 标准输出相同, 即 1.txt
ls &> 1.txt         # 同时重定向标准输出和标准错误 到 1.txt
exec &>> lyb.log    # 脚本内重定向, 将 当前 shell 的标准输出 和 标准错误 重定向到 lyb.log

建议使用:
* ls > 1.txt  2> 2.txt
* ls &> /dev/null
* exec &>> lyb.log

#### 各种括号的作用
* 小括号
    * 单个小括号
        * lyb=(1 2 3)  # 数组
        * (ls)         # 子shell执行命令, 输出到屏幕上
        * lyb=$(ls)    # 子shell执行命令, 存入变量
        * cat <(ls)    # 将命令 或 函数的输出做为 文件, 命令要有打开 文件 的动作
    * 双小括号
        * ((1+2))      # 数学计算, 变量不需要加 $, 计算结果不为 0 时, 表示状态正常
        * lyb=$((1+2)) # 数学计算, 变量不需要加 $, 计算结果存入变量
* 中括号
    * 单中括号
        * [ -a file ]    # 判断文件的各种状态, < 等会有问题
        * lyb=$[lyb+lyb] # 数学计算, 变量不需要加 $, 计算结果存入变量
    * 双中括号
        * [[ -a file ]]    # 判断文件的各种状态, < 等不会有问题, 支持正则
* 大括号
    * 代码块
    * 作为变量的分割符
    * {1..10..2}  # 获取字符序列

括号很复杂, 建议:
* 使用双小括号进行数学计算, 比如: lyb=$((123+456))
* 使用双中括号进行文件判断, 支持正则: [[ lyb =~ ^l ]]

#### 字符串
length=${#val}       # 输出字符串的长度
${val:起始位置:长度} # 获取子串
lyb=123
lyb=$lyb+123 # lyb 将变成 123+123

${var}          # 取变量的值
${var:-word}    # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 返回 word
${var:=word}    # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 设置 var=word, 然后返回 word
${var:+word}    # 如果 var 存在, 且不为空, 则返回 word 的值, 否则, 返回 空
${var:?message} # 如果 var 存在, 且不为空, 返回 var 的值, 否则, 返回 输出 message, 并退出

lyb=123.456.txt
lyb=${lyb%.*}       # 后缀非贪婪匹配, lyb 为 123.456
lyb=${lyb%%.*}      # 后缀  贪婪匹配, lyb 为 123
lyb=${lyb#*.}       # 前缀非贪婪匹配, lyb 为 txt
lyb=${lyb##*.}      # 前缀  贪婪匹配, lyb 为 456.txt
lyb=${lyb/*./str}   # 全文  贪婪匹配, lyb 为 txt, 匹配一次
lyb=${lyb//*./str}  # 全文  贪婪匹配, lyb 为 txt, 匹配多次
lyb=${lyb^^}        # 变为大写
lyb=${lyb,,}        # 变为小写

和 变量的区别
* 在复制号左边的只能是变量
* 以 $ 开头的, 也是变量
* 其他的无论加不加引号, 都是字符串


#### 数组
v=(1 2 3) # 定义数组
${v[1]}   # 数组中指定元素的值
${v[*]}   # 数组中所有元素的值, "1 2 3"
${v[@]}   # 数组中所有元素的值, "1" "2" "3"
${#v[*]}  # 数组中元素的个数
${#v[@]}  # 数组中元素的个数
${!v[@]}  # 获取所有的 key
${!v[*]}  # 获取所有的 key

declare -A v # 关联数组, map
v[a]=a
v[b]=b

#### 子shell
source .bashrc # 当前 shell 执行, 变量等会影响当前 shell
     . .bashrc # 同上
./bin.sh       # 在子 shell 中执行, 变量等不会影响当前 shell
exec ls        # 替换当前 shell, 执行后不再执行之后的命令
exec &>1.txt   # 打开文件描述符, 然后继续执行之后的命令
env            # 设置环境变量, 然后执行程序

#### 通配符
? # 代表一个字符
* # 代表零个或多个字符
[123]
[1-5]
[!a]

#### 正则表达式
^      : 开头
$      : 结尾
.      : 任意字符
[]     :  中括号中      的任意字符
[^]    : 中括号中字符外的任意字符
?      : 前面字符出现 0 次 或 一次
*      : 前面字符出现 0 次 或 多次
+      : 前面字符出现 1 次 或 多次
{n}    : 前面字符出现 n 次
{n,}   : 前面字符出现 n 次 及以上
{n, m} : 前面字符出现 n 次 到 m 次
()     : 将括号内的内容看成一个整体
|      : 或

## 脚本
$0 # 脚本名称
$1 # 第一个参数
$* # 所有参数拼成一个字符串
$@ # 参数序列
$# # 参数个数

#### 脚本上重定向
cat << EOF
    $lyb
EOF

