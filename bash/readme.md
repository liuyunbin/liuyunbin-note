
# 操作系统-僵尸进程
## 产生的原因
* 子进程退出时, 会向父进程发送 `SIGCHLD`, 同时内核会保留子进程退出的状态信息
* 但父进程未正确处理此信号, 导致内核一直保留子进程退出的状态信息

## 存在的意义
* 父进程可以获取子进程退出的状态信息

## 存在的危害
* 数量较少时没有过大的负作用
* 但大量僵尸进程会占用大量的 `PID` 以及其他系统资源, 影响系统正常使用

## 查看以及处理僵尸进程
* 使用 `top` 查看是否存在僵尸进程(zombie)
* 获取僵尸进程的进程号:
    * `ps --no-header -fe -o state,pid  | awk '$1 == "Z" {print $2}'`
* 获取僵尸进程的父进程号:
    * `ps --no-header -fe -o state,ppid | awk '$1 == "Z" {print $2}'`
* 杀死上一步获取的僵尸进程的父进程:
    * `kill -9 pid`

## 模拟僵尸进程的产生
### 场景一: 父进程未处理子进程退出的状态信息
1. 父进程产生子进程
2. 子进程空循环
3. 此时, 可以看到子进程处于运行状态
4. 杀死子进程
5. 此时, 可以看到子进程处于僵尸状态

测试文件: [0101.cc](./0101.cc)

### 场景二: 父进程未正确处理子进程退出的状态信息
1. 父进程设置捕捉 `SIGCHLD` 时, 调用一次 `waitpid()`
2. 父进程阻塞信号 `SIGCHLD`
3. 父进程产生五个子进程, 每次子进程都退出, 父进程休眠一秒, 保证子进程已退出
4. 父进程解除信号 `SIGCHLD` 阻塞
5. 此时, 由于有的 `SIGCHLD` 信号丢失, 所以有的子进程处于僵尸状态

测试文件: [0102.cc](./0102.cc)

## 预防僵尸进程
### 方法一: 父进程设置忽略 `SIGCHLD`
1. 父进程设置捕捉 `SIGCHLD` 时, 使用 `SIG_IGN` 忽略此信号
2. 父进程阻塞信号 `SIGCHLD`
3. 父进程产生五个子进程, 每次子进程都退出, 父进程休眠一秒, 保证子进程已退出
4. 父进程解除信号 `SIGCHLD` 阻塞
5. 此时, 没有进程处于僵尸状态

测试文件: [0103.cc](./0103.cc)

### 方法二: 父进程设置捕捉 `SIGCHLD` 时, 循环调用 `waitpid(...WNOHANG)`
1. 父进程设置捕捉 `SIGCHLD` 时, 循环调用 `waitpid()` 直到失败
2. 父进程阻塞信号 `SIGCHLD`
3. 父进程产生五个子进程, 每次子进程都退出, 父进程休眠一秒, 保证子进程已退出
4. 父进程解除信号 `SIGCHLD` 阻塞
5. 此时, 没有进程处于僵尸状态

测试文件: [0104.cc](./0104.cc)

### 方法三: 父进程设置捕捉 `SIGCHLD` 时, 使用 `sigaction()` 设置 `SA_NOCLDWAIT`, 表示不产生僵尸进程
1. 父进程设置捕捉 `SIGCHLD` 时, 设置 `SA_NOCLDWAIT`
2. 父进程阻塞信号 `SIGCHLD`
3. 父进程产生五个子进程, 每次子进程都退出, 父进程休眠一秒, 保证子进程已退出
4. 父进程解除信号 `SIGCHLD` 阻塞
5. 此时, 没有进程处于僵尸状态

测试文件: [0105.cc](./0105.cc)

### 方法四: 父进程退出, 使子进程变成孤儿进程, 子进程的父进程将变为 `systemd`, 后者会处理僵尸进程
1. 进程产生子进程作为测试的父进程
2. 测试的父进程产生测试的子进程
3. 测试的父进程产生测试的控制进程
4. 通过测试的控制进程杀死测试的父进程
5. 通过测试的控制进程杀死测试的子进程
6. 通过测试的控制进程可以看到测试的子进程并未处于僵尸状态

测试文件: [0106.cc](./0106.cc)

## 销毁僵尸进程
### 方法
* 只能杀死僵尸进程的父进程, 僵尸进程的父进程将变为 `systemd`, 后者将处理僵尸进程

### 测试
1. 进程产生子进程作为测试的父进程
2. 测试的父进程产生测试的子进程
3. 测试的父进程产生测试的控制进程
4. 通过测试的控制进程可以看到测试的子进程处于运行状态
5. 通过测试的控制进程杀死测试的子进程
6. 通过测试的控制进程可以看到测试的子进程处于僵尸状态
7. 通过测试的控制进程杀死测试的父进程
8. 通过测试的控制进程可以看到测试的子进程消失了

测试文件: [0107.cc](./0107.cc)

## 其他测试文件(产生僵尸进程不退出)
1. 父进程产生子进程
2. 子进程退出
3. 此时, 可以看到子进程处于僵尸状态
4. 父进程死循环

测试文件: [0108.cc](./0108.cc)

## 注意事项
1. 设置 `SIGCHLD` 为 `SIG_IGN` 和 `SIG_DFL`(默认会忽略信号), 是不同的, 前者不会产生僵尸进程, 后者会
2. 发送 `SIGCHLD` 的子进程与 waitpid() 得到的子进程不一定相同

# 操作系统-孤儿进程
## 产生的场景
* 子进程未退出, 父进程已退出时, 此时子进程是孤儿进程

## 重现产生的场景
1. 进程产生子进程作为测试的父进程
2. 测试的父进程产生测试的子进程
3. 测试的父进程空循环
4. 此时, 可以看到测试的子进程的父进程是测试的父进程
5. 杀死测试的父进程
6. 此时, 可以看到测试的子进程的父进程变为 systemd

测试文件: [0201.cc](./0201.cc)

## 后续处理
* 孤儿进程的父进程将变为 systemd

## 处理的意义
* 保证所有进程都有父进程, 保证进程退出时的资源都能被释放

## 注意事项
* 孤儿进程只是一个临时状态, 马上就会有新的父进程
* 孤儿进程只有父进程发生变化, 其他属性(比如, 进程, 进程组, 会话)不会变化

# 操作系统-孤儿进程组
## 判断
* 该进程组内所有进程的父进程, 要么属于该进程组, 要么不属于该进程组所属的会话

## 临界状态
* 如果进程组的某个进程的父进程退出导致该进程所属组变成孤儿进程组
* 且该进程组内有进程处于暂停状态
* 0 号进程将发送 `SIGCONT` 和 `SIGHUP` 给该孤儿进程组的每一个成员

## 重现临界状态
01. 进程产生子进程作为测试的父进程
02. 测试的父进程新建新的进程组
03. 测试的父进程产生测试的第一个子进程
04. 测试的第一个子进程使自己暂停
05. 测试的父进程产生测试的第二个子进程
06. 此时, 新的进程组只包含测试的父进程, 测试的第一个子进程和测试的第二个子进程
07. 杀死测试的父进程
08. 此时, 新的进程组只包含测试的第一个子进程和测试的第二个子进程
09. 上述两个进程的父进程变为 systemd
10. systemd 和 两个测试的子进程不在同一个会话
11. 新的进程组变成一个孤儿进程组, 第一个测试的子进程处于暂停状态
12. 所以 0 号进程将发送 `SIGCONT` 和 `SIGHUP` 给该孤儿进程组的每一个成员

测试文件: [0301.cc](./0301.cc)

## 临界状态处理的意义
* 出现临界状态一般都是程序有问题, 系统相当于加了一层保险, 避免系统资源浪费

## 注意事项
* 会话首进程所在的进程组也属于孤儿进程组
* 孤儿进程所在的进程组不一定是孤儿进程组

# 操作系统-信号
## 信号阻塞
### 说明
* `SIGKILL` 和 `SIGSTOP` 无法被阻塞
* `SIGCONT` 可以被阻塞, 但好像没啥用

### 测试
1. 阻塞所有信号
2. 此时, 可以看到除 `SIGKILL` 和 `SIGSTOP` 外, 其他信号都被阻塞了
3. 向自身发送除了 `SIGKILL` 和 `SIGSTOP` 外的所有信号, 这两个信号不能被捕获, 而且会导致进程退出或暂停, 所以跳过
4. 此时, 可以看到除 `SIGKILL` `SIGSTOP` 和 `SIGCONT` 外, 其他信号都处于待决状态

测试文件: [0401.cc](./0401.cc)

## 信号优先级
### 说明
* 有多个信号处于未决状态(信号发送后, 处理前)时, 进程处理的顺序

### 测试
1. 为所有信号注册信号处理函数, 并设置信号处理过程中阻塞其他信号
2. 阻塞所有信号
3. 向自身发送除了 SIGKILL 和 SIGSTOP 外的所有信号, 这两个信号不能被捕获, 而且会导致进程退出或暂停, 所以跳过
4. 解阻塞所有信号
5. 此时, 可以看到信号捕获的顺序
    *  4-SIGILL
    *  5-SIGTRAP
    *  7-SIGBUS
    *  8-SIGFPE
    * 11-SIGSEGV
    * 31-SIGSYS
    * 其他信号按数字的从小到大顺序处理

测试文件: [0402.cc](./0402.cc)

## 信号不可靠
### 相同的信号处于待决状态时, 只记录一个, 其他信号会丢失
1. 设置 SIGUSR1 的信号处理函数
2. 阻塞信号 SIGUSR1
3. 向自身发送信号 SIGUSR1 五次
4. 解除信号 SIGUSR1 阻塞
5. 可以看到 SIGUSR1 只捕获到一次

测试文件: [0403.cc](./0403.cc)

### 信号处理后, 信号处理函数可能会被重置
1. 设置 SIGUSR1 的信号处理函数
2. 设置信号触发后被重置
3. 发送信号 SIGUSR1 第 1 次, 正常捕获
4. 发送信号 SIGUSR1 第 2 次, 进程直接退出

测试文件: [0404.cc](./0404.cc)

## 信号处理
### 第一种: 忽略信号
### 第二种: 默认处理(忽略, 退出, 退出产生core, 暂停, 继续)
### 第三种: 捕获信号, 信号处理过程中, 相同的信号来了会被阻塞, 此时, 如果再来相同的信号将被抛弃
1. 设置信号 SIGUSR1 处理函数, 处理函数休眠 2 秒，便于观察
2. 产生子进程, 子进程空循环
3. 父进程向子进程发送信号 SIGUSR1 第一次
4. 此时, 观察到子进程正在执行信号处理函数
5. 父进程向子进程发送信号 SIGUSR1 第二次
6. 父进程向子进程发送信号 SIGUSR1 第三次
7. 此时, 观察到子进程继续执行之前的信号处理函数，直到完成
8. 然后, 处理第二次信号
9. 不会处理第三次信号, 这个信号丢失了

测试文件: [0405.cc](./0405.cc)

### 第四种: 捕获信号, 信号处理过程中, 不同的信号来了会被直接执行, 执行完之后, 再继续执行之前的函数
1. 设置信号 SIGUSR1 和 SIGUSR2 处理函数, 处理函数休眠 2 秒，便于观察
2. 产生子进程
3. 子进程空循环
4. 父进程向子进程发送信号 SIGUSR1
5. 此时, 观察到子进程正在执行信号处理函数
6. 父进程向子进程发送信号 SIGUSR2
7. 此时, 观察到子进程直接处理信号 SIGUSR2，直到完成
8. 然后, 继续处理 SIGUSR1, 直到完成

测试文件: [0406.cc](./0406.cc)

### 第五种: 使用 sigaction() 可以选择阻塞的信号集
1. 设置信号 SIGUSR1 和 SIGUSR2 处理函数, 处理函数休眠 2 秒, 便于观察，并设置信号处理过程中阻塞 SIGUSR2
2. 产生子进程
3. 子进程空循环
4. 父进程向子进程发送信号 SIGUSR1
5. 此时, 观察到子进程正在执行信号处理函数
6. 父进程向子进程发送信号 SIGUSR2
7. 此时, 观察到子进程继续执行之前的信号处理函数，直到完成
8. 然后, 开始处理 SIGUSR2, 直到完成

测试文件: [0407.cc](./0407.cc)

## 常见信号
```
 1) SIGHUP  # 终端断开时, 向会话首进程发送
 2) SIGINT  # 键盘中断, 由 ctrl+c 产生
 3) SIGQUIT # 键盘退出, 由 ctrl+\ 产生
 4) SIGILL  # 非法指令, 可执行文件有错误
 5) SIGTRAP # 由 debug 产生
 6) SIGABRT # 由 abort() 产生时
            #   默认处理, 进程退出                       -- 0408.cc
            #   忽略信号, 进程退出                       -- 0409.cc
            #   捕获信号, 并从信号处理函数返回, 进程退出 -- 0410.cc
            #   捕获信号, 不从信号处理函数返回, 进程继续 -- 0411.cc (使用 setjmp)
 7) SIGBUS  # 指针非法地址, 比如, 不符合对齐要求
 8) SIGFPE  # 浮点数异常, 比如整数除以0
            #   忽略信号, 进程退出
            #   默认处理, 进程退出
            #   捕获信号, 并从信号处理函数返回, 将继续触发此信号 -- 0412.cc
            #   捕获信号, 不从信号处理函数返回, 进程继续运行
 9) SIGKILL # 退出, 不能被阻塞, 捕获, 忽略
10) SIGUSR1 # 用户自定义信号
11) SIGSEGV # 指针地址合法, 但无权限访问, 比如, 空指针, 除非跳过异常的行, 否则, 将反复触发
12) SIGUSR2 # 用户自定义信号
13) SIGPIPE # 写文件描述符时, 对方已退出, 比如 socket, 管道
14) SIGALRM # 由 alarm() 产生的超时
15) SIGTERM # 退出信号, kill 默认信号
16) SIGSTKFLT # 栈错误, 未使用
17) SIGCHLD # 子进程暂停或继续时, 会向父进程发送此信号
            #   父进程设置默认处理后, 会忽略此信号
            #   父进程设置忽略信号后, 会忽略此信号
            #   父进程设置捕获信号后, 会调用信号处理函数处理              -- 0413.cc
            #   父进程使用 sigaction 设置 SA_NOCLDSTOP 后, 不再接收此信号 -- 0414.cc
            # 子进程退出时, 会向父进程发送此信号
            #   父进程设置 sigaction 的 SA_NOCLDWAIT 后, 不会产生僵尸进程
            #   父进程设置默认处理,   会产生僵尸进程
            #   父进程设置忽略信号, 不会产生僵尸进程
            #   父进程设置捕获信号, 并调用 waitpid() 类函数一次, 可能会产生僵尸进程
            #   父进程设置捕获信号, 并调用 waitpid() 类函数循环,   不会产生僵尸进程
18) SIGCONT # 继续
19) SIGSTOP # 暂停, 不能被阻塞, 捕获, 忽略
20) SIGTSTP # 暂停
21) SIGTTIN # 后台进程读取终端输入
22) SIGTTOU # 后台进程输出到终端
23) SIGURG  # 带外数据
24) SIGXCPU # cpu 使用超出限制
25) SIGXFSZ # 文件大小超出限制
26) SIGVTALRM # 虚拟的超时信号
27) SIGPROF   # setitimer 到期
28) SIGWINCH  # 终端大小发生变化
29) SIGIO     # 异步IO就绪
30) SIGPWR    # 电池问题
31) SIGSYS    # 非法的系统调用
```

## 常用函数
```
* abort()  # 解锁信号 SIGABRT, 然后向自身发送 SIGABRT
* raise()  # 向自己发送信号
* kill()   # 发送信号, 向某一进程 或 进程组
* pause()  # 休眠, 直到不被忽略的信号发生
* sleep()  # 休眠n秒, 或者一个未被忽略的信号到达
* signal() # 设置信号处理函数
           # 信号处理函数不会被重置
           # 被中断系统调用会自动重启
           # 信号处理时, 自身会被阻塞, 其他信号不会
* sigaction() # 设置信号处理函数
              # 可以选择是否自动重启被中断的系统调用
              # 可以选择第一次调用以后, 信号处理函数是否恢复成默认值
              # 可以选择信号处理过程中, 是否阻塞自身, 或这阻塞指定信号集
              # 可以指明对子进程状态变化的处理
              # 可以获取到发送信号一端的一些信息
* longjmp(), setjmp() # 跨函数 goto
* sigemptyset() # 将信号集置空
* sigfillset()  # 填充所有信号
* sigaddset()   # 添加信号到信号集
* sigdelset()   # 从信号集删除信号
* sigismember() # 判断信号是否处于信号集
* sigprocmask() # 阻塞 或 解阻塞 或 查看信号
* sigpending()  # 处于待决状态的信号
```

## 信号测试(捕获所有信号, 用于测试)
测试文件: [0415.cc](./0415.cc)






# TODO

## 简介
* Bash 是 Linux 的默认 shell
* Bash 是脚本, 一门编程语言

## set 设置
```
set -o nounset  # 使用未初始化的变量报错, 同 -u
set -o errexit  # 只要发生错误就退出, 同 -e
set -o pipefail # 只要管道发生错误就退出
set -o errtrace # 函数报错时, 也处理 trap ERR, 同 set -E
set -o  xtrace  # 执行前打印命令, 同 -x
set -o verbose  # 读取前打印命令, 同 -v
set -o vi       # 使用 vi 快捷键
set -- ....     # 重新排列参数
```

建议使用: set -ueo pipefail

## 特殊字符 -- 要使用原字符必须转义
* 没引号包含
    * {} => 变量分割符 或 将语句封装成块
    * [] => 通配符 或 数字计算等等
    * () => 子shell
    * $  => 读取变量, 无值时默认忽略
    * !  => 一些快捷的方式获取命令或参数
    * ;  => 命令的分割符
    * #  => 注释
    * -  => 字符串以 - 开头表示是可选参数
    * -- => 后面的字符串都不是可选参数
    * '  => 单引号
    * "  => 双引号
    * &  => 后台运行
* 单引号包含:
    * '  => 单引号, 需要在字符串开头加上 $ 符号
* 双引号包含:
    * $  => 读取变量, 无值时默认忽略
    * !  => 一些快捷的方式获取命令或参数
    * "  => 双引号

## 特殊变量
```
$HOME  -- 主目录
$IPS   -- 默认分隔符, 默认为: " \t\n", 包含转义字符时, 需要在开头添加 $, IFS=$'\n'
$PATH  -- 命令路径
$PS1   -- 提示符
$PWD   -- 当前工作目录
$SHELL -- 当前 shell
$?     -- 上一命令执行是否成功
$$     -- shell ID
$_     -- 上一命令的最后一个参数
$!     -- 后台最后一个进程的进程 ID
$0     -- shell 名称
$-     -- shell 启动参数
```

## 字符串
```
v=...   #   解析变量和转义字符
v="..." #   解析变量和转义字符
v='...' # 不解析变量和转义字符
v="...
...
"       # 字符串跨行
v='...
...
'       # 字符串跨行

${v:-w}              # v 不为空, 返回 $v, 否则, 返回 w
${v:=w}              # v 不为空, 返回 $v, 否则, 令 v=w, 返回 w
${v:+w}              # v 不为空, 返回  w, 否则, 返回空
${v:?w}              # v 不为空, 返回 $v, 否则, 输出 w, 退出
${#val}              # 输出字符串的长度
${val:起始位置:长度} # 获取子串
lyb=123
lyb=$lyb+123         # 字符串连接, lyb 将变成 123+123
lyb=123.456.txt
lyb=${lyb%.*}        # 后缀非贪婪匹配, lyb 为 123.456
lyb=${lyb%%.*}       # 后缀  贪婪匹配, lyb 为 123
lyb=${lyb#*.}        # 前缀非贪婪匹配, lyb 为 456.txt
lyb=${lyb##*.}       # 前缀  贪婪匹配, lyb 为 txt
lyb=${lyb/*./str}    # 全文  贪婪匹配, lyb 为 strtxt, 匹配一次
lyb=${lyb//*./str}   # 全文  贪婪匹配, lyb 为 strtxt, 匹配多次
lyb=${lyb^^}         # 变为大写
lyb=${lyb,,}         # 变为小写
```

## 索引数组:
```
* v=(1 2 3)  # 初始化数组, 以空字符分割多个元素
* ${v[1]}    # 数组中指定元素的值
* ${v[-1]}   # 数组中最后一个元素的值
* ${v[@]}    # 数组中所有元素的值, "1" "2" "3"
* ${#v[@]}   # 数组中元素的个数
* ${!v[@]}   # 获取所有的 key
* v+=(1 2 3) # 添加数组元素
```

## 关联数组:
```
* declare -A v # 关联数组, map
* v[a]=a       # 赋值
* v[-1]=b      # 以 -1 作为 key
               # 其他同索引数组
```

## 模式扩展 -- 通配符
```
* ~       用户主目录
* ~lyb    用户 lyb 的主目录, 匹配失败的话, 不扩展
* ~+      当前目录
* ?       任意单个字符, 匹配失败的话, 不扩展
* *       任意多个字符, 匹配失败的话, 不扩展
* [123]   [1,3] 中任意一个, 匹配失败的话, 不扩展
* [1-5]   [1,5] 中任意一个, 匹配失败的话, 不扩展
* [!a]    非 a, 匹配失败的话, 不扩展
* [^a]    非 a, 匹配失败的话, 不扩展
* {1,2,3} [1,3] 匹配失败, 也会扩展
* {,1}    空 或 1, 匹配失败, 也会扩展
* {1..10}          匹配失败, 也会扩展
* {01..10}         匹配失败, 也会扩展(保证两位数)
* {1..10..3}       匹配失败, 也会扩展
```

## 模拟命令的标准输入
```
解释变量
cat << EOF
    $lyb
EOF

解释变量
cat << "EOF"
    $lyb
EOF

不解释变量
cat << 'EOF'
    $lyb
EOF

cat <<<  $lyb  #   解释变量
cat <<< "$lyb" #   解释变量
cat <<< '$lyb' # 不解释变量
```

## 括号 -- 只列举常用的情况
```
* 命令替换使用 $() 而不是反引号
    * (ls)         # 子shell执行命令, 输出到屏幕上
    * lyb=$(ls)    # 子shell执行命令, 存入变量
* 整数运算
    * (())         # 整数运算, 变量不需要加 $
    * lyb=$((...)) # 将结果存储在变量中
* 使用 [[ ... ]] 测试
    * [[ -z "$lyb" ]] # 判断是否空字符串
    * [[ -n "$lyb" ]] # 判断是否不是空字符串
    * [[ lyb =~ ^l ]] # 扩展的正则表达式匹配
    * [[ -a file   ]] # file 存在
    * [[ -e file   ]] # file 存在
    * [[ -f file   ]] # file 存在且普通文件
    * [[ -d file   ]] # file 存在且是目录
    * [[ -h file   ]] # file 存在且是符号链接
    * [[ -L file   ]] # file 存在且是符号链接
    * [[ -b file   ]] # file 存在且是  块文件
    * [[ -c file   ]] # file 存在且是字符文件
    * [[ -p file   ]] # file 存在且是一个命名管道
    * [[ -S file   ]] # file 存在且是一个网络 socket
    * [[ -s file   ]] # file 存在且其长度大于零
    * [[ -N file   ]] # file 存在且自上次读取后已被修改
    * [[ -r file   ]] # file 存在且可读
    * [[ -w file   ]] # file 存在且可写权
    * [[ -x file   ]] # file 存在且可执行
    * [[ -u file   ]] # file 存在且设置了 SUID
    * [[ -g file   ]] # file 存在且设置了 SGID
    * [[ -k file   ]] # file 存在且设置了 SBIT
    * [[ -O file   ]] # file 存在且属于有效的用户 ID
    * [[ -G file   ]] # file 存在且属于有效的组   ID
    * [[ -t fd     ]] # fd 是一个文件描述符，并且重定向到终端
    * [[ FILE1 -nt FILE2 ]] # FILE1 比 FILE2 的更新时间更近, 或者 FILE1 存在而 FILE2 不存在
    * [[ FILE1 -ot FILE2 ]] # FILE1 比 FILE2 的更新时间更旧, 或者 FILE2 存在而 FILE1 不存在
    * [[ FILE1 -ef FILE2 ]] # FILE1 和 FILE2 引用相同的设备和 inode 编号
* cat <(ls)           # 将命令或函数的输出作为文件
```

## 其他 bash 操作
```
bash file_name # 执行文件内的命令
bash -c "ls"   # 将字符串的内容交由 bash 执行, 字符串里可包含重定向和管道

echo -n "123"                # 不换行
echo -e "\e[1;33m lyb \e[0m" # 文本黄色 加粗
echo  $'123\''               # 单引号内存在单引号的情况
echo  $(cal)                 # 输出字符以空格区分
echo "$(cal)"                # 保留输出字符的分割符
echo ${!S*}                  # 列出所有包含 S 的变量

ls &> /dev/null # 重定向

!!    # 上一条命令
!l    # 执行最近使用的以 l 打头的命令
!l:p  # 输出最近使用的以 l 打头的命令
!num  # 执行历史命令列表的第 num 条命令
!$    # 上一条命令的最后一个参数
!*    # 上一条命令的所有参数
^1^2  # 将前一条命令中的 1 变成 2

bg %jobspec # 后台暂停 --> 后台运行, 有无 % 都成
fg %jobspec # 后台     --> 前台运行, 有无 % 都成

jobs          # 列出后台作业
jobs %jobspec # 作业号有无 % 都成
jobs -l       #   列出后台作业的 PID
jobs -p       # 只列出后台作业的 PID
jobs -n       # 只列出进程改变的作业
jobs -s       # 只列出停止的作业
jobs -r       # 只列出运行中的作业

read name     # 读取, 如果参数值小于字段数, 多余的值放入最后一个字段

sleep 30   # 前台运行
sleep 30 & # 后台运行

\command # 忽略别名

env          # 设置环境变量, 然后执行程序

getconf NAME_MAX / # 获取变量的值
getconf PATH_MAX /

history
```

## 脚本
```
$0 # 脚本名称
$1 # 第一个参数
$@ # 参数序列
$# # 参数个数

getopts # 处理参数, -- 表示可选参数的终止

exec &>> 1.log  # 脚本内重定向
exec ls         # 替换当前 shell, 执行后不再执行之后的命令
exec &>  1.txt  # 打开文件描述符, 然后继续执行之后的命令

trap ... ERR  # 发生错误退出时, 执行指定命令
trap ... EXIT # 任意情况退出时, 执行指定命令

flock    1.c ls # 设置文件互斥锁 执行命令, 设置锁失败, 等待
flock -n 1.c ls # 设置文件互斥锁 执行命令, 设置锁失败, 退出

脚本内使用, 保证脚本最多执行一次
[[ "$FLOCKER" != "$0" ]] && exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || :

解释:
1. 第一次进入脚本, 由于变量未设置, 会执行 exec
2. 调用 exec, 使用 env 设置 变量名
3. 执行 flock, 重新执行这个脚本, 执行完脚本后会退出, 不会执行之后的命令
    * 使用脚本名作为 文件锁, 脚本名使用绝对路径, 所以不会重复
4. 第二次进入脚本, 由于变量已设置, 直接往下执行就可以了
5. 在此期间, 如果, 有其他脚本进入, 文件锁获取失败, 就直接退出了

if for while

函数

建议使用 local 局部变量, 声明和使用放到不同的行

```

测试文件: [test.sh](./test.sh)

## 常用快捷键
```
Ctrl+A      # 将光标移到行首
Ctrl+B      # 将光标向左移动一个字符
Ctrl+C      # 向前台进程组发送 SIGINT, 默认终止进程
Ctrl+D      # 删除光标前的字符 或 产生 EOF 或 退出终端
Ctrl+E      # 将光标移到行尾
Ctrl+F      # 将光标向右移动一个字符
Ctrl+G      # 响铃
Ctrl+H      # 删除光标前的一个字符
Ctrl+I      # 相当于TAB
Ctrl+J      # 相当于回车
Ctrl+K      # 删除光标处到行尾的字符
Ctrl+L      # 清屏
Ctrl+M      # 相当于回车
Ctrl+N      # 查看历史命令中的下一条命令
Ctrl+O      # 类似回车，但是会显示下一行历史
Ctrl+P      # 查看历史命令中的上一条命令
Ctrl+Q      # 解锁终端
Ctrl+R      # 历史命令反向搜索, 使用 Ctrl+G 退出搜索
Ctrl+S      # 锁定终端 -- TODO 历史命令正向搜索, 使用 Ctrl+G 退出搜索
Ctrl+T      # 交换前后两个字符
Ctrl+U      # 删除光标处到行首的字符
Ctrl+V      # 输入控制字符
Ctrl+W      # 删除光标左边的一个单词
Ctrl+X      #   TODO-列出可能的补全 ?
Ctrl+Y      # 粘贴被删除的字符
Ctrl+Z      # 前台运行的程序 --> 后台暂停
Ctrl+/      # 撤销之前的操作
Ctrl+\      # 产生 SIGQUIT, 默认杀死进程, 并生成 core 文件
Ctrl+xx     # 光标和行首来回切换

Esc+B              # 移动到当前单词的开头(左边)
Esc+F              # 移动到当前单词的结尾(右边)
Esc+.              # 获取上一条命令的最后的部分

Alt+B              # 向后（左边）移动一个单词
Alt+C              # 光标处字符转为大写
Alt+D              # 删除光标后（右边）一个单词
Alt+F              # 向前（右边）移动一个单词
Alt+L              # 光标处到行尾转为小写
Alt+R              # 取消变更
Alt+T              # 交换光标两侧的单词
Alt+U              # 光标处到行尾转为大写
Alt+BACKSPACE      # 删除光标前面一个单词，类似 Ctrl+W，但不影响剪贴板
Alt+.              # 使用上条命令的最后一个单词

Ctrl+X Ctrl+X      # 连续按两次 Ctrl+X，光标在当前位置和行首来回跳转
Ctrl+X Ctrl+E      # 用你指定的编辑器，编辑当前命令
Ctrl+insert        # 复制命令行内容
shift+insert       # 粘贴命令行内容
```


