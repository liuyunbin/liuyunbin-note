
## 申明和定义
* 变量使用前必须申明或定义
* 多个文件使用相同的变量时, 注意防止重复定义, 使用前确保初始化已完成

## 初始化
* 全局变量
    * 在 main 函数运行之前 或 动态库装载时初始化
    * 不同的文件的变量的初始化顺序不一定
* 静态全局变量
    * 同上
* 类静态变量
    * 同上
* 函数静态变量
    * 在第一次经过的时候才初始化
    * C++11 及以后是线程安全的

       const int i = 1; # 只在本文件内有效
extern const int i = 1; # 可以在其他文件中使用

std::getline(std::cin, str); // 读取一行, 包括换行符, str 不会存储换行符

整数除以整数, 无论正负, 小数部分直接舍弃
商的符号由除数和被除数决定
余数的符号只由被除数决定

     static_cast -- 不含底层const的转换, 明确定义, 比如, long -> int, void* -> int*
      const_cast --     底层const的转换, 比如, const int* => int*
reinterpret_cast -- 重新解释底层存储, 比如 long* -> double*
    dynamic_cast

mutable 类可变成员

explicit

string 短字符串优化, 所以 swap 可能会真正交换元素, 而不是拷贝指针

thread --------- 线程
  joinable() --- 判断线程是否可以回收
  join() ------- 等待线程退出
  detach() ----- 使线程处于分离状态
sleep_for() ---- 休眠
sleep_until() -- 休眠, 直到

atomic -------- 原子操作
mutex --------- 互斥锁, 需要手动加解锁
shared_mutex -- 共享锁, 应该很少用

lock_guard --- 构造函数对互斥锁加锁, 析构函数对互斥锁解锁, 一次只能针对一个互斥锁
unique_lock -- 一般和条件变量一起使用
scoped_lock -- 构造函数对互斥锁加锁, 析构函数对互斥锁解锁, 一次可以针对多个互斥锁 -- C++17
shared_lock -- 处理共享锁, 应该很少用

defer_lock --- 不加锁
try_to_lock -- 会尝试加锁, 失败就退出
adopt_lock --- 如果当前线程已加锁, 则不再加锁, 否则, 正常加锁

condition_variable -- 条件变量, 和 unique_lock 一起用
    notify_one ------ 通知一个
    notify_all ------ 通知所以
    wait ------------ 等待

std::shared_ptr
	* 初始化
	    * std::shared_ptr<T>(p)    -- p 指向动态分配的内存 -- 不建议
		* std::shared_ptr<T>(q, d) -- p 可以是普通指针, d 为析构时的处理
		* std::make_shared -- 建议
	p.use_count()
	p.unique()
	p.get()
	p.reset(...)
std::unique_ptr
	初始化
	    * std::unique_ptr<T>(p)    -- p 指向动态分配的内存 -- 不建议
		* std::shared_ptr<T, D>(q, d) -- p 可以是普通指针, d 为析构时的处理, 处于效率的考虑, 删除器使用模板
		* std::make_unique -- 建议, C++14
	p.release() -- 放弃指针的占用, 并返回
	p.reset(...)
std::weak_ptr -- 不影响引用计数
	w.reset()
	w.unique()
	w.use_count()
	w.expired() -- 所关联的智能指针是否存在
	w.lock() -- 返回智能指针

使用动态分配内存的场景
1. 不知道有多少元素(std::vector)
2. 不知道对象的准确类型
3. 多个对象共享数据

## 高级特性
* 对于普通程序员来说，模板元编程只需明白原理，实现能看懂即可, 一般也不会用到


## ubuntu 下设置生成 core
```
$ ulimit -c unlimited           # 设置允许生成的 core 文件大小不受限制
$                               # 可以考虑写入配置项 bashrc
$ echo "kernel.core_pattern=%e.%p" >> /etc/sysctl.conf
$                               # 将core命名方式写入配置文件: 文件名.进程号
$ sudo sysctl -p                # 使配置生效
$ sudo systemctl stop    apport # 停止此服务, 该服务会自动收集 core 文件
$ sudo systemctl disable apport # 禁止改服务自动启动
```


# 计算机网络
## 基础知识
```
硬盘: 1T = 1000G = 1000 * 1000 * 1000 * 1000B = ... / 1024 / 1024 /1024 GB = 931GB
网卡: 1000M = 1000Mbps = 125MB (网速也一样)

  带宽: 网速, 上限由网卡控制
吞吐量: 有效数据的速度, 速度小于带宽
  延时: 客户端发送数据到收到数据的时差

kmg(1000), KMG(1024), B(字节), b(位)
```

## 网络接口层(帧)(以太网)
* MTU 最大传输单元 (链路层)
* 通过MAC可以区分是单播还是(组播或广播)
* 以太网
* WiFi

* 集线器: 无脑转发数据到所有出口(不知道 MAC 和 IP) -- 很少使用了
* 交换机: 将指定数据直接发送到目标机器(知道 MAC) ---- 机器数量过大时, 会很难处理

## 网络层(数据包)
* IPv4
* IPv6

* 路由器: 连接不同的网络(知道 MAC 和 IP)

## 传输层(段)
* TCP: 面向连接的可靠的字节流协议
* UDP: 无连接, 固定长度的不可靠的数据报协议

## 应用层(消息)
* DHCP(广播, UDP)
    1. 新机器(IP: 0.0.0.0)发送信息给当前网络(IP: 255.255.255.255)的所有机器(不会跨网关)
    2. 包含 DHCP 服务器的机器发送新的 IP 给新机器(IP: 255.255.255.255)
    3. 新机器(IP: 新IP)发送确认信息给 DHCP 服务器
* http
* DNS
    * A ------------------ 域名 => IPv4
    * AAAA --------------- 域名 => IPv6
    * CNAME -------------- 域名 => 另一域名
    * /etc/resolv.conf --- DNS 服务器的地址
    * /etc/hosts --------- 域名 和 IP 的对应关系
* ICMP(传输控制协议 不使用端口号) -- ping 实现


## 为什么不能去掉IP(32位)
* 为了划分子网, 方便路由, 传送数据到子网

## 为什么不能去掉MAC(48位, 一般无法改变)
1. 网络协议分层, 不同层实现不同的功能, 交换机会使用其传递数据
2. 直接使用 IP 其实也可以, 这个就是历史原因了

## 端口号
```
* [0, 1024)      # 公认端口号, 需要 root 启动, 比如 80
* [1024, 32768)  # 注册端口, 可以自己注册一些常用服务
* [32768, 60990) # 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
                 # 可通过文件 /proc/sys/net/ipv4/ip_local_port_range 获取
* [60990, 65535)
```

## 单播(一般的网络服务都是单播)
1. 源 IP 和目标 IP 属于同一个子网时, 利用 arp 获取目标的 MAC, 然后利用交换机发送数据到指定机器
2. 否则, 利用路由表获取下一跳的 IP 地址
3. 利用 arp 获取下一跳的 MAC, 然后利用交换机发送数据到下一跳的机器
4. 默认网关会修改源 MAC, 然后再查找下一跳或指定机器
5. 数据传输过程中, 源 IP 和目标 IP 一般不变, 除了 NAT 等

## 组播(IGMP 直播 电视)(TCP 不支持)
1. 组播源注册: 服务器(组播源IP)向中介机构(RP)注册组播IP(2.2.2.2)
2. 客户端向中介机构(RP)申请加入组播IP: 生成基于中介机构(RP)的树(RPT), 同时获取组播源IP
3. 客户端向服务器(组播源IP)申请加入组播IP: 生成基于源的树(SPT), 废弃掉 RPT(SPT路径更优)
4. 服务器通过SPT, 向所有的注册组播IP的用户发送数据
    * 源IP和MAC填自己的数据
    * 目的IP为组播地址
    * 目的MAC为: 01:00:5e + 组播IP 地址低 23 bit(区分单播 组播 广播)
    * 由于目的IP为组播IP, 无法获取确切的MAC, 指定某一机器, 所以只能采用广播向所有机器发送数据
5. 客户端或者路由器通过接收到的数据的组播地址来确定是不是自己所需要的数据

## 广播(ARP, 使用DHCP申请IP地址时)(TCP 不支持)
* 发送所有数据到当前网络的所有机器
* 一般不能跨网络

## 任播(TCP 不支持)
* 最近或最合适的客户

## 防火墙
```
包过滤防火墙: 过滤某些不必要的流量, 依靠 IP 端口号 协议类型(ICMP)
代理防火墙: http 代理
            socks 代理
```

## socket 选项
```
SO_BROADCAST -- 广播
SO_KEEPALIVE -- 保持连接
SO_LINGER ----- close() 之后的内核行为
SO_RCVBUF ----- 接收缓冲区
SO_SNDBUF ----- 发送缓冲区
SO_RCVLOWAT --- 接收低水位值
SO_SNDLOWAT --- 发送低水位值
SO_RCVTIMEO --- 接收超时
SO_SNDTIMEO --- 发送超时
SO_REUSEADDR
    * 通用 IP + 端口号 已绑定时, 不能再 bind() 其他的 IP + 此端口号
    * 端口号 已有连接时, 仍可以 bind()
    * 端口号处于 TIME_WAIT 仍可以 bind()
SO_REUSEPORT -- 允许使用完全相同的绑定, 内核实现负载均衡

TCP_MAXSEG ---- 最大分节大小
TCP_NODELAY --- 禁止 Nagle 算法

IP_TTL -------- TTL 大小
```

## 服务器
1. 迭代服务器
2. 每个客户生成一个进程
3. 每个客户生成一个线程
4. 非阻塞 IO + IO 复用
5. 进程池
6. 线程池

#### 查看 Linux 临时端口号的范围
```
cat /proc/sys/net/ipv4/ip_local_port_range
32768   60999
``

* [0, 1024) 公认端口号, 需要 root 启动, 比如 80
* [1024, 32768) 注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
* [60990, 65535)

# 查询 域名 对应 的 IP
* nslookup baidu.com

