***********************
 csapp-3e-lab-data-lab
***********************

本实验主要用于熟悉整数和浮点数的位的表示

实验官网：http://csapp.cs.cmu.edu/3e/labs.html

********************************************
问题一：使用位操作 非 和 且 实现位操作 异或
********************************************
思路：

对于 x，y 中的每一位，都有以下四种情况：
1. x 中为 0，y 中为 0
2. x 中为 0，y 中为 1
3. x 中为 1，y 中为 0
4. x 中为 1，y 中为 1

我们需要的只有情况 2 和 情况 3，但是由于我们不能使用 或 操作，
所以无法直接找到情况 2 和 情况 3，也不能直接将情况 2 和 情况 3 相 或，
因此，我们这里使用 非 操作，利用情况 1 和 情况 4，
找到同时包含情况 1 2 3 的情况 和 同时包含情况 2 3 4 的情况，
然后取 且 操作

代码：

  int bitXor(int x, int y) {
    // 情况 1
    int a = (~x) & (~y);
    // 情况 2 3 4
    int b = ~a;
    // 情况 4
    int c = x & y;
    // 情况 1 2 3
    int d = ~c;
    return b & d;
  }

********************************************
问题二：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    求得整数的最小值
********************************************
思路：

由于，题目假设整数为 32 位，
而，补码表示的最小值为：符号位为 1，其它位为 0，
所以直接移位即可

代码：

  int tmin(void) {
    return 0x1 << 31;
  }

**********************************
问题三：
    使用
        位操作 非、且、或、异或，
        逻辑操作 非，
        加法运算符
    判断 x 是否是整数的最大值
**********************************
思路：

就 补码 而言，满足 ~x + 1 == x 的情况只有两种，即 0x0000 0000 和 0x8000 0000，
而，整数的最大值为 0x7FFF FFFF，
所以，如果 x == 0x7FFF FFFF，x + 1 == 0x8000 0000，
      如果 x == 0xFFFF FFFF，x + 1 == 0x0000 0000，
所以，我们只需要判断 ((~x) + 1) ^ x 为 0，
然后，排除掉 x 为 0 的情况

注意：

最好不要使用可能导致溢出的代码，可能会有可移植性的问题

代码：

  int isTmax(int x) {
    int y = x + 1;
    return (!((~y + 1) ^ y)) & (!!y);
  }

*******************************************
问题四：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断 x 的奇数位是否都为 1，
    从右往左数，[0, 31]
*******************************************
思路：

只要 x & 0xAAAA AAAA == 0xAAAA AAAA 即可，
但是，题目要求不能使用大于 0xFF 的常量，
所以，我们通过 将 0xAA 移位来获取 0xAAAA AAAA

代码：
  int allOddBits(int x) {
    // a == 0xAAAA
    int a = (0xAA << 8) + 0xAA;
    // a == 0xAAAA AAAA
    a = (a << 16) + a;
    return !((a & x) ^ a);
  }

*******************************************
问题五：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    求 x 相反数
*******************************************
思路：

对于 补码 而言，x 的相反数为 ~x + 1

代码：

  int negate(int x) {
    return ~x + 1;
  }

************************************************
问题六：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断 x 是否属于 [0x30, 0x39] 即 ['0', '9']
************************************************
思路：

给定数字 a，我们可以找一个临界点，
使得 当 x <  0x30 时，a + x <  0
     当 x >= 0x30 时，a + x >= 0
给定数字 b，我们可以找一个临界点，
使得 当 x <= 0x39 时，b + x <  0
使得 当 x >  0x39 时，b + x >= 0

详情见代码注释

注意：尽量不要使用位右移

代码：

  int isAsciiDigit(int x) {
    int sign;
    int a;
    int b;

    // 符号位置为 1，其它位为 0
    sign = 0x1 << 31;

    // a == -0x30 即：0x30 + a == 0
    a = ~0x30 + 1;

    // 获取 x + a 的符号位，其它位置为 0
    a = sign & (a + x);

    // 对 a 的符号位取反，其它位依然是 0
    a = sign & (~a);

    // b == ~0x39 == ~0x39 + 1 - 1 == -0x39 - 1 == -0x3a
    // 即：0x39 + b == -1
    // 即：0x3a + b ==  0
    b = ~0x39;

    // 获取 x + b 的符号位，其它位置为 0
    b = sign & (b + x);

    // 如果 x 属于 [0x30, 0x39]
    // a == 0x8000 0000
    // b == 0x8000 0000
    return !!(a & b);
  }

