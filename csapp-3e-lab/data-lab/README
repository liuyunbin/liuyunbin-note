***********************
 csapp-3e-lab-data-lab
***********************

本实验主要用于熟悉整数和浮点数的位的表示

实验官网：http://csapp.cs.cmu.edu/3e/labs.html

********************************************
问题一：使用位操作 非 和 且 实现位操作 异或
********************************************
思路：

对于 x，y 中的每一位，都有以下四种情况：
1. x 中为 0，y 中为 0
2. x 中为 0，y 中为 1
3. x 中为 1，y 中为 0
4. x 中为 1，y 中为 1

我们需要的只有情况 2 和 情况 3，但是由于我们不能使用 或 操作，
所以无法直接找到情况 2 和 情况 3，也不能直接将情况 2 和 情况 3 相 或，
因此，我们这里使用 非 操作，利用情况 1 和 情况 4，
找到同时包含情况 1 2 3 的情况 和 同时包含情况 2 3 4 的情况，
然后取 且 操作

代码：

  int bitXor(int x, int y) {
    // 情况 1
    int a = (~x) & (~y);
    // 情况 2 3 4
    int b = ~a;
    // 情况 4
    int c = x & y;
    // 情况 1 2 3
    int d = ~c;
    return b & d;
  }

********************************************
问题二：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    求得整数的最小值
********************************************
思路：

由于，题目假设整数为 32 位，
而，补码表示的最小值为：符号位为 1，其它位为 0，
所以直接移位即可

代码：

  int tmin(void) {
    return 0x1 << 31;
  }

**********************************
问题三：
    使用
        位操作 非、且、或、异或，
        逻辑操作 非，
        加法运算符
    判断 x 是否是整数的最大值
**********************************
思路：

就 补码 而言，满足 ~x + 1 == x 的情况只有两种，即 0x0000 0000 和 0x8000 0000，
而，整数的最大值为 0x7FFF FFFF，
所以，如果 x == 0x7FFF FFFF，x + 1 == 0x8000 0000，
      如果 x == 0xFFFF FFFF，x + 1 == 0x0000 0000，
所以，我们只需要判断 ((~x) + 1) ^ x 为 0，
然后，排除掉 x 为 0 的情况

注意：

最好不要使用可能导致溢出的代码，可能会有可移植性的问题

代码：

  int isTmax(int x) {
    int y = x + 1;
    return (!((~y + 1) ^ y)) & (!!y);
  }

*******************************************
问题四：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断 x 的奇数位是否都为 1，
    从右往左数，[0, 31]
*******************************************
思路：

只要 x & 0xAAAA AAAA == 0xAAAA AAAA 即可，
但是，题目要求不能使用大于 0xFF 的常量，
所以，我们通过 将 0xAA 移位来获取 0xAAAA AAAA

代码：
  int allOddBits(int x) {
    // a == 0xAAAA
    int a = (0xAA << 8) + 0xAA;
    // a == 0xAAAA AAAA
    a = (a << 16) + a;
    return !((a & x) ^ a);
  }

*******************************************
问题五：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    求 x 相反数
*******************************************
思路：

对于 补码 而言，x 的相反数为 ~x + 1

代码：

  int negate(int x) {
    return ~x + 1;
  }

************************************************
问题六：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断 x 是否属于 [0x30, 0x39] 即 ['0', '9']
************************************************
思路：

给定数字 a，我们可以找一个临界点，
使得 当 x <  0x30 时，a + x <  0
     当 x >= 0x30 时，a + x >= 0
给定数字 b，我们可以找一个临界点，
使得 当 x <= 0x39 时，b + x <  0
使得 当 x >  0x39 时，b + x >= 0

详情见代码注释

注意：尽量不要使用位右移

代码：

  int isAsciiDigit(int x) {
    int sign;
    int a;
    int b;

    // 符号位置为 1，其它位为 0
    sign = 0x1 << 31;

    // a == -0x30 即：0x30 + a == 0
    a = ~0x30 + 1;

    // 获取 x + a 的符号位，其它位置为 0
    a = sign & (a + x);

    // 对 a 的符号位取反，其它位依然是 0
    a = sign & (~a);

    // b == ~0x39 == ~0x39 + 1 - 1 == -0x39 - 1 == -0x3a
    // 即：0x39 + b == -1
    // 即：0x3a + b ==  0
    b = ~0x39;

    // 获取 x + b 的符号位，其它位置为 0
    b = sign & (b + x);

    // 如果 x 属于 [0x30, 0x39]
    // a == 0x8000 0000
    // b == 0x8000 0000
    return !!(a & b);
  }

************************************************
问题七：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    实现条件运算符
************************************************
思路：

0x0000 0000 和 x 进行 位操作 与 结果为 0x0000 0000
0x0000 0000 和 x 进行 位操作 或 结果为 x
0xFFFF FFFF 和 x 进行 位操作 与 结果为 x

如果 x == 0，则 !!x == 0
如果 x != 0，则 !!x == 1

如果 x == 0，则 ~x + 1 ==  0 即 x == 0x0000 0000
如果 x == 1，则 ~x + 1 == -1 即 x == 0xFFFF FFFF

所以，先将 x 转为 0 或 1，然后转为 0x0000 0000 或 0xFFFF FFFF，
最后，如果 x == 0，
           (x & Y) | (~x & z) == 0 | z == z
      如果 x != 0，
           (x & Y) | (~x & z) == y | 0 == y

  int conditional(int x, int y, int z) {
    // x == 0 或 1
    x = !!x;
    // x == 0x0000 0000 或 0xFFFF FFFF
    x = ~x + 1;
    return (x & y) | (~x & z);
  }

************************************************
问题八：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断 小于等于
************************************************
思路：

不能直接相减，因为，异号相减可能会溢出，
所以，我们总共有分四种情况：
1. x >= 0, y >= 0
2. x >= 0, y <  0
3. x <  0, y >= 0
4. x <  0, y <  0

判断是否同号，用符号位的异或，
求 x - y 用 x + ~y + 1

其它思路和实现条件运算符很像

详情见代码注释

代码：

  int isLessOrEqual(int x, int y) {
    int sign;
    int a;
    int b;
    int c;
    int d;

    // 符号位置为 1，其它位为 0
    sign = 0x1 << 31;

    // 如果 a，b 异号，a == 0x8000 0000，否则，a == 0x0000 0000
    a = (sign & x) ^ (sign & y);

    // 如果 a，b 异号，a == 1，否则，a == 0
    a = !!a;

    // 如果 a，b 异号，a == 0xFFFF FFFF，否则，a == 0x0000 0000
    a = ~a + 1;

    // b = x - y
    b = x + ~y + 1;

    // 如果 x，y 异号 且 x <  0，c == 1，否则，c == 0
    c = !!(a & (x & sign));

    // 如果 x，y 同号 且 x <= y，c == 1，否则，c == 0
    d = !!((~a) & ((b & sign) | (!b)));

    return c | d;
  }

************************************************
问题九：
    使用
        位操作 非、且、或、异或、左移右移，
        加法运算符
    实现逻辑 非
************************************************
思路：

分三种情况：
1. 0x0000 0000 的补码是其本身，符号位是 0
2. 0x8000 0000 的补码是其本身，符号位是 1
3. x 与 -x 对应的符号位为 01 或 10

详情见代码注释

代码：

  int logicalNeg(int x) {
    int a;
    int b;

    // 如果 x 与 -x 的符号位不同，a 的最低位为 1, 否则 a 的最低位为 0
    a = (x ^ (~x + 1)) >> 31;

    // 如果 x 的最高位为 1，b 的最低位为 1，否则，b 的最低位为 0
    b = x >> 31;

    return ~(a | b) & 0x1;
  }

************************************************
问题十：
    使用
        位操作 非、且、或、异或、左移右移，
        逻辑操作 非，
        加法运算符
    判断至少需要多少位，才能存储 x
************************************************
思路：

如果高位有 1，则，低位是必须的，
比如，如果，[16, 32) 位存在 1，则 [0, 16) 未是必须的，
因此，每次可以砍掉一半的情况

如果，x < 0，必须处理掉前面连续的 1，通过取反来获得

最后记得加上符号位

详情见代码注释

代码：

  int howManyBits(int x) {
    int a;
    int b;
    int ret;

    // 如果，x < 0，a == 1，否则，a == 0
    a = (x >> 31) & 0x1;

    // 如果，a == 1，a == 0xFFFF FFFF，否则，a == 0x0000 0000
    a = ~a + 1;

    // 如果 x >= 0, 则不变，
    // 如果 x <  0，按位取反，前面连续的 1 都变为 0
    x = (a & ~x) | (~a & x);

    // 位从右往左数，从 0 开始

    // 如果 x 的 [16, 32) 位存在 1，b == 16，否则，b == 0
    b = !!(x >> 16) << 4;
    // 如果 x 的 [16, 32) 位存在 1
    //    则 [0, 16) 位是必须的，只要判断 [16, 32) 位即可，
    //    将 x 右移 16 位
    ret = b;
    x = x >> b;

    // 接下来判断 [8, 16) 位
    // 如果 x 的 [8, 16) 位存在 1，b == 8，否则，b == 0
    b = !!(x >> 8) << 3;
    // 如果 x 的 [8, 16) 位存在 1
    //    则 [0, 8) 位是必须的，只要判断 [8, 16) 位即可，
    //    将 x 右移 8 位
    ret += b;
    x = x >> b;

    // 接下来判断 [4, 8) 位
    // 如果 x 的 [4, 8) 位存在 1，b == 4，否则，b == 0
    b = !!(x >> 4) << 2;
    // 如果 x 的 [4, 8) 位存在 1
    //    则 [0, 4) 位是必须的，只要判断 [4, 8) 位即可，
    //    将 x 右移 4 位
    ret += b;
    x = x >> b;

    // 接下来判断 [2, 4) 位
    // 如果 x 的 [2, 4) 位存在 1，b == 2，否则，b == 0
    b = !!(x >> 2) << 1;
    // 如果 x 的 [4, 8) 位存在 1
    //    则 [0, 2) 位是必须的，只要判断 [2, 4) 位即可，
    //    将 x 右移 2 位
    ret += b;
    x = x >> b;

    // 接下来判断 [1, 2) 位
    // 如果 x 的 [1, 2) 位存在 1，b == 1，否则，b == 0
    b = !!(x >> 1) << 0;
    // 如果 x 的 [1, 2) 位存在 1
    //    则 [0, 1) 位是必须的，只要判断 [1, 2) 位即可，
    //    将 x 右移 1 位
    ret += b;
    x = x >> b;

    // 接下来判断 [0, 1) 位
    ret += x;

    return ret + 1; // 加上符号位
  }

