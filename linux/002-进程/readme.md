
# 进程
## 存储布局
* 正文段(text):
    * 存储程序本身, 只读, 可共享
    * 内存中只存储一份, 磁盘中需要存储
* 数据段(data)
    * 存储初始化的全局变量或静态变量
    * 内存中每个进程一份, 磁盘中需要存储
* bss
    * 存储未初始化的全局变量或静态变量
    * 内存中每个进程一份, 磁盘中不需要存储
    * 程序启动时初始化为 0
* 栈: 磁盘中不需要存储
* 堆: 磁盘中不需要存储
    * malloc(): 存储空间分配, 未初始化
    * calloc(): 存储空间分配, 初始化为 0
    * realloc(): 重新存储空间分配
    * free(): 释放内存
* 使用 size 可以查看各个部分的大小

## 共享库
* 静态库: 编译到可执行文件
* 动态库: 启动或运行时, 加载到可执行文件
    * g++ -fPIC -shared test.cc -o libtest.so

## 状态及改变
* 就绪
* 运行(R)
* 休眠(S)(可被信号打断)(指被捕获的信号)
    * pause() 只有收到未忽略的信号才返回
    * sleep() 只有收到未忽略的信号 或 到达指定秒数才返回 -- 01.cc
        1. 使用 fork() 产生子进程
        2. 子进程设置信号(SIGUSR1)处理函数
        3. 子进程休眠10s
        4. 父进程休眠1s
        5. 此时, 可以看到, 子进程处于休眠状态
        6. 向子进程发送信号(SIGUSR1)
        7. 此时, 子进程被唤醒(休眠时间小于10s)
* 休眠(D)(不可被信号打断)(指被捕获的信号)
   * 调用 vfork() 后的父进程 -- 02.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程设置信号(SIGUSR1)处理函数
        3. 测试的父进程使用 vfork() 产生测试的子进程
        4. 测试的子进程休眠10s
        5. 测试的父进程休眠1s
        6. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        7. 向测试的父进程发送信号(SIGUSR1)
        8. 此时, 父进程处于不可打断的状态, 所以不会处理
        9. 测试的子进程休眠完成(休眠时间为10s)
        10. 测试的父进程处理信号, 直到结束
   * SIGSTOP 也会被阻塞 -- 03.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程使用 vfork() 产生测试的子进程
        3. 测试的子进程休眠10s
        4. 测试的父进程休眠1s
        5. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        6. 向测试的父进程发送信号(SIGSTOP)
        7. 此时, 父进程处于不可打断的状态, 所以不会处理
        8. 向测试的父进程发送信号(SIGCONT)
        9. 此时, 父进程处于不可打断的状态, 所以不会处理
        10. 测试的子进程休眠完成(休眠时间为10s)
        11. 测试的父进程继续运行, 直到结束
   * SIGKILL 不会被阻塞 -- 04.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程使用 vfork() 产生测试的子进程
        3. 测试的子进程休眠10s
        4. 测试的父进程休眠1s
        5. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        6. 向测试的父进程发送信号(SIGKILL)
        7. 测试的父进程退出
        8. 测试的子进程休眠完成(休眠时间为10s)
        9. 主进程结束
* 暂停(T)(作业控制)
    * 收到信号 SIGSTOP
    * 收到信号 SIGTSTP, 可由 ctrl+z 产生
    * 收到信号 SIGTTIN, 处于后台进程时读终端
    * 收到信号 SIGTTOT, 处于后台进程时写终端, 这个得看设置是否允许后台进程写终端
    * 继续, 收到信号 SIGCONT -- 05.cc
        1. 使用 fork() 产生子进程
        2. 子进程设置信号(SIGUSR1)处理函数
        3. 子进程空循环
        4. 父进程发送信号给子进程(SIGSTOP)
        5. 子进程暂停
        6. 父进程发送信号给子进程(SIGUSR1)
        7. 此时, 子进程处于暂停, 不会处理该信号
        8. 父进程发送信号给子进程(SIGCONT)
        9. 子进程继续, 然后处理 SIGUSR1, 直到结束
* 暂停(t)(由于 DEBUG 产生)
* 空闲(I)
    * 处于不可被打断的休眠状态时, 有时 CPU 是空闲的
* 僵尸(Z)
    * 子进程已退出, 父进程还未处理
* 退出(X)

## core 不能生成的原因
* 设置了 SUID, 进程的实际用户不是可执行文件的所有者
* 设置了 SGID, 进程的实际组不是可执行文件组的所有者
* 没有写当前目录的权限
* 文件已存在, 但无权限修改
* 文件太大, 受 ulimit 的限制

## ubuntu 生产 core
1. ulimit -c unlimited -- 设置 core 文件大小的软限制不受限制
2. /etc/sysctl.conf 添加 `kernel.core_pattern=%e.%p` -- 文件名, 进程号
3. sudo sysctl -p -- 配置生效

## 常用函数
```
* fork() --- 产生子进程, 父子进程使用各自的空间
             父子进程的执行顺序不确定
             进程数太多或者超出自己的限制会报错
             实际用户, 有效用户, 保存的 UID, 进程组, 会话, 信号处理等保持不变
             文件锁, 未处理的信号集, 进程时间将被清空
* vfork() -- 产生子进程, 父子进程共享空间
             子进程退出或调用 exec 前, 父进程处于不可被信号打断的休眠状态
* exec() --- 执行命令
             实际用户, 实际组不变
             设置了用户ID, 有效用户变为文件所有者, 否则不变

*           exit(): 调用 atexit() 登记的函数, 调用析构函数, 刷新标准IO流, 关闭文件描述符
*          _exit(): 直接进入内核, 关闭文件描述符
*          _Exit(): 直接进入内核, 关闭文件描述符
*   pthread_exit(): 线程主动退出
* pthread_cancel(): 取消另一线程
*          abort(): 默认刷新标准IO流, 关闭文件描述符

* getenv(): 获取环境变量
* putenv(): 设置环境变量

* longjmp(): 跨函数跳转
*  setjmp()

* getrlimit(): 获取资源使用的限制
* setrlimit(): 设置资源使用的限制
    * 软限制值可以任意修改, 只要小于等于硬限制值即可
    * 硬限制值可以降低, 只要大于等于软限制值即可
    * 只有超级用户才可以提高硬限制值

waitpid(&status) --- 获取子进程的状态变化的信息
    * WIFEXITED() -- 正常终止
        * WEXITSTATUS() -- 正常退出的状态
    * WIFSIGNALED() -- 信号导致退出
        * WTERMSIG() --  导致退出的信号
        * WCOREDUMP() -- 导致产生 core 的信号
    * WIFSTOPPED() -- 暂停
        * WSTOPSIG() -- 导致暂停的信号
    * WIFCONTINUED() -- 继续
    * WNOHANG -- 没有子进程退出时, 立刻返回
    * WUNTRACED -- 子进程暂停时, 也检测
    * WCONTINUED -- 子进程继续时, 也检测

## 进程优先级
* nice() -- 值越小, 优先级越高

time() -- 进程时间
    * 时间耗时
    * 用户 CPU 时间
    * 相同 CPU 时间

* getpid() -- 进程ID
* getppid() --- 父进程ID

## 实际用户 有效用户
* getuid()
* geteuid()
* setuid(uid)
    * root 用户:
        * 实际, 有效, 保存的用户ID 都改成 uid
    * 普通用户:
        * 如果 uid == 实际ID 或 保存的用户ID, 则, 将有效的用户ID 改为 uid
* setreuid(): 设置实际和有效用户ID
* seteuid(): 设置有效用户ID

## 解释器文件
* 第一行以 `#!` 开头
* 等价于: 解释器文件第一行(不包括 #!) + 解释器文件 + 其他参数
```

## 常用文件
```
/proc/loadavg     # 系统负载
/proc/cpuinfo     # cpu 信息
/proc/uptime      # 运行时间
/proc/sys

/proc/PID/cmdline # 完整的启动命令
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/comm    # 进程名称, 不包含路径名称, 最多 15 位
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/cwd     # 进程当前的目录
/proc/PID/exe     # 符号链接, 指向运行的进程
/proc/PID/environ # 进程使用的环境变量
/proc/PID/fd      # 进程所打开的文件描述符
/proc/PID/limits  # 进程对各种资源的限制
/proc/PID/task    # 进程使用的线程情况
```

## 常用命令
```
```
* ulimit -c ------------ 查看 core 文件大小的软限制
* ulimit -c -H --------- 查看 core 文件大小的硬限制
* ulimit -c unlimited -- 设置 core 文件大小的软限制不受限制

