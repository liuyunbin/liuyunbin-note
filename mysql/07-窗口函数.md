
## 窗口函数
```
在不改变原表行数的情况下进行分组和排序计算
GROUP BY: 分组并合并
窗口函数: 只分组不合并

语法:
窗口函数 OVER (PARTITION BY 分组的列 ORDER BY 排序的列 ROWS  BETWEEN <数据范围> AND <数据范围>)
窗口函数 OVER (PARTITION BY 分组的列 ORDER BY 排序的列 RANGE BETWEEN <数据范围> AND <数据范围>)

数据范围:
current row ---------------- 当前行
数字      preceding -------- 当前行的前n行, 或 当前值减数字
unbounded preceding --------   第一行
数字      following -------- 当前行的后n行, 或 当前值加数字
unbounded following -------- 最后一行

  有 ORDER BY 没有 ROWS BETWEEN 时, 窗口取本行和之前所有的行
没有 ORDER BY 没有 ROWS BETWEEN 时, 窗口是分组下所有行

动态窗口函数: FIRST_VALUE() LAST_VALUE() NTH_VALUE()  SUM() AVG() MAX() MIN() COUNT()
静态窗口函数: ROW_NUMBER() RANK() DENSE_RANK() PERCENT_RANK() CUME_DIST() LAG() LEAD() NTILE()

数据范围指针对动态窗口函数有效
```

## 测试窗口函数
```
USE    test;
DROP   TABLE IF EXISTS student;
CREATE TABLE student(
  name      VARCHAR(20),
  class_id  INT,
  score     DECIMAL
);

INSERT INTO student VALUES('张三', 1, 99);
INSERT INTO student VALUES('张四', 1, 100);
INSERT INTO student VALUES('张五', 1, 99);
INSERT INTO student VALUES('张六', 1, 98);

INSERT INTO student VALUES('李三', 2, 89);
INSERT INTO student VALUES('李四', 2, 88);
INSERT INTO student VALUES('李五', 2, 89);
INSERT INTO student VALUES('李六', 2, 87);

INSERT INTO student VALUES('王三', 3, 79);
INSERT INTO student VALUES('王四', 3, 78);
INSERT INTO student VALUES('王五', 3, 79);
INSERT INTO student VALUES('王六', 3, 77);

SELECT * FROM student ORDER BY score DESC;

# 1. 测试 序号函数 ----- 静态窗口函数
RANK() --------------- 相同的值排名  相同, 排名不连续, 例如 1 2 2 4
DENSE_RANK() --------- 相同的值排名  相同, 排名  连续, 例如 1 2 2 3
ROW_NUMBER() --------- 相同的值排名不相同, 排名  连续, 例如 1 2 3 4

# 1.1 比较三个序号函数的区别
SELECT
  *,
  RANK() OVER w, DENSE_RANK() OVER w, ROW_NUMBER() OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC);

# 1.2 证明是 静态窗口函数, 使用  ROWS BETWEEN ... AND ... ,没用
SELECT
  *,
        RANK() OVER (PARTITION BY class_id ORDER BY score DESC),
        RANK() OVER (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 1 following),
  DENSE_RANK() OVER (PARTITION BY class_id ORDER BY score DESC),
  DENSE_RANK() OVER (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 1 following),
  ROW_NUMBER() OVER (PARTITION BY class_id ORDER BY score DESC),
  ROW_NUMBER() OVER (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 1 following)
FROM student;

# 2. 测试 分布函数 ----- 静态窗口函数
PERCENT_RANK() ------- 排名百分比:  (rank - 1) / (rows - 1)
CUME_DIST() ---------- 小于等于某一值的比例

# 2.1 比较两个分布函数的区别
SELECT
  *,
  PERCENT_RANK() OVER w, CUME_DIST() OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC);

# 2.2 证明是 静态窗口函数, 使用  ROWS BETWEEN ... AND ... ,没用
SELECT
  *,
  PERCENT_RANK() OVER (PARTITION BY class_id ORDER BY score DESC),
  PERCENT_RANK() OVER (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 1 following),
     CUME_DIST() OVER (PARTITION BY class_id ORDER BY score DESC),
     CUME_DIST() OVER (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 1 following)
FROM student;

# 3. 测试 前后函数 ----- 静态窗口函数
 LAG(expr,n) --------- 当前行的前n行的expr的值
LEAD(expr,n) --------- 当前行的后n行的expr的值

# 3.1 比较两个前后函数的区别
SELECT
  *,
  LAG(score,2) OVER w, LEAD(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC);

# 3.2 证明是 静态窗口函数, 使用  ROWS BETWEEN ... AND ... ,没用
SELECT
  *,
  LAG(score,2)  OVER (PARTITION BY class_id ORDER BY score DESC),
  LAG(score,2)  OVER (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 1 following),
  LEAD(score,2) OVER (PARTITION BY class_id ORDER BY score DESC),
  LEAD(score,2) OVER (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 1 following)
FROM student;

# 4. 测试 NTILE(n) 函数 ----- 静态窗口函数
将数据分成 n 组, 返回组编号

# 4.1 比较两个前后函数的区别
SELECT
  *,
  NTILE(2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC);

# 4.2 证明是 静态窗口函数, 使用  ROWS BETWEEN ... AND ... ,没用
SELECT
  *,
  NTILE(2) OVER (PARTITION BY class_id ORDER BY score DESC),
  NTILE(2) OVER (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 1 following)
FROM student;

# 5. 动态窗口函数
FIRST_VALUE(expr) ---- 第一个expr的值
 LAST_VALUE(expr) ---- 最后一个expr的值
  NTH_VALUE(expr,n) -- 第n个expr的值 
  
# 5.1 无 ORDER BY 无 rows between ----- 窗口是分组下所有行
SELECT
  *,
  FIRST_VALUE(score) OVER w, LAST_VALUE(score) OVER w, NTH_VALUE(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id);

# 5.2 有 ORDER BY 无 rows between ----- 窗口是 [第一行, 当前行]
SELECT
  *,
  FIRST_VALUE(score) OVER w, LAST_VALUE(score) OVER w, NTH_VALUE(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC);

# 5.3 有 ORDER BY 有 rows between ----- 指定窗口 [第一行, 当前行]
SELECT
  *,
  FIRST_VALUE(score) OVER w, LAST_VALUE(score) OVER w, NTH_VALUE(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN unbounded preceding AND current row);

# 5.4 有 ORDER BY 有 rows between ----- 指定窗口 [当前行的前两行, 当前行]
SELECT
  *,
  FIRST_VALUE(score) OVER w, LAST_VALUE(score) OVER w, NTH_VALUE(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN 2 preceding AND current row);

# 5.5 有 ORDER BY 有 rows between ----- 指定窗口 [当前行, 最后一行]
SELECT
  *,
  FIRST_VALUE(score) OVER w, LAST_VALUE(score) OVER w, NTH_VALUE(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND unbounded following);
  
# 5.6 有 ORDER BY 有 rows between ----- 指定窗口 [当前行, 当前行的后两行]
SELECT
  *,
  FIRST_VALUE(score) OVER w, LAST_VALUE(score) OVER w, NTH_VALUE(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN current row AND 2 following);

# 5.7 有 ORDER BY 有 rows between ----- 指定窗口 [当前行的前一行, 当前行的后一行]
SELECT
  *,
  FIRST_VALUE(score) OVER w, LAST_VALUE(score) OVER w, NTH_VALUE(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN 1 preceding AND 1 following);

# 5.8 有 ORDER BY 有 rows between ----- 指定窗口 [第一行, 最后一行]
SELECT
  *,
  FIRST_VALUE(score) OVER w, LAST_VALUE(score) OVER w, NTH_VALUE(score,2) OVER w
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN unbounded preceding AND unbounded following);

# 5.9 聚合函数同上
SELECT
  *,
    SUM(score) OVER w t_sum,
    AVG(score) OVER w t_avg,
  COUNT(score) OVER w t_count,
    MAX(score) OVER w t_max,
    MIN(score) OVER w t_min
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC ROWS BETWEEN 1 preceding AND current row);

# 5.10 使用 RANGE
SELECT
  *,
    sum(score) OVER w t_sum,
    avg(score) OVER w t_avg,
  count(score) OVER w t_count,
    max(score) OVER w t_max,
    min(score) OVER w t_min
FROM student
WINDOW w AS (PARTITION BY class_id ORDER BY score DESC RANGE BETWEEN 1 preceding AND current row);
```

## 实战
```
排名问题：每个部门按业绩来排名
topN问题：找出每个部门排名前N的员工进行奖励
```

