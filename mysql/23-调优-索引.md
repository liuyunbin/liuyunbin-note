
## 1. 准备数据
```
DROP   DATABASE IF EXISTS test;
CREATE DATABASE test;
USE    test;
```

#### 1.1 创建学生表和课程表
```
DROP   TABLE IF EXISTS student_info;
CREATE TABLE student_info (
           id INT AUTO_INCREMENT PRIMARY KEY,
   student_id INT NOT NULL ,
         name VARCHAR(20) DEFAULT NULL,
    course_id INT NOT NULL ,
     class_id INT DEFAULT NULL,
  create_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

DROP   TABLE IF EXISTS course;
CREATE TABLE course (
    id INT AUTO_INCREMENT PRIMARY KEY,
    course_id INT NOT NULL ,
    course_name VARCHAR(40) DEFAULT NULL
);

SET GLOBAL log_bin_trust_function_creators=1; # 需要有权限
```

#### 1.2 创建函数返回一个字符串
```
DELIMITER $
CREATE FUNCTION rand_string(n INT)
	RETURNS VARCHAR(255) 
BEGIN
    DECLARE  chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
    DECLARE i          INT          DEFAULT 0;

    WHILE i < n DO
    	SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
    	SET i = i + 1;
    END WHILE;
    RETURN return_str;
END $
DELIMITER ;
```

#### 1.3 创建函数随机数函数
```
DELIMITER $
CREATE FUNCTION rand_num (from_num INT, to_num INT)
RETURNS INT(11)
BEGIN
    DECLARE i INT DEFAULT 0;
    SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
    RETURN i;
END $
DELIMITER ;
```

#### 1.4 存储过程：插入课程表
```
DELIMITER $
CREATE PROCEDURE insert_course( max_num INT )
BEGIN
    DECLARE i INT DEFAULT 0;
    SET autocommit = 0;
    REPEAT
        SET i = i + 1;
        INSERT INTO course (course_id, course_name ) VALUES
                (rand_num(10000,10100),rand_string(6));
    UNTIL i = max_num
    END REPEAT;
    COMMIT;
END $
DELIMITER ;
```

#### 1.5 存储过程: 插入学生信息表
```
DELIMITER $
CREATE PROCEDURE insert_stu(max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
    SET autocommit = 0;
    REPEAT
        SET i = i + 1;
        INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES
            (rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));
    UNTIL i = max_num
    END REPEAT;
    COMMIT;
END $
DELIMITER ;
```

#### 1.6 产生课程
```
CALL insert_course(100);
```

#### 1.7 产生学生
```
CALL insert_stu(10000000); # 100  万 --> 54s
                           # 1000 万 --> 1563.862s
```

#### 1.8 查看数据
```
SELECT count(*) FROM student_info;
SELECT count(*) FROM course;
```

## 2 测试索引的作用
#### 2.1 测试在单列添加索引
```
DROP INDEX student_id_index ON student_info;               # 1. 删除之前存在的索引(可选)
SELECT * FROM student_info ORDER BY id DESC LIMIT 5;       # 2. 找到 id 靠后的一个学生的信息 12.32s
SELECT * FROM student_info WHERE student_id = 137587;      # 3. 测试 whehe 3.903s
CREATE INDEX student_id_index ON student_info(student_id); # 4. 创建索引 16.055s
SELECT * FROM student_info WHERE student_id = 137587;      # 5. 测试 whehe 0.210s
                                                           #    获取除该索引和主键外的其他值, 需要回表
SELECT id, student_id FROM student_info WHERE student_id = 137587;
                                                           # 6. 测试 whehe 0.186s
                                                           #    只获取该索引和主键外, 不需要回表
EXPLAIN SELECT * FROM student_info WHERE name = 'uWxAgi' && student_id = 137587;
                                                           # 7. AND 会使用索引 
EXPLAIN SELECT * FROM student_info WHERE name = 'uWxAgi' || student_id = 137587;
                                                           # 8. OR 不会使用索引
SELECT * FROM student_info WHERE id = 10999996;            # 9. 主键索引不需要回表 0.177
SELECT id, student_id FROM student_info WHERE id = 10999996;
                                                           # 10. 主键索引不需要回表 0.176
```

#### 2.2 测试多个单列索引和联合索引
```
DROP INDEX   student_id_index ON student_info;                 # 1. 删除之前存在的索引 student_id_index
DROP INDEX student_name_index ON student_info;                 # 2. 删除之前存在的索引 student_name_index 
SELECT * FROM student_info ORDER BY id DESC LIMIT 5;           # 3. 找到 id 靠后的一个学生的信息 12.32s
SELECT * FROM student_info WHERE name = 'uWxAgi' && student_id = 137587;
                                                               # 4. 测试 WHERE多列 3.894s
CREATE INDEX   student_id_index ON student_info(student_id);   # 5. 创建索引   student_id_index 16.055s
CREATE INDEX student_name_index ON student_info(name);         # 6. 建索引 student_name_index 21.758s
EXPLAIN SELECT * FROM student_info WHERE name = 'uWxAgi' && student_id = 137587;
                                                               # 7. 测试 WHERE多列 0.231s
                                                               #    会同时使用多个索引
DROP INDEX   student_id_index ON student_info;                 # 8. 删除之前存在的索引 student_id_index
DROP INDEX student_name_index ON student_info;                 # 9. 删除之前存在的索引 
CREATE INDEX   student_id_index ON student_info(student_id, name);
                                                               # 10. 创建联合索引  16.055s
EXPLAIN SELECT * FROM student_info WHERE name = 'uWxAgi' && student_id = 137587;
                                                               # 11. 测试 WHERE多列 0.180s
                                                               #     优于多个索引
EXPLAIN SELECT * FROM student_info WHERE name = 'uWxAgi';      # 12. 只查 name       不走索引 4.142s
EXPLAIN SELECT * FROM student_info WHERE student_id = 137587;  # 13. 只查 student_id   走索引 0.195s
```

## 4. 索引失效
```
DROP INDEX   student_id_index    ON student_info; # 1. 删除之前存在的索引 student_id_index
DROP INDEX student_name_index    ON student_info; # 2. 删除之前存在的索引 student_name_index 
DROP INDEX mul_id_name           ON student_info; # 3. 删除之前存在的索引 mul_id_name 
DROP INDEX mul_id_name_course_id ON student_info; # 4. 删除之前存在的索引 mul_id_name_course_id 

SHOW INDEX FROM student_info;

```

           id INT AUTO_INCREMENT PRIMARY KEY,
   student_id INT NOT NULL ,
         name VARCHAR(20) DEFAULT NULL,
    course_id INT NOT NULL ,
     class_id INT DEFAULT NULL,
  create_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
  
#### 4.1
```
DROP INDEX   student_id_index ON student_info;                 # 1. 删除之前存在的索引 student_id_index
DROP INDEX student_name_index ON student_info;                 # 2. 删除之前存在的索引 student_name_index 
SELECT * FROM student_info ORDER BY id DESC LIMIT 5;           # 3. 找到 id 靠后的一个学生的信息 12.32s
SELECT * FROM student_info WHERE student_id = 137587;          # 4. 测试 4.031s
CREATE INDEX   student_id_index ON student_info(student_id);   # 5. 创建索引   student_id_index 16.055s
SELECT * FROM student_info WHERE student_id = 137587;          # 6. 测试 0.203s
EXPLAIN SELECT * FROM student_info WHERE student_id = 137587;  # 7. 查看执行计划
CREATE INDEX   mul_id_name_course_id ON student_info(student_id, name, course_id);
                                                               # 8. 创建联合索引 18.268s
EXPLAIN SELECT * FROM student_info WHERE student_id = 137587;  # 9. 查看执行计划
SELECT * FROM student_info WHERE student_id = 137587;          # 10. 测试 0.199s
EXPLAIN SELECT * FROM student_info WHERE student_id = 123 AND name = '123' AND course_id = 111; 
                                                               # 11. 复合索引正常使用
EXPLAIN SELECT * FROM student_info WHERE student_id = 123;     # 12. 复合索引, 使用第一个字段, 索引有效
EXPLAIN SELECT * FROM student_info WHERE name = '123';         # 13. 复合索引, 使用第二个字段, 索引失效
EXPLAIN SELECT * FROM student_info WHERE course_id = 111;      # 14. 复合索引, 使用第三个字段, 索引失效
EXPLAIN SELECT * FROM student_info WHERE student_id = 123 AND name = '123'; 
                                                               # 15. 复合索引, 使用第一二字段, 索引有效
EXPLAIN SELECT * FROM student_info WHERE student_id = 123 AND course_id = 111; 
                                                               # 16. 复合索引, 使用第一三字段, 索引有效
EXPLAIN SELECT * FROM student_info WHERE name = '123' AND course_id = 111; 
                                                               # 17. 复合索引, 使用第二三字段, 索引失效
EXPLAIN SELECT * FROM student_info WHERE student_id + 1 = 123; # 18. 使用运算符导致索引失效
                                                               #     包括函数 类型转换都会导致索引失效
EXPLAIN SELECT * FROM student_info WHERE student_id = 123 - 1; # 19. 索引有效
EXPLAIN SELECT * FROM student_info WHERE student_id = 123 AND name > '123' AND course_id = 111;
                                                               # 20. 索引有效

EXPLAIN SELECT * FROM student_info WHERE student_id = 123 AND name = '123';
                                                               # 12. 复合索引正常
EXPLAIN SELECT * FROM student_info WHERE name = '123' AND student_id = 123;
                                                               # 13. 复合索引正常
EXPLAIN SELECT * FROM student_info WHERE student_id = 123 OR name = '123';
                                                               # 14. 复合索引正常
EXPLAIN SELECT * FROM student_info WHERE name = '123' OR student_id = 123;
                                                               # 15. 复合索引正常

SELECT * FROM student_info WHERE name       = '123';           # 12. 测试 0.199s


CREATE INDEX student_name_index ON student_info(name);         # 6. 建索引 student_name_index 21.758s
EXPLAIN SELECT * FROM student_info WHERE name = 'uWxAgi' && student_id = 137587;
                                                               # 7. 测试 WHERE多列 0.231s
                                                               #    会同时使用多个索引
DROP INDEX   student_id_index ON student_info;                 # 8. 删除之前存在的索引 student_id_index
DROP INDEX student_name_index ON student_info;                 # 9. 删除之前存在的索引 
CREATE INDEX   student_id_index ON student_info(student_id, name);
                                                               # 10. 创建联合索引  16.055s
EXPLAIN SELECT * FROM student_info WHERE name = 'uWxAgi' && student_id = 137587;
                                                               # 11. 测试 WHERE多列 0.180s
                                                               #     优于多个索引
EXPLAIN SELECT * FROM student_info WHERE name = 'uWxAgi';      # 12. 只查 name       不走索引 4.142s
EXPLAIN SELECT * FROM student_info WHERE student_id = 137587;  # 13. 只查 student_id   走索引 0.195s




SHOW STATUS LIKE Connections          ：连接MySQL服务器的次数。 
SHOW STATUS LIKE Uptime               ：MySQL服务器的上线时间。 

SHOW STATUS LIKE Innodb_rows_read     ：Select查询返回的行数 
SHOW STATUS LIKE Innodb_rows_inserted ：执行INSERT操作插入的行数 
SHOW STATUS LIKE Innodb_rows_updated  ：执行UPDATE操作更新的 行数 
SHOW STATUS LIKE Innodb_rows_deleted  ：执行DELETE操作删除的行数 

SHOW STATUS LIKE Com_select           ：查询操作的次数。 
SHOW STATUS LIKE Com_insert           ：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 
SHOW STATUS LIKE Com_update           ：更新操作 的次数。 
SHOW STATUS LIKE Com_delete           ：删除操作的次数。

SHOW STATUS LIKE 'last_query_cost'; # 统计SQL的查询成本

DROP TABLE IF EXISTS t1;
CREATE TABLE t1 (t1 INT PRIMARY KEY, t2 INT UNIQUE, t3 INT);

INSERT INTO t1 VALUES(123, 123, 123);
INSERT INTO t1 VALUES(456, 456, 456);
INSERT INTO t1 VALUES(789, 789, 789);

EXPLAIN SELECT * FROM t1 WHERE t3 = 123;
```
