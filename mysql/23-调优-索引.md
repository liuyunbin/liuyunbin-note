
## 1. 准备数据
```
DROP   DATABASE IF EXISTS test;
CREATE DATABASE test;
USE    test;
```

#### 1.1 创建学生表和课程表
```
DROP   TABLE IF EXISTS student_info;
CREATE TABLE student_info (
           id INT AUTO_INCREMENT PRIMARY KEY,
   student_id INT NOT NULL ,
         name VARCHAR(20) DEFAULT NULL,
    course_id INT NOT NULL ,
     class_id INT DEFAULT NULL,
  create_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

DROP   TABLE IF EXISTS course;
CREATE TABLE course (
    id INT AUTO_INCREMENT PRIMARY KEY,
    course_id INT NOT NULL ,
    course_name VARCHAR(40) DEFAULT NULL
);

SET GLOBAL log_bin_trust_function_creators=1; # 需要有权限
```

#### 1.2 创建函数返回一个字符串
```
DELIMITER $
CREATE FUNCTION rand_string(n INT)
	RETURNS VARCHAR(255) 
BEGIN
    DECLARE  chars_str VARCHAR(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
	DECLARE return_str VARCHAR(255) DEFAULT '';
    DECLARE i          INT          DEFAULT 0;

    WHILE i < n DO
    	SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));
    	SET i = i + 1;
    END WHILE;
    RETURN return_str;
END $
DELIMITER ;
```

#### 1.3 创建函数随机数函数
```
DELIMITER $
CREATE FUNCTION rand_num (from_num INT, to_num INT)
RETURNS INT(11)
BEGIN
    DECLARE i INT DEFAULT 0;
    SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;
    RETURN i;
END $
DELIMITER ;
```

#### 1.4 存储过程：插入课程表
```
DELIMITER $
CREATE PROCEDURE insert_course( max_num INT )
BEGIN
    DECLARE i INT DEFAULT 0;
    SET autocommit = 0;
    REPEAT
        SET i = i + 1;
        INSERT INTO course (course_id, course_name ) VALUES
                (rand_num(10000,10100),rand_string(6));
    UNTIL i = max_num
    END REPEAT;
    COMMIT;
END $
DELIMITER ;
```

#### 1.5 存储过程: 插入学生信息表
```
DELIMITER $
CREATE PROCEDURE insert_stu(max_num INT )
BEGIN
DECLARE i INT DEFAULT 0;
    SET autocommit = 0;
    REPEAT
        SET i = i + 1;
        INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES
            (rand_num(10000,10100),rand_num(10000,10200),rand_num(1,200000),rand_string(6));
    UNTIL i = max_num
    END REPEAT;
    COMMIT;
END $
DELIMITER ;
```

#### 1.6 产生课程
```
CALL insert_course(100);
```

#### 1.7 产生学生
```
CALL insert_stu(10000000); # 100  万 --> 54s
                           # 1000 万 --> 1563.862s
```

#### 1.8 查看数据
```
SELECT count(*) FROM student_info;
SELECT count(*) FROM course;
```

## 2 测试索引的作用
```
DROP INDEX student_id_index ON student_info;

EXPLAIN
SELECT course_id,class_id,name,create_time,student_id
FROM student_info
WHERE student_id = 123110; # 0.428s --  100 万
                           # 3.353s -- 1000 万
CREATE INDEX student_id_index ON student_info(student_id);

EXPLAIN
SELECT course_id,class_id,name,create_time,student_id
FROM student_info
WHERE student_id = 123110; # 0.193s --  100  万
                           # 0.228s --- 1000 万
```

## 3. 慢查询日志
```
SHOW VARIABLES LIKE '%slow_query_log%';          # 1. 查看慢查询日志是否开启及日志文件位置
SET  GLOBAL slow_query_log='ON';                 # 2. 开启慢查询日志
SHOW VARIABLES LIKE '%slow_query_log%';          # 3. 再次查看慢查询日志是否开启及日志文件位置

SHOW GLOBAL  VARIABLES LIKE '%long_query_time%'; # 4. 查看慢查询的时间阈值
SHOW SESSION VARIABLES LIKE '%long_query_time%'; #
SET  GLOB AL long_query_time = 1;                # 5. 设置慢查询的时间阈值
SET  SESSION long_query_time = 1;                #
SHOW GLOBAL  VARIABLES LIKE '%long_query_time%'; # 6. 再次查看慢查询的时间阈值
SHOW SESSION VARIABLES LIKE '%long_query_time%'; #

SHOW STATUS LIKE 'Slow_queries';                 # 7. 查看慢查询的次数
SELECT course_id,class_id,name,create_time,student_id
FROM student_info
WHERE student_id = 123110;                       # 8. 执行慢查询
SHOW STATUS LIKE 'Slow_queries';                 # 9. 再次查看慢查询的次数

                                                 # 10. 切换到慢查询目录
mysqldumpslow -s t -t 5 ....log                  # 11. 查询耗时最长的 5 条慢查询

SET  GLOBAL slow_query_log='OFF';                # 12. 开启慢查询日志
SHOW VARIABLES LIKE '%slow_query_log%';          # 13. 再次查看慢查询日志是否开启及日志文件位置


# 重建慢查询日志
SET GLOBAL slow_query_log=ON;        # 要打开慢查询日志
mysqladmin -uroot -p flush-logs slow # 重建慢查询日志
```

## 4. EXPLAIN
```
# 1. 造数据
USE    test;
DROP   TABLE IF EXISTS teacher1;
CREATE TABLE teacher1 (id INT PRIMARY KEY, name VARCHAR(20) unique, addr VARCHAR(20), extra varchar(20));
INSERT INTO  teacher1 VALUES(1, "中神通", "全真教", "111");
INSERT INTO  teacher1 VALUES(2, "东邪",   "桃花岛", "222");
INSERT INTO  teacher1 VALUES(3, "西毒",   "西域", "333");
INSERT INTO  teacher1 VALUES(4, "南帝",   "大理", "444");
INSERT INTO  teacher1 VALUES(5, "北丐",   "宋", "555");
INSERT INTO  teacher1 VALUES(6, "中顽童", "全真教", "666");
INSERT INTO  teacher1 VALUES(7, "北侠",   "蒙古", "777");
INSERT INTO  teacher1 VALUES(8, "西狂",   "大宋", "888");

CREATE INDEX index_addr ON teacher1(addr);

DROP   TABLE IF EXISTS teacher2;
CREATE TABLE teacher2 (id INT PRIMARY KEY, name VARCHAR(20) unique, addr VARCHAR(20), extra varchar(20));
INSERT INTO  teacher2 VALUES(7,  "北侠",     "蒙古", "777");
INSERT INTO  teacher2 VALUES(10, "金轮法王", "蒙古", "999");
INSERT INTO  teacher2 VALUES(11, "潇湘子",   "蒙古", "123");
INSERT INTO  teacher2 VALUES(12, "尼摩星",   "蒙古", "456");
INSERT INTO  teacher2 VALUES(13, "尹克西",   "蒙古", "789");

CREATE INDEX index_addr ON teacher2(addr);

DROP   TABLE IF EXISTS student;
CREATE TABLE student (id INT PRIMARY KEY, name VARCHAR(20) unique, addr VARCHAR(20), teacher_id int);
INSERT INTO  student VALUES(1, "马钰",   "全真教", 1);
INSERT INTO  student VALUES(2, "丘处机", "全真教", 1);
INSERT INTO  student VALUES(3, "王处一", "全真教", 1);
INSERT INTO  student VALUES(4, "黄蓉",   "桃花岛", 2);
INSERT INTO  student VALUES(5, "欧阳克",   "西域", 3);
INSERT INTO  student VALUES(6, "朱子柳",   "大理", 4);
INSERT INTO  student VALUES(7, "路人甲",   "大宋", 111);

CREATE INDEX index_addr ON student(addr);

# 2. 输出的各个字段的值
# 2.1 table -- 表名, 临时表也会记录
EXPLAIN SELECT * FROM teacher1;                                  # 一张表 
EXPLAIN SELECT * FROM teacher1, teacher2;                        # 两张表
EXPLAIN SELECT * FROM teacher1 UNION     SELECT * FROM teacher2; # 两张表 + 临时表
EXPLAIN SELECT * FROM teacher1 UNION ALL SELECT * FROM teacher2; # 两张表
EXPLAIN SELECT * FROM teacher1 WHERE id = (SELECT teacher_id FROM student WHERE name = '马钰');
                                                                 # 两张表, 子查询

# 2.2 id -- 每个 SELECT 关键字都对应一个唯一的id, 临时表也会有
EXPLAIN SELECT * FROM teacher1;                                  # 一张表 
EXPLAIN SELECT * FROM teacher1, teacher2;                        # 两张表
EXPLAIN SELECT * FROM teacher1 UNION     SELECT * FROM teacher2; # 两张表 + 临时表
EXPLAIN SELECT * FROM teacher1 UNION ALL SELECT * FROM teacher2; # 两张表
EXPLAIN SELECT * FROM teacher1 WHERE id = (SELECT teacher_id FROM student WHERE name = '马钰');
                                                                 # 两张表, 子查询

# 2.3 select_type   查询的类型
# 2.3.1  SIMPLE --------- 不包含 UNION 或者子查询
EXPLAIN SELECT * FROM teacher1;
EXPLAIN SELECT * FROM teacher1, teacher2;

# 2.3.2 PRIMARY -------- UNION 和 UNION ALL 的左边, 子查询的大查询
EXPLAIN SELECT * FROM teacher1 UNION     SELECT * FROM teacher2;
EXPLAIN SELECT * FROM teacher1 UNION ALL SELECT * FROM teacher2;
EXPLAIN SELECT * FROM teacher1 WHERE id = (SELECT teacher_id FROM student WHERE name = '马钰');

# 2.3.4 UNION  --------- UNION 和 UNION ALL 的右边 (不相关)
EXPLAIN SELECT * FROM teacher1 UNION     SELECT * FROM teacher2;
EXPLAIN SELECT * FROM teacher1 UNION ALL SELECT * FROM teacher2;    
      
# 2.3.5 UNION RESULT --- UNION 去重的临时表
EXPLAIN SELECT * FROM teacher1 UNION     SELECT * FROM teacher2;

# 2.3.6 SUBQUERY ------------ 不相关子查询中的小查询
EXPLAIN SELECT * FROM teacher1 WHERE id = (SELECT teacher_id FROM student WHERE name = '马钰');

# 2.3.7 DEPENDENT SUBQUERY ---- 相关子查询中的小查询
EXPLAIN SELECT *, (SELECT name FROM teacher1 WHERE teacher1.id = student.teacher_id)
FROM student;

# 2.3.8 DEPENDENT UNION ------- UNION 和 UNION ALL 的右边 (相关)
EXPLAIN
SELECT * FROM student WHERE teacher_id IN (
    SELECT id FROM teacher1 WHERE teacher1.id = student.teacher_id
    UNION ALL
    SELECT id FROM teacher2 WHERE teacher2.id = student.teacher_id
)

# 2.3.9 DERIVED ---------------- 派生表
EXPLAIN SELECT * FROM (SELECT * FROM teacher1 UNION ALL SELECT * FROM teacher2) t1;

# 2.3.10       MATERIALIZED ----------- 把子查询优化成连接查询
EXPLAIN SELECT * FROM teacher1 WHERE id IN (SELECT teacher_id FROM student);    
      
# 2.3.11 UNCACHEABLE SUBQUERY --- 不常用
# 2.3.12 UNCACHEABLE UNION ------ 不常用

# 2.4 partitions --- 分区表中的命中情况
# 2.5 type -- 针对单表的访问方法
# 2.5.1 system --- 只有一条记录, 精确
# 2.5.2 const ---- 常数与主键或唯一键等值匹配
EXPLAIN SELECT * FROM teacher1 WHERE id = 1;
EXPLAIN SELECT * FROM teacher1 WHERE name = '中神通';

# 2.5.3 eq_ref --- 连接查询 或 子查询时，被驱动表 使用主键或唯一键 常量等值匹配
EXPLAIN SELECT *, (SELECT name FROM teacher1 WHERE id = student.teacher_id) FROM student;

# 2.5.4 ref ------ 常数与普通索引等值匹配
EXPLAIN SELECT * FROM teacher1 WHERE addr = '大元';

# 2.5.5 fulltext ----- 全文索引

# 2.5.6 ref_or_null -- 常数与普通索引等值匹配 或 NULL
EXPLAIN SELECT * FROM teacher1 WHERE addr = '大元' OR addr IS NULL;

# 2.5.7 index_merge -- 单表多字段查询, 查询之间使用 OR, 可能索引合并
EXPLAIN SELECT * FROM teacher1 WHERE name = '北侠' OR  addr = '蒙古';
EXPLAIN SELECT * FROM teacher1 WHERE name = '北侠' AND addr = '蒙古'; # const

# 2.5.8 unique_subquery --- IN 转化成 EXISTS, 并且子查询使用 主键进行等值匹配 --- 没复现
EXPLAIN SELECT * FROM student WHERE id IN (SELECT id FROM teacher1 WHERE teacher1.id = student.teacher_id);

# 2.5.9 index_subquery ---- 与 unique_subquery 类似，只不过子查询中的表时使用的是普通的索引 --- 没复现

# 2.5.10 range --- 范围查找
EXPLAIN SELECT * FROM teacher1 WHERE id IN (1, 2, 3);
EXPLAIN SELECT * FROM teacher1 WHERE id > 1 OR id < 3; # 实测使用 ALL

# 2.5.10 index -- 不懂

# 2.5.11 ALL: 全表扫描
EXPLAIN SELECT * FROM teacher1;


结果值从最好到最坏依次是

system > const > eq_ref > ref** > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL 


至少要达到 range 级别，要求是 ref 级别，最好是 consts级别

# 2.6 possible_keys --- 可能用到的索引
# 2.7 key ------------- 实际上使用的索引
# 2.8 key_len ------------- 实际使用到的索引长度
# 2.9 ref ----------------- 使用的索引列
# 2.10 rows --------------- 预估的需要读取的记录条数
# 2.11 filtered ----------- 某个表经过搜索条件过滤后剩余记录条数的百分比
# 2.12 Extra -------------- 一些额外的信息
# 2.12.1 No tables used --- 没有 FROM 子句
EXPLAIN SELECT 1;

# 2.12.2 Impossible WHERE ---- WHERE 子句永远为 FALSE
EXPLAIN SELECT * FROM teacher1 WHERE 1 = 2;

# 2.12.3 Using where ----- WHERE 使用非索引列
EXPLAIN SELECT * FROM teacher1 WHERE extra = '111';

# 2.12.4 No matching min/max row -- 有 MIN 或者 MAX 聚合函数，但是没有符合 WHERE的搜索条件的记录
EXPLAIN SELECT max(id) FROM teacher1 WHERE id > 1000;

# 2.12.5 Using index ----- WHERE 使用只有索引列 -- TODO
EXPLAIN SELECT * FROM teacher1 WHERE name = '北侠';

  当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在`Extra`列将会提示该额外信息。比方说下边这个查询中只需要用到`idx_key1`而不需要回表操作:


# 2.12.6 Using index condition -- 搜索条件中虽然出现了索引列，但却不能使用到索引

# 2.12.7 Using join buffer (Block Nested Loop)

  在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫`join buffer`的内存块来加快查询速度，也就是我们所讲的`基于块的嵌套循环算法`。

  mysql> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;

# 2.12.8 Not exists

  当我们使用左(外)连接时，如果`WHERE`子句中包含要求被驱动表的某个列等于`NULL`值的搜索条件，而且那个列是不允许存储`NULL`值的，那么在该表的执行计划的Extra列就会提示这个信息：

  mysql> EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;

# 2.12.9 Using intersect(...) 、 Using union(...) 和 Using sort_union(...)

  如果执行计划的`Extra`列出现了`Using intersect(...)`提示，说明准备使用`Intersect`索引合并的方式执行查询，括号中的`...`表示需要进行索引合并的索引名称；

  如果出现`Using union(...)`提示，说明准备使用`Union`索引合并的方式执行查询;

  如果出现`Using sort_union(...)`提示，说明准备使用`Sort-Union`索引合并的方式执行查询。

  mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';

# 2.12.10 Zero limit
  当我们的`LIMIT`子句的参数为`0`时，表示压根儿不打算从表中读取任何记录，将会提示该额外信息

  mysql> EXPLAIN SELECT * FROM s1 LIMIT 0;


# 2.12.11 Using filesort

  有一些情况下对结果集中的记录进行排序是可以使用到索引的。

  mysql> EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;
  mysql> EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;

  需要注意的是，如果查询中需要使用`filesort`的方式进行排序的记录非常多，那么这个过程是很耗费性能的，我们最好想办法`将使用文件排序的执行方式改为索引进行排序`。

# 2.12.12 Using temporary
  mysql> EXPLAIN SELECT DISTINCT common_field FROM s1;

  mysql> EXPLAIN SELECT common_field, COUNT(*) AS amount FROM s1 GROUP BY common_field;

  执行计划中出现`Using temporary`并不是一个好的征兆，因为建立与维护临时表要付出很大的成本的，所以我们`最好能使用索引来替代掉使用临时表`，比方说下边这个包含`GROUP BY`子句的查询就不需要使用临时表：

  mysql> EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;
  ```

  从 `Extra` 的 `Using index` 的提示里我们可以看出，上述查询只需要扫描 `idx_key1` 索引就可以搞 定了，不再需要临时表了。

SHOW WARNINGS


SHOW STATUS LIKE Connections          ：连接MySQL服务器的次数。 
SHOW STATUS LIKE Uptime               ：MySQL服务器的上线时间。 

SHOW STATUS LIKE Innodb_rows_read     ：Select查询返回的行数 
SHOW STATUS LIKE Innodb_rows_inserted ：执行INSERT操作插入的行数 
SHOW STATUS LIKE Innodb_rows_updated  ：执行UPDATE操作更新的 行数 
SHOW STATUS LIKE Innodb_rows_deleted  ：执行DELETE操作删除的行数 

SHOW STATUS LIKE Com_select           ：查询操作的次数。 
SHOW STATUS LIKE Com_insert           ：插入操作的次数。对于批量插入的 INSERT 操作，只累加一次。 
SHOW STATUS LIKE Com_update           ：更新操作 的次数。 
SHOW STATUS LIKE Com_delete           ：删除操作的次数。

SHOW STATUS LIKE 'last_query_cost'; # 统计SQL的查询成本

```
