
## 1. 表锁
```
* 颗粒度大
* 容易锁争用
* 死锁概率低

# 1.1 共享锁(S)和排他锁(X)
DROP TABLE if EXISTS student;
CREATE TABLE student(id INT PRIMARY KEY, name varchar(20));
LOCK TABLES student READ;          # 锁定共享锁
SHOW OPEN TABLES where In_use > 0; # 查看表上的锁
UNLOCK TABLES;                     # 解锁当前加锁的表
SHOW OPEN TABLES where In_use > 0; # 查看表上的锁
LOCK TABLES student WRITE;         # 锁定排他锁
SHOW OPEN TABLES where In_use > 0; # 查看表上的锁
UNLOCK TABLES;                     # 解锁当前加锁的表
SHOW OPEN TABLES where In_use > 0; # 查看表上的锁

# 1.2 意向锁(IX, IS)
* 有事务持有或计划持有该表上的锁
* 由服务器自动维护
* 为了简化锁的判断
* 意向锁之间相互兼容
* 可以和行锁共存

# 1.3 自增锁: AUTO-INC锁
innodb_autoinc_lock_mode = 0
    传统锁定模式
    每条 INSERT 都获取表锁
innodb_autoinc_lock_mode = 1
    连续锁定模式
    每条 INSERT 都获取表锁
    插入条数确定的情况下, 计算自增的值, 提前释放表锁
    8.0 前的默认值
innodb_autoinc_lock_mode = 2
    交错锁定模式
    MySQL 8.0 开始的默认值
    所有数据保证唯一,  单调递增
    给定语句插入的行生成的值可能不是连续的
    插入条数确定的情况下, 计算自增的值, 这种情况一定是连续的
    
# 1.4 元数据锁: MDL锁
* 增删改查加 MDL 读锁
* 表结构变化时, 增加 MDL 写锁 
```

## 2. 页锁
```
颗粒度间于表锁和行锁之间
```
