
## 0. 总结
```
DROP TABLE if EXISTS student;
CREATE TABLE student(id INT PRIMARY KEY, name varchar(20));

* 颗粒度小
* 不容易锁争用
* 可能会死锁
* 增删改会自动添加 排他锁
* 使用索引锁定, 否则会是表锁定

IX -------------- 表级意向独占锁
IS -------------- 表级意向共享锁 
S,REC_NOT_GAP --- 共享型记录锁
X,REC_NOT_GAP --- 独占型记录锁
S,GAP ----------- 共享型间隙锁
X,GAP ----------- 独占型间隙锁
X --------------- 临键锁
INSERT_INTENTION -- 插入意向锁
```

## 1. 记录锁
```
* 针对表中存在的记录
* 区分: 共享锁和排他锁
```
### 1.1 测试 共享型记录锁可以叠加
| 会话A                                                  | 会话B                  | 说明                   |
| ------------------------------------------------------ | ---------------------- | ------------           |
| SET SESSION TRANSACTION_ISOLATION = 'REPEATABLE-READ'; |                        | 设置变量               |
|                        | SET SESSION TRANSACTION_ISOLATION = 'REPEATABLE-READ'; | 设置变量               |
| TRUNCATE student;                                      |                        | 清空表                 |
| INSERT INTO student VALUES(10, '张三');                |                        | 插入数据               |
| INSERT INTO student VALUES(20, '李四');                |                        | 插入数据               |
| INSERT INTO student VALUES(30, '王五');                |                        | 插入数据               |
| SELECT * FROM student;                                 |                        | 张三, 李四, 王五       |
| START TRANSACTION;                                     |                        | 开启事务               |
| SELECT * FROM performance_schema.data_locks\G          |                        | 无锁                   |
| SELECT * FROM student WHERE id = 10 FOR SHARE;         |                 | 添加 共享记录锁和表意向共享锁 |
| SELECT * FROM performance_schema.data_locks\G          |                      | 共享记录锁和表意向共享锁 |
|                                                        | START TRANSACTION;     | 开启事务               |
|       | SELECT * FROM student WHERE id = 10 FOR SHARE;                   | 添加 共享记录锁和表意向共享锁 |
| SELECT * FROM performance_schema.data_locks\G          |                      | 共享记录锁和表意向共享锁 |
| COMMIT;                                                |                        | 提交事务               |
|                                                        | COMMIT;                | 提交事务               |



# 3.1.1 证明记录锁是写优先的
* 事务A 获取该行的读锁 
* 事务B 尝试获取该行的写锁, 等待
* 事务C 尝试获取该行的读锁, 等待
* 事务A 提交, 导致, 事务B 获取锁成功
* 事务B 提交, 导致, 事务C 获取锁成功


START TRANSACTION;                                     #  9. 其他会话: 开启事务
SELECT * FROM student WHERE id = 10 FOR SHARE;         # 10. 当前事务: 共享锁 --- 证明共享型记录锁可以叠加
SELECT * FROM performance_schema.data_locks;           # 11. 锁状态: IS -- S,REC_NOT_GAP
COMMIT;                                                # 12. 其他会话: 提交
SELECT * FROM performance_schema.data_locks;           # 13. 锁状态: IS -- S,REC_NOT_GAP
START TRANSACTION;                                     # 14. 会话A: 开启事务
SELECT * FROM student WHERE id = 10 FOR UPDATE;        # 15. 会话A: 排他锁 (阻塞)
SELECT * FROM performance_schema.data_locks;           # 16. 锁状态: IS - S,REC_NOT_GAP - IX - X,REC_NOT_GAP
START TRANSACTION;                                     # 17. 会话B: 开启事务
SELECT * FROM student WHERE id = 10 FOR SHARE;         # 18. 会话B: 共享锁 (阻塞) -- 证明共享锁是写优先的
SELECT * FROM performance_schema.data_locks;           # 19. 锁状态: IS - S,REC_NOT_GAP - IX - X,REC_NOT_GAP
COMMIT;                                                # 20. 当前事务: 提交, 释放共享锁
SELECT * FROM performance_schema.data_locks;           # 21. 锁状态: IS - S,REC_NOT_GAP - IX - X,REC_NOT_GAP
                                                       # 22. 此时, 会话A 获取排他锁成功
COMMIT;                                                # 23. 会话A: 提交, 释放排他锁
SELECT * FROM performance_schema.data_locks;           # 24. 锁状态: IS - S,REC_NOT_GAP
                                                       # 25. 此时, 会话B 获取共享锁成功
COMMIT;                                                # 26. 会话B: 提交, 释放共享锁
SELECT * FROM performance_schema.data_locks;           # 27. 锁状态: 空

# 3.1.2 测试同一事务, 开启共享锁的情况下修改数据 -- 可以, 只要其他事务不持有相关锁就可以
TRUNCATE student;                                      #  1. 清空表
INSERT INTO student VALUES(10, '张一');                #  2. 初始化数据
INSERT INTO student VALUES(20, '张二');                #
INSERT INTO student VALUES(30, '张三');                #
SELECT * FROM student;                                 #  3. 查看数据
SET SESSION TRANSACTION_ISOLATION = 'REPEATABLE-READ'; #  4. 所有会话: 设置隔离级别
START TRANSACTION;                                     #  5. 开启事务
SELECT * FROM performance_schema.data_locks;           #  6. 锁状态: 空
SELECT * FROM student WHERE id = 10 FOR SHARE;         #  7. 当前事务: 共享锁
SELECT * FROM performance_schema.data_locks;           #  8. 锁状态: IS - S,REC_NOT_GAP
UPDATE student SET name = '123' WHERE id = 10;
SELECT * FROM performance_schema.data_locks;           #  9. 锁状态: IS - S,REC_NOT_GAP - IX - X,REC_NOT_GAP
COMMIT; 

# 3.1.3 测试 锁等待时直接报错
TRUNCATE student;                                      #  1. 清空表
INSERT INTO student VALUES(10, '张一');                #  2. 初始化数据
INSERT INTO student VALUES(20, '张二');                #
INSERT INTO student VALUES(30, '张三');                #
SELECT * FROM student;                                 #  3. 查看数据
SET SESSION TRANSACTION_ISOLATION = 'REPEATABLE-READ'; #  4. 所有会话: 设置隔离级别
START TRANSACTION;                                     #  5. 开启事务
SELECT * FROM performance_schema.data_locks;           #  6. 锁状态: 空
SELECT * FROM student WHERE id = 10 FOR SHARE;         #  7. 当前事务: 共享锁
START TRANSACTION;                                     #  8. 会话A: 开启事务
SELECT * FROM student WHERE id = 10 FOR UPDATE NOWAIT; #  9. 会话A: 排他锁 --- 报错
COMMIT                                                 # 10. 会话A: 提交
COMMIT                                                 # 11. 当前事务: 提交

# 3.2 间隙锁:
* 不区分 共享锁 还是 排他锁
* 针对表中不存在的记录
* 所有的间隙锁都能共存 (可能造成死锁)
* 该范围内不能插入数据
* 处理幻读的问题 (其他事务插入数据的问题) --- TODO

# 3.2.1 简单测试
TRUNCATE student;                                      #  1. 清空表
INSERT INTO student VALUES(10, '张一');                #  2. 初始化数据
INSERT INTO student VALUES(20, '张二');                #
INSERT INTO student VALUES(30, '张三');                #
SELECT * FROM student;                                 #  3. 查看数据
SET SESSION TRANSACTION_ISOLATION = 'REPEATABLE-READ'; #  4. 所有会话: 设置隔离级别
START TRANSACTION;                                     #  5. 开启事务
SELECT * FROM performance_schema.data_locks;           #  6. 锁状态: 空
SELECT * FROM student WHERE id = 11 FOR SHARE;         #  7. 当前事务: 间隙锁
SELECT * FROM performance_schema.data_locks;           #  8. 锁状态: IS - S,GAP
INSERT INTO student VALUES(11, '789');                 
SELECT * FROM performance_schema.data_locks;           #  9. 锁状态: IS - S,GAP - IX
COMMIT;

# 3.2.2 测试死锁
TRUNCATE student;                                      #  1. 清空表
INSERT INTO student VALUES(10, '张一');                #  2. 初始化数据
INSERT INTO student VALUES(20, '张二');                #
INSERT INTO student VALUES(30, '张三');                #
SELECT * FROM student;                                 #  3. 查看数据
SET SESSION TRANSACTION_ISOLATION = 'REPEATABLE-READ'; #  4. 所有会话: 设置隔离级别
START TRANSACTION;                                     #  5. 开启事务
SELECT * FROM performance_schema.data_locks;           #  6. 锁状态: 空
SELECT * FROM student WHERE id = 11 FOR UPDATE;        #  7. 当前事务: 间隙锁
SELECT * FROM performance_schema.data_locks;           #  8. 锁状态: IX -- X,GAP
START TRANSACTION;                                     #  9. 其他会话: 开启事务
SELECT * FROM student WHERE id = 11 FOR UPDATE;        # 10. 其他会话: 间隙锁
SELECT * FROM performance_schema.data_locks;           # 11. 锁状态: IX -- X,GAP
INSERT INTO student VALUES(11, '789');                 # 12. 其他会话: 等待
SELECT * FROM performance_schema.data_locks;           # 13. 锁状态: IX -- X,GAP -- INSERT_INTENTION
INSERT INTO student VALUES(11, '789');                 # 14. 当前事务: --- 退出, 会自动解锁
SELECT * FROM performance_schema.data_locks;           # 15. 锁状态: IX -- X,GAP -- INSERT_INTENTION
COMMIT;                                                # 16. 其他会话
COMMIT;                                                # 17. 当前事务

# 3.3 临键锁: 同时使用记录锁和间隙锁
TRUNCATE student;                                      #  1. 清空表
INSERT INTO student VALUES(10, '张一');                #  2. 初始化数据
INSERT INTO student VALUES(20, '张二');                #
INSERT INTO student VALUES(30, '张三');                #
SELECT * FROM student;                                 #  3. 查看数据
SET SESSION TRANSACTION_ISOLATION = 'REPEATABLE-READ'; #  4. 所有会话: 设置隔离级别
START TRANSACTION;                                     #  5. 开启事务
SELECT * FROM performance_schema.data_locks;           #  6. 锁状态: 空
SELECT * FROM student WHERE id >= 10 FOR UPDATE;       #  7. 当前事务: 临键锁
SELECT * FROM performance_schema.data_locks;           #  8. 锁状态: IX -- X,REC_NOT_GAP -- X
COMMIT;

# 3.4 插入意向锁
* 插入意向锁之前不排斥, 只要(主键, 唯一键不冲突即可)

TRUNCATE student;                                      #  1. 清空表
INSERT INTO student VALUES(10, '张一');                #  2. 初始化数据
INSERT INTO student VALUES(20, '张二');                #
INSERT INTO student VALUES(30, '张三');                #
SELECT * FROM student;                                 #  3. 查看数据
SET SESSION TRANSACTION_ISOLATION = 'REPEATABLE-READ'; #  4. 所有会话: 设置隔离级别
START TRANSACTION;                                     #  5. 开启事务
SELECT * FROM performance_schema.data_locks;           #  6. 锁状态: 空
SELECT * FROM student WHERE id = 15 FOR UPDATE;        #  7. 当前事务: 间隙锁
SELECT * FROM performance_schema.data_locks;           #  8. 锁状态:  IX -- X,GAP
INSERT INTO student VALUES(11, '张一');                #  9. 会话A: 插入意向锁
INSERT INTO student VALUES(12, '张一');                # 10. 会话B: 插入意向锁
SELECT * FROM performance_schema.data_locks;           # 11. 锁状态: IX -- X,GAP -- INSERT_INTENTION
COMMIT;                                                #                                                    
```

## 4. 悲观锁
```
* 适用于修改大于查询的情况
* 认为其他事务很有可能修改数据, 为保险, 一定加锁
* 不能获取过时的数据
* 比如, 银行的自动取款机判断可取金额
```

## 5. 乐观锁
```
* 适用于查询大于修改的情况
* 偶尔获取过时的数据也没关系
* 大多数情况都适合
```
