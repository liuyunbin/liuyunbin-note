
## 线程
* ps -o lwp,nlwp # 线程ID, 线程数
* ps -L          # 列每一个线程

## 进程
* 新建的进程将继承父进程的进程组, 会话
* 进程ID无法变化
* 进程退出时, 将向父进程发送信号, 父进程处理此信号前, 该进程变为僵尸进程
    * 如果此进程是该进程组的最后一个进程, 此进程退出后, 该进程组消失
* 一个进程只能有一个父进程
* 一个父进程可以有多个子进程
* 孤儿进程:
    * 父进程已经退出的进程, 孤儿进程的父进程ID会自动改变
* 孤儿进程组:
* 僵尸进程:
    * 子进程已退出, 父进程还未处理
    * 如果父进程退出的话, 初始化进程会自动处理
    * 杀死僵尸进程只能杀死僵尸进程的父进程
* 一个进程只能属于一个进程组
* 一个进程只能属于一个会话
* 存在原因: 为了唯一确认一个进程
* 其他属性:
    * 实际用户和组
    * 有效用户和组
    * 保存用户和组
    * 文件用户和组, 一般和有效的相同
    * 附属组
    * 进程状态: 运行, 休眠, 僵尸进程等
    * 优先级
    * 进程名称和启动命令

## 进程组
* 只能修改自身或者子进程(调用exec之前)的进程的进程组ID
* 进程和进程组必须属于同一个会话
* 只要该进程组还存在进程, 该进程组就不会消失
* 一个进程组包含一个或多个进程
* 一个进程组只能属于一个会话
* 存在原因: 为了便于处理一批进程, 比如发送信号

## 会话
* 新建会话
    * 当前进程不能是进程组进程, 为可以避免影响到原进程组的其他进程
    * 新的会话ID是当前进程的ID, 新的进程组ID也是当前进程的ID
    * 新会话和新进程组里将只包含当前进程
    * 新的会话将脱离终端的控制
* 会话退出时, 默认不会对会话内的其他进程有影响??
* 一个会话包括一个或多个进程
* 一个会话包括一个或多个进程组
* 一个会话最多和一个终端绑定
* 存在原因: 为了终端的作业控制

## 终端
* 用户登录时, 系统将一个会话与终端绑定, 此会话进程即为控制进程
* 终端退出时, 将发送 SIGHUP 给控制进程, 控制进程将向此会话中的所有进程组发送信号 SIGHUP
    * SIGHUP 表示控制终端断开(正常或异常), 默认行为是结束进程
* 此会话有且只有一个前台进程组, 有零个或多个后台进程组
* 终端的输入将发送到前台进程组, 前台和后台进程组的输出都将发送到终端
* 新建会话可以脱离终端
* 脱离终端的进程的父进程不一定是 1, 也可能是其他脱离终端的进程
* 脱离终端可以忽略 SIGHUP 或 新建会话

## 信号处理
* sleep() 暂停n秒, 或者一个未被忽略的信号到达
* signal
    第一次处理后, 信号处理函数可能被重置, Linux 不会重置
    可能中断系统调用, Linux 会自动重启
    信号不排队, 相同的信号出现多次时, 只当作一次处理
    信号处理时:
        相同的信号来了会被阻塞, 此时, 如果再来相同的信号将被抛弃
        不同的信号来了会被直接执行, 执行完之后, 在继续执行之前的信号
* sigaction
    * sa_mask 可以指明被阻塞的信号
    * sa_flags-->SA_NOCLDSTOP 对于 SIGCHLD, 不接收子进程暂停或继续的信号
    * sa_flags-->SA_NOCLDWAIT 对于 SIGCHLD, 不让子进程变为僵尸进程
    * sa_flags-->SA_NODEFER   信号处理时, 不阻止自己的信号
    * sa_flags-->SA_ONSTACK   使用信号栈处理,
    * sa_flags-->SA_RESETHAND 第一次调用后, 重置信号处理函数为默认值
    * sa_flags-->SA_RESTART   自动重启被中断的系统调用
    * sa_flags-->SA_SIGINFO   指明信号处理函数
    相比 signal 改进的地方
        * 可以选择是否自动重启被中断的系统调用
        * 可以选择第一次调用以后, 信号处理函数是否恢复成默认值
        * 可以选择信号处理过程中, 是否阻塞自身, 或这阻塞指定信号集
        * 可以指明对子进程状态变化的处理
        * 可以获取到发送信号一端的一些信息
    还存在的问题
        * 信号不排队, 会丢失信号
* SIGKILL 和 SIGSTOP 不能被捕获或忽略
* 多个信号待处理时, 优先级
    * SIGILL(4),SIGTRAP(5),SIGBUS(7),SIGFPE(8),SIGSEGV(11),SIGSYS(31) 优先处理, 从左到右
    * 其他情况按数字的大小顺序处理
* 相同信号多次发送时, 不会排队, 可能会丢失信号
* fork() 会继承信号处理函数, 未处理的信号被忽略(执行 exec 之前)
* 多线程和信号处理会很麻烦




ps -U RUID -G RGID           # 实际的用户和组
ps -u EUID -g EGID           # 有效的用户和组
ps -p PID                    # 进程ID
ps -s SID                    # 会话ID
ps --ppid PPID               # 父进程ID
ps -t ...                    # 终端
ps -C vim                    # 进程名称, 全名称 或 前 15 位

ps -o ruid,ruser,rgid,rgroup # 实际的用户和组
ps -o euid,euser,egid,egroup # 有效的用户和组
ps -o suid,suser,sgid,sgroup # 保存的用户和组
ps -o fuid,fuser,fgid,fgroup # 文件的用户和组, 一般和有效的相同
ps -o supgid,supgrp          # 附属组ID
ps -o pid,ppid,pgid,sid      # 进程ID, 父进程ID, 进程组ID, 会话ID
ps -o ouid                   # 会话ID所属用户ID
ps -o tty                    # 终端
ps -o tpgid                  # 输出前台进程的ID
ps -o luid,lsession          # 终端登录的用户ID和会话ID
ps -o stat,state             # 进程状态
                             # R 正在运行
                             # S 正在休眠
                             # T 后台暂停的作业
                             # t debug 调试中
                             # Z 僵尸进程
ps -o pmem,rsz,vsz           # 内存百分比,内存,内存(含交换分区)
ps -o pcpu,c,bsdtime,cputime # cpu: 百分比,百分比整数,user+system,system
ps -o lstart,etime,etimes    # 启动时间,运行时间,运行时间(秒)
ps -o nice,pri,psr,rtprio    # 优先级
ps -o wchan                  # 进程休眠, 返回当前使用的内核函数
                             # 进程运行, 返回 -
                             # 列出线程, 返回 *
ps -o cmd                    # 启动命令
ps -o comm                   # 进程名称
ps -o fname                  # 进程名称的前 8 位

ps -e           # 所有进程
ps -H           # 输出进程树
ps -ww          # 不限制输出宽度
ps --no-headers # 不输出列头部
ps --headers    #   输出列头部
ps --sort -pcpu # cpu 使用率逆序

* pgrep # 使用进程名称查找
        # 可以前缀匹配, 精确匹配, 使用启动命令匹配, 默认使用进程名称(15)匹配, 一般默认足够
        # 使用扩展的正则表达式
        # 可以指定 实际用户, 有效用户, 实际组ID, 进程组ID, 会话ID, 父进程ID, 终端
        # 可以反转匹配结果
        # 可以列出线程ID
        # 可以列出匹配到的最老或最新的进程
        # 可以列出进程ID, 进程名称(15位), 启动命令
        # 可以列出匹配到的数目
        # 可以指定输出的分隔符
* pkill # 杀死进程, 参数和 pgrep 类似
* pwdx  # 列出进程的当前工作目录
* pidof # 列出进程名称对应的 PID, 精确匹配, 没有长度限制
* kill        # 通过进程ID发送信号给进程或进程组
* killall     # 通过进程名称发送信号给进程或进程组, 进程名称精确匹配
* kill    -l  # 列出所有信号
* killall -l  # 列出所有信号
* kill    %1  # bash 内置的 kill, 杀死作业
* killall -o 2m a.out # 发给 2 分钟前启动的 a.out
* killall -y 2m a.out # 发给 2 分钟内启动的 a.out
* killall -w    a.out # 等待进程结束

* free -h    # 内存使用情况
* df   -Th   # 查看磁盘挂载情况

uname -a # 全部信息
uname -m # x86_64 等
uname -r # 内核版本

top
top -n 1 # 刷新次数
top -b # 方便写入文件
top        # 使用 CPU 排序 -- TODO
top -u lyb # M 内存排序
           # P CPU 排序
           # T 时间排序
           # m 显示内存信息
           # t 显示进程 或 CPU状态信息
           # c 显示命令名称 或 完整命令行

pstree     [PID] # 以进程 PID 为根画进程树, 默认为 1
pstree  -c [PID] # 展示所有子树
pstree  -p [PID] # 展示进程ID
pstree  -g [PID] # 展示进程组ID
pstree  -n [PID] # 使用 PID 排序而不是 进程名称
pstree  -l [PID] # 使用长行, 方便写入文件

nohup  # 忽略信号 SIGHUP
setsid # 以新的 session 执行命令

## 常用信号
 1) SIGHUP    # 退出进程, 控制终端断开
 2) SIGINT    # 退出进程, 键盘中断(ctrl+c)
 3) SIGQUIT   # 退出进程, 产生core, 键盘退出(ctrl+\)
 4) SIGILL    # 退出进程, 产生core, 非法指令, 一般是可执行文件发生错误
 5) SIGTRAP   # 退出进程, 产生core, 断点, debug 产生
 6) SIGABRT   # 退出进程, 产生core, 由 abort() 产生
 7) SIGBUS    # 退出进程, 产生core, 指针非法地址, 比如, 不符合对齐要求
 8) SIGFPE    # 退出进程, 产生core, 浮点数异常
 9) SIGKILL   # 退出进程, 不能被捕获和忽略
10) SIGUSR1   # 退出进程, 用户自定义信号
11) SIGSEGV   # 退出进程, 产生core, 指针地址合法, 但无权限访问, 比如其他进程的地址
12) SIGUSR2   # 退出进程, 用户自定义信号
13) SIGPIPE   # 退出进程, 对端退出时, 写管道
14) SIGALRM   # 退出进程, 由 alarm() 产生的超时
15) SIGTERM   # 退出进程, 可以被捕获和忽略, kill 默认信号
16) SIGSTKFLT # 退出进程, 栈错误, 未使用
17) SIGCHLD   # 忽略信号, 子进程状态变化时, 向父进程发送
18) SIGCONT   # 继续进程
19) SIGSTOP   # 暂停进程, 不能被捕获和忽略
20) SIGTSTP   # 暂停进程, 可以被捕获和忽略
21) SIGTTIN   # 暂停进程, 后台进程读取终端输入
22) SIGTTOU   # 暂停进程, 后台进程输出到终端
23) SIGURG    # 忽略信号, 带外数据
24) SIGXCPU   # 退出进程, 产生core, cpu 使用超出限制
25) SIGXFSZ   # 退出进程, 产生core, 文件大小超出限制
26) SIGVTALRM # 退出进程, 虚拟的超时信号
27) SIGPROF   # 退出进程, setitimer 到期
28) SIGWINCH  # 忽略信号, 终端大小发生变化
29) SIGIO     # 退出进程, 异步IO就绪
30) SIGPWR    # 退出进程, 电池问题
31) SIGSYS    # 退出进程, 产生core, 非法的系统调用

## proc 文件
/proc/loadavg     # 系统负载
/proc/cpuinfo     # cpu 信息
/proc/uptime      # 运行时间
/proc/sys

/proc/PID/cmdline # 完整的启动命令
/proc/PID/comm    # 进程名称, 不包含路径名称, 最多 15 位
                  # 如果以符号链接启动, 将存储符号链接
/proc/PID/cwd     # 进程当前的目录
/proc/PID/exe     # 符号链接, 指向运行的进程
/proc/PID/environ # 进程使用的环境变量
/proc/PID/fd      # 进程所打开的文件描述符
/proc/PID/limits  # 进程对各种资源的限制
/proc/PID/task    # 进程使用的线程情况

