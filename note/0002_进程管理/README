
## 线程
* ps -o lwp,nlwp # 线程ID, 线程数
* ps -L          # 列每一个线程

## 进程
* 新建进程的将继承父进程的进程组, 会话
* 进程ID无法变化
* 一个进程只能有一个父进程
* 父进程:
    * 一个父进程可以有多个子进程
    * ps --ppid PPID
    * ps -o ppid
* 孤儿进程:
    * 父进程已经退出的进程, 孤儿进程的父进程ID, 进程组ID, 会话ID 会自动改变
* 僵尸进程:
    * 子进程已退出, 父进程还未处理
    * 如果父进程退出的话, 初始化进程会自动处理
    * 杀死僵尸进程只能杀死僵尸进程的父进程
* 一个进程只能属于一个进程组
* 一个进程只能属于一个会话
* 存在原因: 为了唯一确认一个进程
* ps -p PID
* ps -o pid
* ps -U RUID -G RGID           # 实际的用户和组
* ps -o ruid,ruser,rgid,rgroup
* ps -u EUID -g EGID           # 有效的用户和组
* ps -o euid,euser,egid,egroup
* ps -o suid,suser,sgid,sgroup # 保存的用户和组
* ps -o fuid,fuser,fgid,fgroup # 文件的用户和组, 一般和有效的相同
* ps -o supgid,supgrp          # 附属组ID
* ps -o stat,state             # 进程状态
                               # R 正在运行
                               # S 正在休眠
                               # T 后台暂停的作业
                               # t debug 调试中
                               # Z 僵尸进程
* ps -o pmem,rsz,vsz           # 内存百分比,内存,内存(含交换分区)
* ps -o pcpu,c,bsdtime,cputime # cpu: 百分比,百分比整数,user+system,system
* ps -o lstart,etime,etimes    # 启动时间,运行时间,运行时间(秒)
* ps -o nice,pri,psr,rtprio    # 优先级
* ps -o wchan                  # 进程休眠, 返回当前使用的内核函数
                               # 进程运行, 返回 -
                               # 列出线程, 返回 *
* ps -C vim                    # 进程名称, 全名称 或 前 15 位
* ps -o cmd                    # 启动命令
* ps -o comm                   # 进程名称
* ps -o fname                  # 进程名称的前 8 位
* pgrep # 使用进程名称查找
        # 可以前缀匹配, 精确匹配, 使用启动命令匹配, 默认使用进程名称(15)匹配, 一般默认足够
        # 使用扩展的正则表达式
        # 可以指定 实际用户, 有效用户, 实际组ID, 进程组ID, 会话ID, 父进程ID, 终端
        # 可以反转匹配结果
        # 可以列出线程ID
        # 可以列出匹配到的最老或最新的进程
        # 可以列出进程ID, 进程名称(15位), 启动命令
        # 可以列出匹配到的数目
        # 可以指定输出的分隔符
* pkill # 杀死进程, 参数和 pgrep 类似
* pwdx  # 列出进程的当前工作目录
* pidof # 列出进程名称对应的 PID, 精确匹配, 没有长度限制
* kill        # 通过进程ID发送信号给进程或进程组
* killall     # 通过进程名称发送信号给进程或进程组, 进程名称精确匹配
* kill    -l  # 列出所有信号
* killall -l  # 列出所有信号
* kill    %1  # bash 内置的 kill, 杀死作业
* killall -o 2m a.out # 发给 2 分钟前启动的 a.out
* killall -y 2m a.out # 发给 2 分钟内启动的 a.out
* killall -w    a.out # 等待进程结束

## 进程组
* 只能修改自身或者子进程(调用exec之前)的进程的进程组ID
* 进程和进程组必须属于同一个会话
* 一个进程组包含一个或多个进程
* 一个进程组只能属于一个会话
* 存在原因: 为了便于处理一批进程, 比如发送信号
* ps -o pgid

## 会话
* 新建会话
    * 当前进程不能是进程组进程, 为可以避免影响到原进程组的其他进程
    * 新的会话ID是当前进程的ID, 新的进程组ID也是当前进程的ID
    * 新会话和新进程组里将只包含当前进程
    * 新的会话将脱离终端的控制
* 一个会话包括一个或多个进程
* 一个会话包括一个或多个进程组
* 一个会话最多和一个终端绑定
* 存在原因: 为了终端的作业控制
* ps -s SID
* ps -o sid
* ps -o ouid # 会话ID所属用户ID

## 终端
* 用户登录时, 系统将一个会话与终端绑定, 此会话进程即为控制进程
* 终端退出时, 将向此会话中的所有进程发送信号
* 此会话有且只有一个前台进程组, 有零个或多个后台进程组
* 终端的输入将发送到前台进程组, 前台和后台进程组的输出都将发送到终端
* 新建会话可以脱离终端
* 脱离终端的进程的父进程不一定是 1, 也可能是其他脱离终端的进程
* ps -t ...
* ps -o tty
* ps -o tpgid    # 输出前台进程的ID
* ps -o luid     # 终端登录的用户ID
* ps -o lsession # 终端登录的会话ID

## 杂项
* free -h    # 内存使用情况
* df   -Th   # 查看磁盘挂载情况

uname -a # 全部信息
uname -m # x86_64 等
uname -r # 内核版本

ps -e           # 所有进程
ps -H           # 输出进程树
ps -ww          # 不限制输出宽度
ps --no-headers # 不输出列头部
ps --headers    #   输出列头部
ps --sort -pcpu # cpu 使用率逆序

top
top -n 1 # 刷新次数
top -b # 方便写入文件
top        # 使用 CPU 排序 -- TODO
top -u lyb # M 内存排序
           # P CPU 排序
           # T 时间排序
           # m 显示内存信息
           # t 显示进程 或 CPU状态信息
           # c 显示命令名称 或 完整命令行

pstree     [PID] # 以进程 PID 为根画进程树, 默认为 1
pstree  -c [PID] # 展示所有子树
pstree  -p [PID] # 展示进程ID
pstree  -g [PID] # 展示进程组ID
pstree  -n [PID] # 使用 PID 排序而不是 进程名称
pstree  -l [PID] # 使用长行, 方便写入文件

## proc 文件
/proc/loadavg    # 系统负载
/proc/cpuinfo     # cpu 信息
/proc/uptime      # 运行时间
/proc/sys

/proc/PID/cmdline # 完整的启动命令
/proc/PID/comm    # 进程名称, 不包含路径名称, 最多 15 位
                  # 如果以符号链接启动, 将存储符号链接
/proc/PID/cwd     # 进程当前的目录
/proc/PID/exe     # 符号链接, 指向运行的进程
/proc/PID/environ # 进程使用的环境变量
/proc/PID/fd      # 进程所打开的文件描述符
/proc/PID/limits  # 进程对各种资源的限制
/proc/PID/task    # 进程使用的线程情况

