
IFS 默认值: " \t\n"
IFS 包含转义字符时, 需要在开头添加 $, IFS=$'\n'

ntpdate -s time-b.nist.gov # 使用时间服务器更新时间

nohup sleep 1000 & # 脱离终端, 在后台运行
read name     # 读取, 如果参数值小于字段数, 多余的值放入最后一个字段
redis flushdb

rz          #  windows 向 虚拟机  发送数据

od -Ax  -tx1z 1.c # 每组一个字节, 显示十六进制
od      -c    1.c # 每组一个字节, 显示字符

set -o nounset  # 使用未初始化的变量报错, 同 -u
set -o errexit  # 只要发生错误就退出, 同 -e
set -o pipefail # 只要管道发生错误就退出
set -o errtrace # 函数报错时, 也处理 trap ERR, 同 set -E
set -o  xtrace  # 执行前打印命令, 同 -x
set -o verbose  # 读取前打印命令, 同 -v
set -o vi       # 使用 vi 快捷键
set -- ....     # 重新排列参数

sleep 30   # 前台运行
sleep 30 & # 后台运行

trap ... ERR  # 发生错误退出时, 执行指定命令
trap ... EXIT # 任意情况退出时, 执行指定命令

cat lyb | xargs -i vim {} # 以此编辑 lyb 中的每一个文件

xxd -g1 1.c # 每组一个字节, 显示十六进制
xxd -b  1.c # 每组一个字节, 显示  二进制

c++filt  a.out   # 可以解析动态库里的符号

--------------------------------------
## 时间戳 字符串形式 等待

## 学习一个命令需要注意的点
* 不需要了解命令的所有选项, 目的是为了使用, 有一些命令一辈子也用不到, 切记切记
* 支持 通配符, 还是基础的正则表达式 还是 扩展的正则表达式
* 各个选项之间是 且 还是 或
* 如何处理符号连接

#### 获取命令源码
yum install yum-utils
rpm -qf /usr/sbin/pidof        # 查看 命令所属的包
yumdownloader --source ...     # 下载源码包
rpm2cpio ...src.rpm | cpio -id # 转换
tar xvf ...                    # 解压

----------------------------------------
文件名称建议: 大小写字母 数字 下划线 短横线 点

errno 是线程安全的, 如何检验

#### 查看 Linux 临时端口号的范围
```
cat /proc/sys/net/ipv4/ip_local_port_range
32768   60999
``

* [0, 1024) 公认端口号, 需要 root 启动, 比如 80
* [1024, 32768) 注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
* [60990, 65535)

# 查询 域名 对应 的 IP
* nslookup baidu.com

\command # 忽略别名

bc <<< "scale=2; 10/2" # 设置使用两位小数, 输出: 5.00
bc <<< "ibase=2;  100" # 输入使用二进制, 输出: 4
bc <<< "obase=2;   10" # 输出使用二进制, 输出: 1010


date "+%Y-%m-%d %H:%M:%S"   # 输出: 年-月-日 时-分-秒
date "+%Y-%m-%d %H:%M"      # 输出: 年-月-日 时-分
date "+%s"                  # 输出: 时间戳
date -d "20200202 01:01:01" # 使用: 指定输入日期
date -d "@...."             # 使用: 时间戳
date -r 1.c                 # 使用: 文件的 mtime
date -s "20200202 10:10:10" # 更新系统时间, 需要 root


exec ls      # 替换当前 shell, 执行后不再执行之后的命令
exec &>1.txt # 打开文件描述符, 然后继续执行之后的命令
env          # 设置环境变量, 然后执行程序

flock    1.c ls # 设置文件互斥锁 执行命令, 设置锁失败, 等待
flock -n 1.c ls # 设置文件互斥锁 执行命令, 设置锁失败, 退出

脚本内使用, 保证脚本最多执行一次
[[ "$FLOCKER" != "$0" ]] && exec env FLOCKER="$0" flock -en "$0" "$0" "$@" || :

解释:
1. 第一次进入脚本, 由于变量未设置, 会执行 exec
2. 调用 exec, 使用 env 设置 变量名
3. 执行 flock, 重新执行这个脚本, 执行完脚本后会退出, 不会执行之后的命令
    * 使用脚本名作为 文件锁, 脚本名使用绝对路径, 所以不会重复
4. 第二次进入脚本, 由于变量已设置, 直接往下执行就可以了
5. 在此期间, 如果, 有其他脚本进入, 文件锁获取失败, 就直接退出了

getconf NAME_MAX /
getconf PATH_MAX /

getopt  # a  无参数, a: 有参数
        # -- 表示可选参数的终止
        # 会重新排列参数
        # 可以解析 --bug
        # 可以区分无参数, 有参数, 可选参数的情况
        # -kval 可以当作 -k val 处理
        # 参数带空格可能出问题

getopts # -o 短选项, -l 长选项
        # a 无参数, a: 有参数, a:: 参数可选
        #  -- 表示可选参数的终止
        # 不会重排参数
        # 只能解析 -k, -k val, 不能解析 --bug, -kval
        # 只能区分有参数和无参数的情况
        # 参数带空格也能处理

hd            1.c # 每组一个字节, 显示十六进制
hexdump -C    1.c # 每组一个字节, 显示十六进制
hexdump -c    1.c # 每组一个字节, 显示字符

history

iconv

ip addr
ip route

