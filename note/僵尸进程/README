
## 僵尸进程
* 产生的原因: 子进程已退出, 父进程未处理
* 产生的场景
    * 子进程已退出, 父进程处理之前
    * 子进程已退出, 父进程未处理
        1. fork() 产生子进程
        2. 父进程空循环
        3. 子进程退出, 此时子进程处于僵尸状态
    * 子进程已退出, 父进程已处理, 但处理方式不对, 由于 SIGCHLD 信号可能丢失, 导致产生僵尸进程
        1. 父进程捕捉 SIGCHLD, 信号处理函数调用一次 waitpid()
        2. 产生 10 子进程, 每个子进程都退出
        3. 此时, 由于有的 SIGCHLD 信号丢失, 所以有的子进程处于僵尸状态
* 存在的意义: 父进程可以获取子进程退出的状态信息
* 预防
    1. 父进程捕获 SIGCHLD, 在信号处理函数里循环调用 waitpid(...WNOHANG)
    2. 父进程使用 SIG_IGN 忽略 SIGCHLD 信号
    3. 父进程使用 sigaction(...SA_NOCLDWAIT)
    4. 父进程退出, 直接将对子进程的处理行为交给 system
* 杀死
    1. 只能杀死僵尸进程的父进程
    2. 此后, 僵尸进程的父进程将变为 systemd
    3. 此后, systemd 将处理 SIGCHLD 信号
    4. 然后, 僵尸进程消失

