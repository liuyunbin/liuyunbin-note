
# 僵尸进程

## 产生的原因
* 子进程退出时, 会向父进程发送 SIGCHLD, 同时内核会保留子进程退出的状态信息
* 但父进程未正确处理此信号, 导致内核一直保留子进程退出的状态信息

## 存在的意义
* 父进程可以获取子进程退出的状态信息

## 存在的危害
* 没有过大的副作用, 但大量僵尸进程会造成系统资源的浪费

## 查看僵尸进程
* 使用 top 查看是否存在僵尸进程
* 获取僵尸进程的进程号:

    ps --no-header -fe -o state,pid | awk '$1 == "Z" {print $2}'

## 模拟僵尸进程的产生
### 场景一: 父进程未处理子进程退出的状态信息
1. 父进程产生子进程
2. 子进程空循环
3. 此时, 可以看到子进程处于运行状态
4. 杀死子进程
5. 此时, 可以看到子进程处于僵尸状态

源文件: [01.cc](./01.cc)

### 场景二: 父进程未正确处理子进程退出的状态信息
1. 父进程设置捕捉 SIGCHLD 时, 调用一次 waitpid()
2. 父进程阻塞信号 SIGCHLD
3. 父进程产生五个子进程, 每次子进程都退出, 父进程休眠一秒, 保证子进程已退出
4. 父进程解除信号 SIGCHLD 阻塞
5. 此时, 由于有的 SIGCHLD 信号丢失, 有的子进程处于僵尸状态

源文件: [02.cc](./02.cc)

## 预防僵尸进程
### 方法一: 父进程设置忽略 SIGCHLD

源文件: [03.cc](./03.cc)

### 方法二: 父进程设置捕捉 SIGCHLD 时, 循环调用 waitpid(...WNOHANG)

源文件: [04.cc](./04.cc)

### 方法三: 父进程设置捕捉 SIGCHLD 时, 使用 sigaction() 设置 `SA_NOCLDWAIT`, 表示不产生僵尸进程

源文件: [05.cc](./05.cc)

### 方法四: 父进程退出, 使子进程变成孤儿进程, 子进程的父进程将变为 systemd, 后者会处理僵尸进程
1. 进程产生子进程作为测试的父进程
2. 测试的父进程产生测试的子进程
3. 测试的父进程产生测试的控制进程
4. 通过测试的控制进程杀死测试的父进程
5. 通过测试的控制进程杀死测试的子进程
6. 通过测试的控制进程可以看到测试的子进程并未处于僵尸状态

源文件: [06.cc](./06.cc)

## 销毁僵尸进程
### 方法
* 只能杀死僵尸进程的父进程, 僵尸进程的父进程将变为 systemd, 后者将处理僵尸进程

### 测试
1. 进程产生子进程作为测试的父进程
2. 测试的父进程产生测试的子进程
3. 测试的父进程产生测试的控制进程
4. 通过测试的控制进程可以看到测试的子进程处于运行状态
5. 通过测试的控制进程杀死测试的子进程
6. 通过测试的控制进程可以看到测试的子进程处于僵尸状态
7. 通过测试的控制进程杀死测试的父进程
8. 通过测试的控制进程可以看到测试的子进程消失了

源文件: [07.cc](./07.cc)

## 其他测试文件
* 产生僵尸进程不退出

## 注意事项
1. 设置 SIGCHLD 为 `SIG_IGN` 和 `SIG_DFL`(默认会忽略信号), 是不同的, 前者不会产生僵尸进程, 后者会
2. 发送 SIGCHLD 的子进程与 waitpid() 得到的子进程不一定相同

