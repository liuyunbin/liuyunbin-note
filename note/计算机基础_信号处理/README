
## 信号
信号是一种进程间通信的工具, 也可用于控制进程的行为

## 信号的来源
* 自己向自己发送信号(程序内)
* 父进程向子进程发送信号(程序内)
* 向同一用户下的任意进程发送信号(通过终端)
* 内核向进程发送信号
* 可以向进程发送信号, 也可以向进程组发送信号

## 信号的种类
* 不能被捕获的信号
    * SIGSTOP   # 暂停
    * SIGKILL   # 退出
* 和终端相关的信号
    * SIGINT    # 中断, 可由 Ctrl+C 产生
    * SIGQUIT   # 退出, 可由 Ctrl+\ 产生
    * SIGTSTP   # 暂停, 可由 Ctrl+Z 产生
    * SIGCONT   # 继续
    * SIGTTIN   # 属于后台进程时, 读取终端输入
    * SIGTTOU   # 属于后台进程时, 输出到终端
    * SIGHUP    # 控制终端断开时, 向会话ID 发送的信号
    * SIGWINCH  # 终端大小发生变化
* 程序错误 -- 此类错误, 优先级最高, 内部比较看值
    *  4-SIGILL  # 可执行文件有问题
    *  5-SIGTRAP # 断点, debug 产生
    *  7-SIGBUS  # 指针非法地址, 比如, 不符合对齐要求
    *  8-SIGFPE  # 浮点数异常, 比如整数除以0, 除非跳过异常的行, 否则将反复触发
    * 11-SIGSEGV # 指针地址合法, 但无权限访问, 比如, 空指针, 野指针, 除非跳过异常的行, 否则, 将反复触发
    * 31-SIGSYS  # 非法的系统调用
    * SIGSTKFLT  # 栈错误, 未使用
* 进程限制
    * SIGXCPU   # cpu 使用超出限制
    * SIGXFSZ   # 文件大小超出限制
* 资源问题
    * SIGURG    # 带外数据到达
    * SIGIO     # 异步IO就绪
    * SIGPWR    # 电池问题
    * SIGALRM   # alarm() 超时
    * SIGVTALRM # 虚拟的超时信号
    * SIGPROF   # setitimer() 超时
* 自定义信号
    * SIGUSR1   # 自定义信号
    * SIGUSR2   # 自定义信号
* 其他信号
    * SIGABRT   # abort() 产生, 除非信号处理函数从不返回, 否则将终止进程
    * SIGTERM   # kill 默认信号
    * SIGCHLD   # 子进程状态变化时, 向父进程发送
    * SIGPIPE   # 对端退出时, 写管道

## 信号处理方式
* 忽略信号
* 捕获信号, 自定义处理函数
* 退出
* 退出, 产生 core
* 暂停
* 继续

## 信号优先级
* SIGILL(4),SIGTRAP(5),SIGBUS(7),SIGFPE(8),SIGSEGV(11),SIGSYS(31) 优先处理, 从左到右
* 其他情况按数字的大小顺序处理

## 信号问题
* 信号不排队, 所以, 同一个信号多次出现时, 会有信号丢失的问题
* 多线程和信号处理会很麻烦

## 相关函数
* abort()  # 解锁信号 SIGABRT, 然后向自身发送 SIGABRT
* raise()  # 向自己发送信号
* kill()   # 发送信号
* longjmp(), setjmp() # 跨函数 goto
* pause()  # 暂停, 直到某一信号发生
* sleep()  # 暂停n秒, 或者一个未被忽略的信号到达
* signal() # 设置信号处理函数
           # 信号处理函数不会被重置
           # 被中断系统调用会自动重启
           # 信号不排队, 相同的信号出现多次时, 只当作一次处理
           # 信号处理时:
           #   相同的信号来了会被阻塞, 此时, 如果再来相同的信号将被抛弃
           #   不同的信号来了会被直接执行, 执行完之后, 在继续执行之前的函数
* sigaction() # 设置信号处理函数
              # 可以选择是否自动重启被中断的系统调用
              # 可以选择第一次调用以后, 信号处理函数是否恢复成默认值
              # 可以选择信号处理过程中, 是否阻塞自身, 或这阻塞指定信号集
              # 可以指明对子进程状态变化的处理
              # 可以获取到发送信号一端的一些信息
              # 信号不排队, 会丢失信号
* fork()      # 会继承信号处理函数, 未处理的信号被忽略(执行 exec 之前)
* sigemptyset() # 将信号集置空
* sigfillset()  # 填充所以信号
* sigaddset()   # 添加信号到信号集
* sigdelset()   # 从信号集删除信号
* sigismember() # 判断信号是否处于信号集

## 信号编号, 默认行为, 以及说明
 1) SIGHUP    # 退出进程, 控制终端断开
 2) SIGINT    # 退出进程, 键盘中断(ctrl+c)
 3) SIGQUIT   # 退出进程, 产生core, 键盘退出(ctrl+\)
 4) SIGILL    # 退出进程, 产生core, 非法指令, 一般是可执行文件发生错误
 5) SIGTRAP   # 退出进程, 产生core, 断点, debug 产生
 6) SIGABRT   # 退出进程, 产生core, 由 abort() 产生
 7) SIGBUS    # 退出进程, 产生core, 指针非法地址, 比如, 不符合对齐要求
 8) SIGFPE    # 退出进程, 产生core, 浮点数异常
 9) SIGKILL   # 退出进程, 不能被捕获和忽略
10) SIGUSR1   # 退出进程, 用户自定义信号
11) SIGSEGV   # 退出进程, 产生core, 指针地址合法, 但无权限访问, 比如其他进程的地址
12) SIGUSR2   # 退出进程, 用户自定义信号
13) SIGPIPE   # 退出进程, 对端退出时, 写管道
14) SIGALRM   # 退出进程, 由 alarm() 产生的超时
15) SIGTERM   # 退出进程, 可以被捕获和忽略, kill 默认信号
16) SIGSTKFLT # 退出进程, 栈错误, 未使用
17) SIGCHLD   # 忽略信号, 子进程状态变化时, 向父进程发送
18) SIGCONT   # 继续进程
19) SIGSTOP   # 暂停进程, 不能被捕获和忽略
20) SIGTSTP   # 暂停进程, 可以被捕获和忽略
21) SIGTTIN   # 暂停进程, 后台进程读取终端输入
22) SIGTTOU   # 暂停进程, 后台进程输出到终端
23) SIGURG    # 忽略信号, 带外数据
24) SIGXCPU   # 退出进程, 产生core, cpu 使用超出限制
25) SIGXFSZ   # 退出进程, 产生core, 文件大小超出限制
26) SIGVTALRM # 退出进程, 虚拟的超时信号
27) SIGPROF   # 退出进程, setitimer 到期
28) SIGWINCH  # 忽略信号, 终端大小发生变化
29) SIGIO     # 退出进程, 异步IO就绪
30) SIGPWR    # 退出进程, 电池问题
31) SIGSYS    # 退出进程, 产生core, 非法的系统调用

