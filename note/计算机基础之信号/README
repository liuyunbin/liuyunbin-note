
## 信号
信号是一种进程间通信的工具, 也可用于控制进程的行为

## 信号产生
* 终端产生(键盘中断, 键盘退出, 暂停, 终端大小变化)
* 内核向进程发送信号(IO 可用, 超时, 程序调试, 程序错误等)
* 自己向自己发送信号(abort(), kill())
* 其他进程向本进程发送信号(kill())

## 信号处理
* 阻塞信号, 被阻塞的信号处于未决状态
* 忽略信号
* 捕获信号, 默认处理(忽略, 退出, 退出产生core, 暂停, 继续)
* 捕获信号, 自定义处理

## 信号问题 -- 只考虑内核 3.10及其以后的 Linux 系统
#### 是否可以阻塞 捕获 或 忽略所有信号?
SIGKILL 和 SIGSTOP 不能被阻塞 捕获 和 忽略

#### 信号丢失
信号不排队, 所以, 同一个信号多次出现时, 会有信号丢失的问题

#### 信号触发后, 信号处理函数是否会恢复默认处理?
* signal()    不会恢复默认处理
* sigaction() 可以选择是否恢复默认处理

#### 信号触发的优先级
* SIGILL(4),SIGTRAP(5),SIGBUS(7),SIGFPE(8),SIGSEGV(11),SIGSYS(31) 优先处理, 从左到右
* 其他情况按数字的大小顺序处理

#### 信号处理时, 是否阻塞自身或其他信号?
* signal()    会阻塞自身, 不会阻塞其他信号
* sigaction() 可以选择阻塞的信号集

#### 信号处理时, 能不能获取发送端的数据?
* signal()    不能
* sigaction() 可以

#### 函数 abort() 是否一定会退出?
不一定
* SIGABRT 默认处理 进程会退出
* SIGABRT 忽略信号 进程会退出
* SIGABRT 捕获信号 信号处理函数返回, 进程会退出
* SIGABRT 捕获信号 信号处理函数不返回, 进程不会退出, 可以使用 longjmp(), setjmp() 跨函数 goto

#### SIGFPE 和 SIGSEGV 是否会一直触发?
会一直触发, 除非信号处理函数跳过错误行

#### SIGCHLD 相关问题
* 在子进程状态发生变化时, 会向父进程发送 SIGCHLD
* 子进程暂停, 继续, 后台进程向终端读取或输出信息
    * 设置默认处理, 会向父进程发送此信号, 父进程会忽略此信号
    * 设置忽略信号, 会向父进程发送此信号, 父进程会忽略此信号
    * 设置捕获信号, 会向父进程发送此信号, 父进程调用信号处理函数处理
    * 设置捕获信号, 并使用 sigaction 设置 SA_NOCLDSTOP, 不会向父进程发送此信号
* 子进程退出
    * 设置默认处理,   会产生僵尸进程
    * 设置忽略信号, 不会产生僵尸进程
    * 设置捕获信号, 并使用 waitpid() 类函数正确处理, 不会产生僵尸进程
    * 设置捕获信号, 并使用 waitpid() 类函数正确处理, 不会产生僵尸进程
    * 设置捕获信号, 并使用 sigaction 设置 SA_NOCLDWAIT, 不会产生僵尸进程
    * 设置忽略信号, 并使用 sigaction 设置 SA_NOCLDWAIT, 不会产生僵尸进程

#### 信号处理后, 是否自动重启被中断的系统调用?
* signal()    会自动重启
* sigaction() 可用选择是否自动重启

#### 多线程和信号处理会很麻烦

## 常用信号
 1) SIGHUP    # 控制终端断开, 向 SPID 发送
 2) SIGINT    # 键盘中断(ctrl+c)
 3) SIGQUIT   # 键盘退出(ctrl+\)
 4) SIGILL    # 非法指令, 可执行文件有错误
 5) SIGTRAP   # 由 断点, debug 产生
 6) SIGABRT   # abort() 产生, 除非信号处理函数从不返回, 否则将终止进程
 7) SIGBUS    # 指针非法地址, 比如, 不符合对齐要求
 8) SIGFPE    # 浮点数异常, 比如整数除以0, 除非跳过异常的行, 否则将反复触发
 9) SIGKILL   # 退出, 不能被阻塞, 捕获, 忽略
10) SIGUSR1   # 用户自定义信号
11) SIGSEGV   # 指针地址合法, 但无权限访问, 比如, 空指针, 野指针, 除非跳过异常的行, 否则, 将反复触发
12) SIGUSR2   # 用户自定义信号
13) SIGPIPE   # 写文件描述符时, 对方已退出, 比如 socket, 管道
14) SIGALRM   # 由 alarm() 产生的超时
15) SIGTERM   # 退出信号, kill 默认信号
16) SIGSTKFLT # 栈错误, 未使用
17) SIGCHLD   # 子进程状态变化时, 向父进程发送
18) SIGCONT   # 继续
19) SIGSTOP   # 暂停, 不能被 阻塞, 捕获, 忽略
20) SIGTSTP   # 暂停
21) SIGTTIN   # 后台进程读取终端输入
22) SIGTTOU   # 后台进程输出到终端
23) SIGURG    # 带外数据
24) SIGXCPU   # cpu 使用超出限制
25) SIGXFSZ   # 文件大小超出限制
26) SIGVTALRM # 虚拟的超时信号
27) SIGPROF   # setitimer 到期
28) SIGWINCH  # 终端大小发生变化
29) SIGIO     # 异步IO就绪
30) SIGPWR    # 电池问题
31) SIGSYS    # 非法的系统调用

## 常用函数
* abort()  # 解锁信号 SIGABRT, 然后向自身发送 SIGABRT
* raise()  # 向自己发送信号
* kill()   # 发送信号
* pause()  # 暂停, 直到某一信号发生
* sleep()  # 暂停n秒, 或者一个未被忽略的信号到达
* signal() # 设置信号处理函数
           # 信号处理函数不会被重置
           # 被中断系统调用会自动重启
           # 信号不排队, 相同的信号出现多次时, 只当作一次处理
           # 信号处理时:
           #   相同的信号来了会被阻塞, 此时, 如果再来相同的信号将被抛弃
           #   不同的信号来了会被直接执行, 执行完之后, 在继续执行之前的函数
* sigaction() # 设置信号处理函数
              # 可以选择是否自动重启被中断的系统调用
              # 可以选择第一次调用以后, 信号处理函数是否恢复成默认值
              # 可以选择信号处理过程中, 是否阻塞自身, 或这阻塞指定信号集
              # 可以指明对子进程状态变化的处理
              # 可以获取到发送信号一端的一些信息
              # 信号不排队, 会丢失信号
* fork()      # 会继承信号处理函数, 未处理的信号被忽略(执行 exec 之前)
* sigemptyset() # 将信号集置空
* sigfillset()  # 填充所以信号
* sigaddset()   # 添加信号到信号集
* sigdelset()   # 从信号集删除信号
* sigismember() # 判断信号是否处于信号集
* sigprocmask() # 阻塞 或 解阻塞 信号

