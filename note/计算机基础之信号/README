
# 信号
## 存在的意义
* 信号是一种进程间通信的工具

## 信号产生
* 终端
* 内核
* 进程

## 信号阻塞 -- 01.cc
* SIGKILL 和 SIGSTOP 无法被阻塞
* SIGCONT 可以被阻塞, 但好像没啥用
    1. 阻塞所有信号
    2. 此时, 可以看到除 SIGKILL 和 SIGSTOP 外, 其他信号都被阻塞了
    3. 向自身发送除了 SIGKILL 和 SIGSTOP 外的所有信号, 这两个信号不能被捕获, 而且会导致进程退出或暂停, 所以跳过
    4. 此时, 可以看到除 SIGKILL 和 SIGSTOP SIGCONT 外, 其他信号都处于待决状态

## 信号优先级 -- 02.cc
* 有多个信号处于未决状态(信号发送后, 处理前)时, 进程处理的顺序
    1. 为所有信号注册信号处理函数, 并设置信号处理过程中阻塞其他信号
    2. 阻塞所有信号
    3. 向自身发送除了 SIGKILL 和 SIGSTOP 外的所有信号, 这两个信号不能被捕获, 而且会导致进程退出或暂停, 所以跳过
    4. 解阻塞所有信号
    5. 此时, 可以看到信号捕获的顺序
        *  4-SIGILL
        *  5-SIGTRAP
        *  7-SIGBUS
        *  8-SIGFPE
        * 11-SIGSEGV
        * 31-SIGSYS
        * 其他信号按数字的从小到大顺序处理

## 信号不可靠
* 相同的信号处于待决状态时, 只记录一个, 其他信号会丢失 -- 03.cc
    1. 设置 SIGUSR1 的信号处理函数
    2. 阻塞信号 SIGUSR1
    3. 向自身发送信号 SIGUSR1 五次
    4. 解除信号 SIGUSR1 阻塞
    5. 可以看到 SIGUSR1 只捕获到一次
* 信号处理后, 信号处理函数可能会被重置 -- 04.cc
    1. 设置 SIGUSR1 的信号处理函数
    2. 设置信号触发后被重置
    3. 发送信号 SIGUSR1 第 1 次, 正常捕获
    4. 发送信号 SIGUSR1 第 2 次, 进程直接退出

## 信号处理
* 忽略信号
* 默认处理(忽略, 退出, 退出产生core, 暂停, 继续)
* 捕获信号, 信号处理过程中, 相同的信号来了会被阻塞, 此时, 如果再来相同的信号将被抛弃 -- 05.cc
    1. 设置信号 SIGUSR1 处理函数, 处理函数休眠 2 秒，便于观察
    2. 产生子进程
    3. 子进程空循环
    4. 父进程向子进程发送信号 SIGUSR1 第一次
    5. 此时, 观察到子进程正在执行信号处理函数
    6. 父进程向子进程发送信号 SIGUSR1 第二次
    7. 父进程向子进程发送信号 SIGUSR1 第三次
    8. 此时, 观察到子进程继续执行之前的信号处理函数，直到完成
    9. 然后, 处理第二次信号
    10. 不会处理第三次信号, 这个信号丢失了
* 捕获信号, 信号处理过程中, 不同的信号来了会被直接执行, 执行完之后, 再继续执行之前的函数 -- 06.cc
    1. 设置信号 SIGUSR1 和 SIGUSR2 处理函数, 处理函数休眠 2 秒，便于观察
    2. 产生子进程
    3. 子进程空循环
    4. 父进程向子进程发送信号 SIGUSR1
    5. 此时, 观察到子进程正在执行信号处理函数
    6. 父进程向子进程发送信号 SIGUSR2
    7. 此时, 观察到子进程直接处理信号 SIGUSR2，直到完成
    8. 然后, 继续处理 SIGUSR1, 直到完成
* 使用 sigaction() 可以选择阻塞的信号集 -- 07.cc
    1. 设置信号 SIGUSR1 和 SIGUSR2 处理函数, 处理函数休眠 2 秒, 便于观察，并设置信号处理过程中阻塞 SIGUSR2
    2. 产生子进程
    3. 子进程空循环
    4. 父进程向子进程发送信号 SIGUSR1
    5. 此时, 观察到子进程正在执行信号处理函数
    6. 父进程向子进程发送信号 SIGUSR2
    7. 此时, 观察到子进程继续执行之前的信号处理函数，直到完成
    8. 然后, 开始处理 SIGUSR2, 直到完成

## 常见信号
 1) SIGHUP  # 终端断开时, 向会话首进程发送
 2) SIGINT  # 键盘中断, 由 ctrl+c 产生
 3) SIGQUIT # 键盘退出, 由 ctrl+\ 产生
 4) SIGILL  # 非法指令, 可执行文件有错误
 5) SIGTRAP # 由 debug 产生
 6) SIGABRT # 由 abort() 产生时
            #   默认处理, 进程退出 -- 08.cc
            #   忽略信号, 进程退出 -- 09.cc
            #   捕获信号, 并从信号处理函数返回, 进程退出 -- 10.cc
            #   捕获信号, 不从信号处理函数返回, 进程继续 -- 11.cc
 7) SIGBUS  # 指针非法地址, 比如, 不符合对齐要求
 8) SIGFPE  # 浮点数异常, 比如整数除以0
            #   忽略信号, 进程退出
            #   默认处理, 进程退出
            #   捕获信号, 并从信号处理函数返回, 将继续触发此信号 -- 12.cc
            #   捕获信号, 不从信号处理函数返回, 进程继续运行
 9) SIGKILL # 退出, 不能被阻塞, 捕获, 忽略
10) SIGUSR1 # 用户自定义信号
11) SIGSEGV # 指针地址合法, 但无权限访问, 比如, 空指针, 除非跳过异常的行, 否则, 将反复触发
12) SIGUSR2 # 用户自定义信号
13) SIGPIPE # 写文件描述符时, 对方已退出, 比如 socket, 管道
14) SIGALRM # 由 alarm() 产生的超时
15) SIGTERM # 退出信号, kill 默认信号
16) SIGSTKFLT # 栈错误, 未使用
17) SIGCHLD # 子进程暂停或继续时, 会向父进程发送此信号
            #   父进程设置默认处理后, 会忽略此信号
            #   父进程设置忽略信号后, 会忽略此信号
            #   父进程设置捕获信号后, 会调用信号处理函数处理  -- 13.cc
            #   父进程使用 sigaction 设置 SA_NOCLDSTOP 后, 不再接收此信号 -- 14.cc
            # 子进程退出时, 会向父进程发送此信号
            #   父进程设置 sigaction 的 SA_NOCLDWAIT 后, 不会产生僵尸进程
            #   父进程设置默认处理,   会产生僵尸进程
            #   父进程设置忽略信号, 不会产生僵尸进程
            #   父进程设置捕获信号, 并调用 waitpid() 类函数一次, 可能会产生僵尸进程
            #   父进程设置捕获信号, 并调用 waitpid() 类函数循环,   不会产生僵尸进程
18) SIGCONT # 继续
19) SIGSTOP # 暂停, 不能被阻塞, 捕获, 忽略
20) SIGTSTP # 暂停
21) SIGTTIN # 后台进程读取终端输入
22) SIGTTOU # 后台进程输出到终端
23) SIGURG  # 带外数据
24) SIGXCPU # cpu 使用超出限制
25) SIGXFSZ # 文件大小超出限制
26) SIGVTALRM # 虚拟的超时信号
27) SIGPROF   # setitimer 到期
28) SIGWINCH  # 终端大小发生变化
29) SIGIO     # 异步IO就绪
30) SIGPWR    # 电池问题
31) SIGSYS    # 非法的系统调用

## 常用函数
* abort()  # 解锁信号 SIGABRT, 然后向自身发送 SIGABRT
* raise()  # 向自己发送信号
* kill()   # 发送信号
* pause()  # 休眠, 直到不被忽略的信号发生
* sleep()  # 休眠n秒, 或者一个未被忽略的信号到达
* signal() # 设置信号处理函数
           # 信号处理函数不会被重置
           # 被中断系统调用会自动重启
           # 信号处理时, 自身会被阻塞, 其他信号不会
* sigaction() # 设置信号处理函数
              # 可以选择是否自动重启被中断的系统调用
              # 可以选择第一次调用以后, 信号处理函数是否恢复成默认值
              # 可以选择信号处理过程中, 是否阻塞自身, 或这阻塞指定信号集
              # 可以指明对子进程状态变化的处理
              # 可以获取到发送信号一端的一些信息
* longjmp(), setjmp() # 跨函数 goto
* sigemptyset() # 将信号集置空
* sigfillset()  # 填充所有信号
* sigaddset()   # 添加信号到信号集
* sigdelset()   # 从信号集删除信号
* sigismember() # 判断信号是否处于信号集
* sigprocmask() # 阻塞 或 解阻塞 或 查看信号
* sigpending()  # 处于待决状态的信号

