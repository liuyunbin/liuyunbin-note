
# 僵尸进程
## 产生的原因
* 子进程退出时, 会向父进程发送 SIGCLD, 同时内核会保留子进程退出的状态信息
* 但父进程未正确处理这些信息

## 存在的意义
* 父进程可以获取子进程退出时的状态信息

## 存在的危害
* 不处理的话会造成系统资源的浪费

## 产生僵尸进程
### 父进程未处理子进程的退出信息
1. 父进程产生子进程
2. 子进程空循环
3. 此时, 可以看到子进程处于运行状态
4. 杀死子进程
5. 此时, 可以看到子进程处于僵尸状态

### 父进程未正确出来子进程的退出信息
1. 父进程设置捕捉 SIGCHLD 时, 调用一次 waitpid()
2. 父进程阻塞信号 SIGCHLD
3. 父进程产生三个子进程, 每次子进程都退出, 父进程休眠一秒, 保证子进程已退出
4. 父进程解除信号 SIGCHLD 阻塞
5. 此时, 由于有的 SIGCHLD 信号丢失, 有的子进程处于僵尸状态

## 预防僵尸进程
* 父进程设置捕捉 SIGCHLD 时, 循环调用 waitpid(...WNOHANG)
* 父进程设置忽略 SIGCHLD
* 父进程设置捕捉 SIGCHLD 时, 使用 sigaction() 设置 SA_NOCLDWAIT, 表示不产生僵尸进程
* 父进程退出, 使子进程变成孤儿进程, 子进程的父进程将变为 systemd, 后者会处理僵尸进程
    1. 进程产生子进程作为测试的父进程
    2. 测试的父进程产生测试的子进程
    3. 测试的父进程产生测试的控制进程
    4. 通过测试的控制进程杀死测试的父进程
    5. 通过测试的控制进程杀死测试的子进程
    6. 通过测试的控制进程可以看到测试的子进程并未处于僵尸状态

## 销毁僵尸进程
* 只能杀死僵尸进程的父进程, 僵尸进程的父进程将变为 systemd, 后者将处理僵尸进程
    1. 进程产生子进程作为测试的父进程
    2. 测试的父进程产生测试的子进程
    3. 测试的父进程产生测试的控制进程
    4. 通过测试的控制进程可以看到测试的子进程处于运行状态
    5. 通过测试的控制进程杀死测试的子进程
    6. 通过测试的控制进程可以看到测试的子进程处于僵尸状态
    7. 通过测试的控制进程杀死测试的父进程
    8. 通过测试的控制进程可以看到测试的子进程消失了

## 注意事项
1. 对于 SIGCHLD, 设置忽略信号和默认处理(默认行为是忽略), 是不同的, 前者不会产生僵尸进程, 后者会
2. 发送 SIGCHLD 的子进程与 waitpid() 得到的子进程不一定相同

