
# 僵尸进程

## 产生的原因
子进程退出时, 内核会保留子进程退出的状态信息, 由父进程处理, 而父进程未处理这些信息

## 存在的意义
父进程可以获取子进程退出的状态信息

## 存在的危害
会造成系统资源的浪费

## 重现产生的场景
### 子进程已退出, 父进程未处理
1. 父进程产生子进程
2. 子进程退出
3. 父进程休眠一秒, 保证子进程已退出
4. 此时, 可以看到子进程处于僵尸状态

### 子进程已退出, 父进程已处理, 但处理方式不对, 导致产生了僵尸进程
1. 父进程设置捕捉 SIGCHLD 时, 调用一次 waitpid()
2. 父进程阻塞信号 SIGCHLD
3. 父进程产生五个子进程, 每次子进程都退出, 父进程休眠一秒, 保证子进程已退出
4. 父进程解除信号 SIGCHLD 阻塞
5. 此时, 由于有的 SIGCHLD 信号丢失, 有的子进程处于僵尸状态

## 预防僵尸进程的产生
1. 父进程设置捕捉 SIGCHLD 时, 循环调用 waitpid(...WNOHANG)
2. 父进程设置忽略 SIGCHLD 信号(注意: 设置忽略信号 SIGCHLD 和 设置默认处理 SIGCHLD, 默认行为是忽略信号, 这两个是不同的)
3. 父进程设置捕捉 SIGCHLD 时, 使用 sigaction() 设置 SA_NOCLDWAIT
4. 父进程退出, 使子进程变成孤儿进程, 子进程的父进程将变为 systemd, 后者会处理僵尸进程

## 处理已存在的僵尸进程
1. 只能杀死僵尸进程的父进程
2. 此后, 僵尸进程将变成孤儿进程, 其父进程将变为 systemd
3. 此后, systemd 将处理 SIGCHLD 信号
4. 然后, 僵尸进程消失

