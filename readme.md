
# 编译
```
./install-dependency.sh
./build.sh
```

# 目录
* [计算机操作系统](#计算机操作系统)
    * [进程管理](#进程管理)
        * [进程基础](#进程基础)
        * [僵尸进程](#僵尸进程)
* [计算机组成原理](#计算机组成原理)
* [计算机网络](#计算机网络)
* [计算机语言](#计算机语言)
    * [bash](#bash)
    * [cpp](#cpp)
    * [python](#python)
    * [lua](#lua)
* [常用函数](#常用函数)
* [常用命令](#常用命令)

# 计算机操作系统
## 进程管理
### 进程基础
#### 线程启动

#### 进程退出
|          退出方式               | 终止类型 |   说明                                                 |
|---------------------------------|----------|--------------------------------------------------------|
| main() 函数返回                 | 正常终止 | 同调用 exit()                                          |
| 调用 exit()                     | 正常终止 | 调用 atexit() 登记的函数, 调用析构函数, 关闭文件描述符 |
| 调用 _exit()                    | 正常终止 | 直接进入内核                                           |
| 调用 _Exit()                    | 正常终止 | 同 _exit()                                             |
| 最后一个线程返回                | 正常终止 |                                          |
| 最后一个线程调用 pthread_exit() | 正常终止 |                                          |
| 调用 abort()                    | 异常中止 |                                          |
| 收到信号                        | 异常中止 |                                          |
| 取消最后一个线程                | 异常中止 |                                          |

#### 存储布局
|            布局      |    说明                                                                          |
|----------------------|----------------------------------------------------------------------------------|
| 正文段(text) |   程序本身, 只读, 可共享, 内存中只存储一份, 磁盘中需要存储                               |
| 数据段(data) |   初始化的全局变量或静态变量, 内存中每个进程一份, 磁盘中需要存储                         |
| bss          | 未初始化的全局变量或静态变量, 内存中每个进程一份, 磁盘中不需要存储, 程序启动时初始化为 0 |
| 栈           |   磁盘中不需要存储                                                 |
| 堆           |   磁盘中不需要存储                                                 |

使用 size 可以查看各个部分的大小

#### 共享库
* 静态库 -- 编译到可执行文件
* 动态库 -- 启动或运行时, 加载到可执行文件

#### 存储空间分配
* malloc()
* calloc()
* realloc()
* free()

#### 环境变量
* getenv()
* putenv()

#### 跨函数跳转
* longjmp()
* setjmp()

#### 资源使用
* getrlimit()
* setrlimit()

### 新建
* fork(): 父子进程的执行顺序不确定
* vfork(): 在子进程退出或执行exec之前, 父进程处于不可被信号打断的休眠状态
* 将继承父进程的进程组, 会话

### 修改
* PID 无法变化

### 销毁
* 将向父进程发送信号 SIGCHLD, 内核会保存退出状态
* 如果此进程是该进程组的最后一个进程, 此进程退出后, 该进程组消失
* 如果此进程是该会话的最后一个进程, 此进程退出后, 该会话消失

### 其他特性
* 启动命令: 完整的启动命令, 包括路径和参数, 如果是符号链接, 只会记录和展示符号本身
* 进程名称: 启动名称去掉路径和参数, 查找或输出时, 只会使用前 15 位(一般使用15位足够了)
* 一个进程只能属于一个父进程
* 一个父进程可以有多个子进程
* 一个进程只能属于一个进程组
* 一个进程只能属于一个会话
* 实际用户和组
* 有效用户和组
* 保存用户和组
* 文件用户和组, 一般和有效的用户相同
* 附属组
* 优先级

### 进程-状态及改变
* 就绪
* 运行(R)
* 休眠(S)(可被信号打断)(指被捕获的信号)
    * pause() 只有收到未忽略的信号才返回
    * sleep() 只有收到未忽略的信号 或 到达指定秒数才返回 -- 01.cc
        1. 使用 fork() 产生子进程
        2. 子进程设置信号(SIGUSR1)处理函数
        3. 子进程休眠10s
        4. 父进程休眠1s
        5. 此时, 可以看到, 子进程处于休眠状态
        6. 向子进程发送信号(SIGUSR1)
        7. 此时, 子进程被唤醒(休眠时间小于10s)
* 休眠(D)(不可被信号打断)(指被捕获的信号)
   * 调用 vfork() 后的父进程 -- 02.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程设置信号(SIGUSR1)处理函数
        3. 测试的父进程使用 vfork() 产生测试的子进程
        4. 测试的子进程休眠10s
        5. 测试的父进程休眠1s
        6. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        7. 向测试的父进程发送信号(SIGUSR1)
        8. 此时, 父进程处于不可打断的状态, 所以不会处理
        9. 测试的子进程休眠完成(休眠时间为10s)
        10. 测试的父进程处理信号, 直到结束
   * SIGSTOP 也会被阻塞 -- 03.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程使用 vfork() 产生测试的子进程
        3. 测试的子进程休眠10s
        4. 测试的父进程休眠1s
        5. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        6. 向测试的父进程发送信号(SIGSTOP)
        7. 此时, 父进程处于不可打断的状态, 所以不会处理
        8. 向测试的父进程发送信号(SIGCONT)
        9. 此时, 父进程处于不可打断的状态, 所以不会处理
        10. 测试的子进程休眠完成(休眠时间为10s)
        11. 测试的父进程继续运行, 直到结束
   * SIGKILL 不会被阻塞 -- 04.cc
        1. 使用 fork() 产生测试的父进程
        2. 测试的父进程使用 vfork() 产生测试的子进程
        3. 测试的子进程休眠10s
        4. 测试的父进程休眠1s
        5. 此时, 可以看到, 测试的父进程处于不可被打断的状态
        6. 向测试的父进程发送信号(SIGKILL)
        7. 测试的父进程退出
        8. 测试的子进程休眠完成(休眠时间为10s)
        9. 主进程结束
* 暂停(T)(作业控制)
    * 收到信号 SIGSTOP
    * 收到信号 SIGTSTP, 可由 ctrl+z 产生
    * 收到信号 SIGTTIN, 处于后台进程时读终端
    * 收到信号 SIGTTOT, 处于后台进程时写终端, 这个得看设置是否允许后台进程写终端
    * 继续, 收到信号 SIGCONT -- 05.cc
        1. 使用 fork() 产生子进程
        2. 子进程设置信号(SIGUSR1)处理函数
        3. 子进程空循环
        4. 父进程发送信号给子进程(SIGSTOP)
        5. 子进程暂停
        6. 父进程发送信号给子进程(SIGUSR1)
        7. 此时, 子进程处于暂停, 不会处理该信号
        8. 父进程发送信号给子进程(SIGCONT)
        9. 子进程继续, 然后处理 SIGUSR1, 直到结束
* 暂停(t)(由于 DEBUG 产生)
* 空闲(I)
    * 处于不可被打断的休眠状态时, 有时 CPU 是空闲的
* 僵尸(Z)
    * 子进程已退出, 父进程还未处理
* 退出(X)

### 操作系统-进程-系统文件
```
/proc/loadavg     # 系统负载
/proc/cpuinfo     # cpu 信息
/proc/uptime      # 运行时间
/proc/sys

/proc/PID/cmdline # 完整的启动命令
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/comm    # 进程名称, 不包含路径名称, 最多 15 位
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/cwd     # 进程当前的目录
/proc/PID/exe     # 符号链接, 指向运行的进程
/proc/PID/environ # 进程使用的环境变量
/proc/PID/fd      # 进程所打开的文件描述符
/proc/PID/limits  # 进程对各种资源的限制
/proc/PID/task    # 进程使用的线程情况
```

### 僵尸进程
* 产生的原因
    * 子进程退出时, 会向父进程发送 `SIGCHLD`, 同时内核会保留子进程退出的状态信息
    * 但父进程未正确处理此信号, 导致内核一直保留子进程退出的状态信息
* 存在的意义
    * 父进程可以获取子进程退出的状态信息
* 存在的危害
    * 数量较少时没有过大的负作用
    * 但大量僵尸进程会占用大量的 `PID` 以及其他系统资源, 影响系统正常使用
* 查看以及处理
    * 使用 `top` 查看是否存在僵尸进程(zombie)
    * 获取僵尸进程的进程号:
        * `ps --no-header -fe -o state,pid  | awk '$1 == "Z" {print $2}'`
    * 获取僵尸进程的父进程号:
        * `ps --no-header -fe -o state,ppid | awk '$1 == "Z" {print $2}'`
    * 杀死上一步获取的僵尸进程的父进程:
        * `kill -9 pid`
* 重现僵尸进程的产生
    * 情况一: 父进程未处理子进程退出的状态信息
    * 情况二: 父进程未正确处理子进程退出的状态信息
* 预防僵尸进程的产生
    * 方法一: 忽略信号 `SIGCHLD`
    * 方法二: 设置 `SIGCHLD` 处理为 循环调用 `waitpid`
    * 方法三: 设置 `SIGCHLD` 选项为 `SA_NOCLDWAIT`
    * 方法四: 杀死父进程
* 销毁僵尸进程: 杀死僵尸进程的父进程
* 注意事项
    * 设置 `SIGCHLD` 为 `SIG_IGN` 和 `SIG_DFL`(默认会忽略信号), 是不同的, 前者不会产生僵尸进程, 后者会
    * 发送 `SIGCHLD` 的子进程与 waitpid() 得到的子进程不一定相同

### 孤儿进程
* 产生的场景: 子进程未退出, 父进程已退出时, 此时子进程是孤儿进程
* 重现产生的场景
    1. 进程产生子进程作为测试的父进程
    2. 测试的父进程产生测试的子进程
    3. 测试的父进程空循环
    4. 此时, 可以看到测试的子进程的父进程是测试的父进程
    5. 杀死测试的父进程
    6. 此时, 可以看到测试的子进程的父进程变为 `systemd`
* 后续处理: 孤儿进程的父进程将变为 `systemd`
* 处理的意义: 保证所有进程都有父进程, 从而保证子进程退出时的资源都能被释放
* 注意事项
    * 孤儿进程只是一个临时状态, 马上就会有新的父进程
    * 孤儿进程只有父进程发生变化, 其他属性(比如, 进程, 进程组, 会话)不会变化

### 孤儿进程组
* 判断: 该进程组内所有进程的父进程, 要么属于该进程组, 要么不属于该进程组所属的会话
* 临界状态
    * 如果进程组的某个进程的父进程退出导致该进程所属组变成孤儿进程组
    * 且该进程组内有进程处于暂停状态
    * 0 号进程将发送 `SIGCONT` 和 `SIGHUP` 给该孤儿进程组的每一个成员
* 重现临界状态
    01. 进程产生子进程作为测试的父进程
    02. 测试的父进程新建新的进程组
    03. 测试的父进程产生测试的第一个子进程
    04. 测试的第一个子进程使自己暂停
    05. 测试的父进程产生测试的第二个子进程
    06. 此时, 新的进程组只包含测试的父进程, 测试的第一个子进程和测试的第二个子进程
    07. 杀死测试的父进程
    08. 此时, 新的进程组只包含测试的第一个子进程和测试的第二个子进程
    09. 上述两个进程的父进程变为 systemd
    10. systemd 和 两个测试的子进程不在同一个会话
    11. 新的进程组变成一个孤儿进程组, 第一个测试的子进程处于暂停状态
    12. 所以 0 号进程将发送 `SIGCONT` 和 `SIGHUP` 给该孤儿进程组的每一个成员
* 临界状态处理的意义: 出现临界状态一般都是程序有问题, 系统相当于加了一层保险, 避免系统资源浪费
* 注意事项
    * 会话首进程所在的进程组也属于孤儿进程组
    * 孤儿进程所在的进程组不一定是孤儿进程组

### 进程组
* 存在意义: 为了便于向一批进程发送信号
* 新建
    * 只能新建值为对应的 PID 的进程组, 并将对应进程加入该进程组
    * 如果新建的进程组的值与原进程组的值相同, 则忽略
    * 可以为自身新建进程组
    * 子进程不能为父进程的新建对应的进程组
    * 不能新建子进程的进程组(子进程属于不同的会话)
    * 不能新建子进程的进程组(子进程调用exec之后)
    * 可以新建子进程的进程组(其他情况)
    * 不能新建孙进程对应的进程组
    * 不能新建会话首进程对应的的进程组
* 修改
    * 目标进程组必须存在
    * 目标进程组和原进程组必须属于同一个会话
    * 其他情况与新建进程组相同
* 销毁
    * 创建进程组的进程退出或修改进程组时, 只要原进程组还有其他进程, 原进程组就不会消失
    * 当该进程组的最后一个进程退出或所属的进程组被修改时, 原进程组消失
    * 可以向同一进程组内的所有成员统一发送信号
* 与进程和会话的关系
    * 一个进程组包含一个或多个进程
    * 一个进程组只能属于一个会话

### 会话
* 存在意义: 为了便于终端的处理
* 新建
    * 新的会话ID是当前进程的ID, 新的进程组ID也是当前进程的ID
    * 新会话和新进程组里将只包含当前进程
    * 新的会话将脱离终端的控制
    * 当前进程是进程组的首进程时, 不能新建会话, 避免出现同一进程组的进程属于不同的会话的情况
    * 当前进程不能是进程组的首进程时, 可以新建会话
* 销毁(会话不和终端绑定): 会话首进程退出时, 不会对会话内的其他进程有影响
* 和进程 进程组 终端的关系
    * 一个会话包含一个或多个进程
    * 一个会话包括一个或多个进程组
    * 一个会话最多和一个终端绑定

### 控制终端
* 用户登录时, 系统将一个会话与终端绑定, 此会话进程即为控制进程
* 终端退出时, 将发送 SIGHUP 给控制进程, 控制进程将向此会话中的所有进程组发送信号 SIGHUP
    * 对于暂停的作业将先发送 SIGCONT 和 SIGTERM 信号
* 此会话有且只有一个前台进程组, 有零个或多个后台进程组
* 终端的输入将发送到前台进程组, 前台和后台进程组的输出都将发送到终端
* 新建会话可以脱离终端
* 脱离终端的进程的父进程不一定是 1, 也可能是其他脱离终端的进程
* 脱离终端可以忽略 SIGHUP 或 新建会话

### 守护进程
1. 产生子进程, 然后父进程退出, 保证子进程不是进程组的首进程
2. 新建会话, 保证子进程脱离终端的控制
3. 关闭所有的文件描述符, 避免受到父进程文件描述符的影响
4. 设置权限掩码, 避免受到父进程掩码的影响
5. 切换到根目录, 因为当前目录可能会被卸载或删除

参见开源项目: https://github.com/lighttpd/spawn-fcgi

## 信号
### 信号基础
* 信号-阻塞
    * `SIGKILL` 和 `SIGSTOP` 无法被阻塞
    * `SIGCONT` 可以被阻塞, 但好像没啥用
* 信号-优先级
    * 有多个信号处于未决状态(信号发送后, 处理前)时, 进程处理的顺序
    * 04-SIGILL
    * 05-SIGTRAP
    * 07-SIGBUS
    * 08-SIGFPE
    * 11-SIGSEGV
    * 31-SIGSYS
    * 其他信号按数字的从小到大顺序处理
* 信号-不可靠
    * 相同的信号处于待决状态时, 只记录一个, 其他信号会丢失
    * 信号处理后, 信号处理函数可能会被重置
* 信号-信号处理
    * 忽略信号
    * 默认处理(忽略, 退出, 退出产生core, 暂停, 继续)
    * 捕获信号
        * 信号处理过程中, 相同的信号来了会被阻塞, 此时, 如果再来相同的信号将被抛弃
        * 信号处理过程中, 不同的信号来了会被直接执行, 执行完之后, 再继续执行之前的函数
        * 使用 sigaction() 可以选择阻塞的信号集

### 常见信号
```
 1) SIGHUP  # 终端断开时, 向会话首进程发送
 2) SIGINT  # 键盘中断, 由 ctrl+c 产生
 3) SIGQUIT # 键盘退出, 由 ctrl+\ 产生
 4) SIGILL  # 非法指令, 可执行文件有错误
 5) SIGTRAP # 由 debug 产生
 6) SIGABRT # 由 abort() 产生时
            #   默认处理, 进程退出
            #   忽略信号, 进程退出
            #   捕获信号, 并从信号处理函数返回, 进程退出
            #   捕获信号, 不从信号处理函数返回, 进程继续
 7) SIGBUS  # 指针非法地址, 比如, 不符合对齐要求
 8) SIGFPE  # 浮点数异常, 比如整数除以0
            #   忽略信号, 进程退出
            #   默认处理, 进程退出
            #   捕获信号, 并从信号处理函数返回, 将继续触发此信号
            #   捕获信号, 不从信号处理函数返回, 进程继续运行
 9) SIGKILL # 退出, 不能被阻塞, 捕获, 忽略
10) SIGUSR1 # 用户自定义信号
11) SIGSEGV # 指针地址合法, 但无权限访问, 比如, 空指针, 除非跳过异常的行, 否则, 将反复触发
12) SIGUSR2 # 用户自定义信号
13) SIGPIPE # 写文件描述符时, 对方已退出, 比如 socket, 管道
14) SIGALRM # 由 alarm() 产生的超时
15) SIGTERM # 退出信号, kill 默认信号
16) SIGSTKFLT # 栈错误, 未使用
17) SIGCHLD # 子进程暂停或继续时, 会向父进程发送此信号
            #   父进程设置默认处理后, 会忽略此信号
            #   父进程设置忽略信号后, 会忽略此信号
            #   父进程设置捕获信号后, 会调用信号处理函数处理
            #   父进程使用 sigaction 设置 SA_NOCLDSTOP 后, 不再接收此信号
            # 子进程退出时, 会向父进程发送此信号
            #   父进程设置 sigaction 的 SA_NOCLDWAIT 后, 不会产生僵尸进程
            #   父进程设置默认处理,   会产生僵尸进程
            #   父进程设置忽略信号, 不会产生僵尸进程
            #   父进程设置捕获信号, 并调用 waitpid() 类函数一次, 可能会产生僵尸进程
            #   父进程设置捕获信号, 并调用 waitpid() 类函数循环,   不会产生僵尸进程
18) SIGCONT # 继续
19) SIGSTOP # 暂停, 不能被阻塞, 捕获, 忽略
20) SIGTSTP # 暂停
21) SIGTTIN # 后台进程读取终端输入
22) SIGTTOU # 后台进程输出到终端
23) SIGURG  # 带外数据
24) SIGXCPU # cpu 使用超出限制
25) SIGXFSZ # 文件大小超出限制
26) SIGVTALRM # 虚拟的超时信号
27) SIGPROF   # setitimer 到期
28) SIGWINCH  # 终端大小发生变化
29) SIGIO     # 异步IO就绪
30) SIGPWR    # 电池问题
31) SIGSYS    # 非法的系统调用
```

### 相关函数
```
* abort()  # 解锁信号 SIGABRT, 然后向自身发送 SIGABRT
* raise()  # 向自己发送信号
* kill()   # 发送信号, 向某一进程 或 进程组
* pause()  # 休眠, 直到不被忽略的信号发生
* sleep()  # 休眠n秒, 或者一个未被忽略的信号到达
* signal() # 设置信号处理函数
           # 信号处理函数不会被重置
           # 被中断系统调用会自动重启
           # 信号处理时, 自身会被阻塞, 其他信号不会
* sigaction() # 设置信号处理函数
              # 可以选择是否自动重启被中断的系统调用
              # 可以选择第一次调用以后, 信号处理函数是否恢复成默认值
              # 可以选择信号处理过程中, 是否阻塞自身, 或这阻塞指定信号集
              # 可以指明对子进程状态变化的处理
              # 可以获取到发送信号一端的一些信息
* longjmp(), setjmp() # 跨函数 goto
* sigemptyset() # 将信号集置空
* sigfillset()  # 填充所有信号
* sigaddset()   # 添加信号到信号集
* sigdelset()   # 从信号集删除信号
* sigismember() # 判断信号是否处于信号集
* sigprocmask() # 阻塞 或 解阻塞 或 查看信号
* sigpending()  # 处于待决状态的信号
```

# 计算机组成原理
# 计算机网络
# 计算机语言

# 常用函数
* fork()      -- 产生子进程
* vfork()     -- 产生子进程, 子进程退出或调用 exec 前, 父进程不会运行

* exec()      -- 执行命令

* localtime() -- 获取本地时间

* system()    -- 执行命令, 输出到终端?
* strftime()  -- 格式化时间
* kill()      -- 发送信号
* time()      -- 获取当前的时间戳

* getpid()
* getsid()
* getppid()
* getpgid()

* signal()

* wait()    -- 获取子进程的退出信息
* waitpid()
* wait3()
* wait4()
* waitid()
```

# 常用命令

-----------------------------------------------------

# 最佳实际
* 文件名称建议: 大小写字母 数字 下划线 短横线 点
* 参数建议: 不要空格, 不要以短横线开头
* 学习命令: 以功能为核心,
* 学习一个命令需要注意的点
    * 不常用的命令, 只需知道大致功能即可, 比如, 组相关的命令
    * 不常用的命令, 只需知道命令的大致功能 或者 关键参数即可, 比如, 组相关的命令
    *   复杂的命令, 需要总结出常用的参数, 每次都过一遍 man 文档太麻烦了, 比如, ps
    *   常用的命令, 需要知道大致功能即可, 记住常用参数, 其他参数需要的时候查询即可
    * 支持 通配符, 还是基础的正则表达式 还是 扩展的正则表达式
    * 涉及过滤时, 多个命令是且还是或
    * 对符号链接的处理, 这个可以先猜, 有利于加深理解
    * 对转义字符的处理
    * 学习命令要以功能为核心而不是以命令参数为核心
    * 不要垃圾进垃圾出, 宁可不写, 也不写错的, 或者 不懂的内容

# 计算机组成原理-整数-浮点数-字符
## 本文主要讨论数据在内存以及文件中存储
* 基础知识(原码 反码 补码 移码 字节序)
* 无符号的整数的存储(内存以及二进制文件)
* 有符号的整数的存储(内存以及二进制文件)
* 浮点数的存储(内存以及二进制文件)
* 字符存储(内存 二进制文件 文本文件)
* 查看二进制(内存)
* 查看二进制(文件)

## 基础知识(原码 反码 补码 移码 字节序)

### 加减法的所有类型
* 正数+正数:
* 正数-正数:
* 正数+负数: 可以转化为 正数-正数
* 正数-负数: 可以转化为 正数+正数
* 负数+正数: 可以转化为 正数-正数
* 负数+负数: 可以转化为 正数+正数, 然后把正数变成负数
* 负数-正数: 可以转化为 正数+正数, 然后把正数变成负数
* 负数-负数: 可以转化为 正数-负数
* 正数: 可以转化为    0+正数
* 负数: 可以转化为    0-正数

所以我们考虑加减法只要处理 正数+正数 和 正数-正数 的情况就可以了

### 原码
* 正数: 符号位为 0
* 负数: 符号位为 1
* +0: 0000
* -0: 1000
* 最大: 0111(+7)
* 最小: 1111(-7)
* 比较大小:
    * 先比较符号位, 正数大于负数
    * 同为正数, 数越大, 值越大
    * 同为负数, 数越大, 值越小
* 正数+正数: 需要使用加法器处理, 像列竖式一样, 高位直接舍弃
* 正数-正数: 需要使用减法器处理

### 反码
* 计算:
    * 正数的反码和原码相同
    * 负数的反码在原码的基础上, 把除符号位外的所有位取反
* 定义:
    * 最高位取负, 值为 2^(w-1) - 1, 其他位取正, 即:
    * 0000 == -0*(2^3-1) + 0*2^2 + 0*2^1 + 0*2^0 = -0 + 0 + 0 + 0 = +0
    * 1111 == -1*(2^3-1) + 1*2^2 + 1*2^1 + 1*2^0 = -7 + 4 + 2 + 1 = -0
    * 0111 == -0*(2^3-1) + 1*2^2 + 1*2^1 + 1*2^0 = -0 + 4 + 2 + 1 = +7(最大)
    * 1000 == -1*(2^3-1) + 0*2^2 + 0*2^1 + 0*2^0 = -7 + 0 + 0 + 0 = -7(最小)
* 比较大小(比使用原码好一点, 同号的比较大小可以统一)
    * 先比较符号位, 正数大于负数
    * 同为正数, 数越大, 值越大
    * 同为负数, 数越大, 值越小
* 正数+正数: 无意义
* 正数-正数: 无意义

### 补码
* 计算
    * 正数的补码和原码相同
    * 负数的补码在反码的基础上, 在最后一位加一
* 定义:
    * 最高位取负, 其他位取正
    * 0000 == -0*2^3 + 0*2^2 + 0*2^1 + 0*2^0 = -0 + 0 + 0 + 0 = +0
    * 0111 == -0*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = -0 + 4 + 2 + 1 = +7(最大)
    * 1000 == -1*2^3 + 0*2^2 + 0*2^1 + 0*2^0 = -8 + 0 + 0 + 0 = -8(最小)
* 比较大小(比使用原码好一点, 同号的比较大小可以统一)
    * 先比较符号位, 正数大于负数
    * 同为正数, 位数越大, 值越大
    * 同为负数, 位数越大, 值越大
* 正数+正数: 使用加法器处理
* 正数-正数: 可以转化为 正数 + 负数, 然后使用加法器处理(补码存在的主要目的)
* 补码变符号
    * 正数(+1) => 负数(-1) == 正数的补码(0001)各位取反(1110), 然后加一(1111)
    * 负数(-1) => 正数(+1) == 负数的补码(1111)各位取反(0000), 然后加一(0001)
* 加法器: 像列竖式一样, 从低到高, 一位一位相加, 该进就进, 超过最高位直接舍弃

### 移码
* 在原码的基础上加一个数字, 使得所有的数字都是非负数
* 比较大小: 直接比较即可
* 加法: 无意义
* 减法: 无意义

### 字节序(单元大小是多字节的数据, 高字节在前还是在后)
* 网络字节序(大端)
* 内存中存储(大小端由 CPU 决定, 一般使用小端存储)(主机字节序)
* 文件内存储二进制(同内存中存储)(二进制文件)
* 文件中存储字符(由 BOM 决定)(文本文件)

### 大小端
#### 大端存储(高字节存储在内存的低字节)
* 方便判断正负
* 看起来直观, 手写的计算机存储和真实的存储一致

#### 小端存储(高字节存储在内存的高字节)
* 方便类型转换, 比如 int => short

#### 涉及的 C++ 类型
* 整形: short, int, long, long long
* 浮点型: float, double, long double
* 字符类: `wchar_t`, `char16_t`, `char32_t`

#### 判断
使用共同体或类似的方法

测试: [101-01.cc](./101-01.cc)

### BOM
* UTF-8 : 不需要 BOM (使用 vim 的 set nobomb 可以去掉 BOM)
* UTF-16: 由 BOM 指定
* UTF-32: 由 BOM 指定
* GBK: 不需要 BOM

## 无符号的整数的存储(内存以及二进制文件)
* 使用原码表示
* 溢出时舍弃高位
* 最小数: 0000(0*2^3+0*2^2+0*2^1+0*2^0 == 0)
* 最大数: 1111(1*2^3+1*2^2+1*2^1+1*2^0 == 15)
* unsigned char, unsigned short, usigned long, unsigned long long
* 除 unsigned char 外, 有大小端之分
* 无符号的整数 除以 无符号的整数 结果还是 无符号的整数, 小数部分直接舍弃

## 有符号的整数的存储(内存以及二进制文件)
* 使用补码表示(方便处理减法以及负数)
* 溢出时未定义
* 最小数: 1000(-1*2^3+0*2^2+0*2^1+0*2^0 == -8)
* 最大数: 0111(+0*2^3+1*2^2+1*2^1+1*2^0 == +7)
* signed char, short, long, long long
* 除 signed char 外, 有大小端之分
* 有符号的整数 除以 有符号的整数
    * 商的符号由除数和被除数决定, 取余的符号只和被除数有关(C++11)
    * 小数部分直接舍弃

测试: [101-02.cc](./101-02.cc)

## 浮点数的存储(内存以及二进制文件)
* 使用 double, 探索浮点数的存储以及精度的损失
* 区分大小端
* 格式: 1-符号位 11-阶码 52-尾码

### 浮点数的类型
* 正负  零: 阶码都为 0, 尾码  都为 0
* 非规约数: 阶码都为 0, 尾码不都为 0, 阶码的偏移量为 1022, 尾码整数部分为 0 (特别小的数字)
* 正负无穷: 阶码都为 1, 尾码  都为 0
* 非数字: 阶码都为 1, 尾码不都为 0
* 规约数: 阶码不都为 0, 也不都为 1, 阶码的偏移量为 1023, 尾码整数部分为 1
* 查看浮点数类型: pclassify(...)

### 浮点数的舍入模式
* 范围:
    * 浮点数存储(二进制)
    * 保留小数位数(十进制)
    * 如果不能精确处理, 是舍弃还是进一
* 向下舍入:
    * 正数: 舍弃
    * 负数: 进一
    * std::floor
* 向上舍入:
    * 正数: 进一
    * 负数: 舍弃
    * std::ceil
* 向零舍入:
    * 正数: 舍弃
    * 负数: 舍弃
    * std::trunc
    * 浮点数-->整数
* 四舍五入:
    * 只用于保留小数位数
    * 剩余部分第一位小于 5: 舍弃
    * 剩余部分第一位大于等于 5: 进一
    * std::round
* 最近舍入:
    * 四舍六入五取偶
    * 保留小数
        * 剩余部分第一位小于 5: 舍弃
        * 剩余部分第一位大于 5: 进一
        * 剩余部分第一位 5 后  存在非 0 位: 进一
        * 剩余部分第一位 5 后不存在非 0 位: 进一
            * 精确存储的的最后一位为奇数: 进一
            * 精确存储的的最后一位为偶数: 舍弃
    * 存储
        * 剩余部分第一位为 0: 舍弃
        * 剩余部分第一位为 1 且后  存在 非 0 位: 进一
        * 剩余部分第一位为 1 且后不存在 非 0 位
            * 精确存储的的最后一位为 1: 进一
            * 精确存储的的最后一位为 0: 舍弃
    * 默认是最近舍入
* 由舍入模式决定:
    * std::rint
    * std::nearbyint
* 查看舍入模式: fegetround()
* 设置舍入模式: fesetround(...)

#### 测试文件
* 测试保留小数时的四舍六入五取偶: [03.cc](./03.cc)
* 测试存储小数时的四舍六入五取偶: [04.cc](./04.cc)

### 浮点数异常(这个比较乱, 一般不重要)
* 范围:
    * 四则运算
    * 调用函数
    * 参数不合法 或者 结果不准确的问题
* 类型:
    * 除以 0
    * 结果不准确
    * 参数非法
    * 上溢
    * 下溢
* 清空浮点数异常: feclearexcept(...)
* 测试浮点数异常: fetestexcept(...)
* 可能会引发浮点数异常的场景:
    * 浮点数的四则运算
    * 绝大部分函数
* 不会引发浮点数异常的场景:
    * isless 只对 signaling NaN 抛出异常
    * nearbyint 系列

测试: [101-05.cc](./101-05.cc)

### 浮点数最多可以表示的小数点后的位数
* 最小非规约正数的最后一位非 0 位
* 1074 位

测试: [101-06.cc](./101-06.cc)

### 阶码为什么用移码? 不用补码, 反码, 原码
* 方便比较大小
    * 符号位特殊
    * 其他位直接比较即可
* 使用其他的还需要判断阶码的符号位

### 相邻可表示的浮点数的差值是不是一定的?
* 不是
* 离零越近, 差值越小
* 非规约数:
    * 差值: 2 的 (0-1022-52) 次
    * 即: 2 的 -1074 次
* 最大非规约正数 --> 最小规约正数
    * 差值: 2 的 (0-1022-52) 次
    * 即: 2 的 -1074 次
* 阶码相同时
    * 差值: 2 的 (阶码-1023-52) 次
* 阶码相邻时
    * 差值: 2 的 (小的阶码-1023-52) 次

### 非规约数的偏移量为什么是 1022, 不是 1023?, 非规约数的整数位为什么是 0, 不是 1?
* 设 a 为最大正非规约数的上一可表示数: 0 00000000000 (0)1111111111111111111111111111111111111111111111111110
* 设 b 为最大正非规约数              : 0 00000000000 (0)1111111111111111111111111111111111111111111111111111
* 设 c 为最小正规约数                : 0 00000000001 (1)0000000000000000000000000000000000000000000000000000
* 设 d 为最小正规约数的下一可表示数  : 0 00000000001 (1)0000000000000000000000000000000000000000000000000001
* 如果非规约数的偏移量是 1022, 非规约数的整数位是 0
    * a 为: -1022次 - -1074次 - -1074次 (-1022 - 52)
    * b 为: -1022次 - -1074次
    * c 为: -1022次
    * d 为: -1022次 + -1074次
    * b - a: -1074次
    * c - b: -1074次
    * d - c: -1074次
* 如果非规约数的偏移量是 1023, 非规约数的整数位是 0 (非规约数 => 规约数, 变化差值不太连续)
    * a 为: -1023次 - -1075次 - -1075次 (-1023 - 52)
    * b 为: -1023次 - -1075次
    * c 为: -1022次 == -1023次 + -1023次
    * d 为: -1022次 + -1074次
    * b - a: -1075次
    * c - b: -1075次 + -1023次
    * d - c: -1074次
* 如果非规约数的偏移量是 1022, 非规约数的整数位是 1(最大非规约数 大于 最小规约数, 不行)
    * a 为: -1022次 + -1022次 - -1074次 - -1074次 (-1022 - 52)
    * b 为: -1022次 + -1022次 - -1074次
    * c 为: -1022次
    * d 为: -1022次 + -1074次
    * b - a: -1074次
    * c - b: -1074次 - -1022次 (小于 0)
    * d - c: -1074次
* 如果非规约数的偏移量是 1023, 非规约数的整数位是 1(相比较, 第一种能表达更贴近 0 的数)
    * a 为: -1023次 + -1023次 - -1075次 - -1075次 (-1023 - 52)
    * b 为: -1023次 + -1023次 - -1075次
    * c 为: -1022次 == -1023次 + -1023次
    * d 为: -1022次 + -1074次
    * b - a: -1075次
    * c - b: -1075次
    * d - c: -1074次

测试: [101-07.cc](./101-07.cc)

### 规约数的隐藏位为什么是1?
为了节省空间

### 浮点数精度损失
* 范围
    * 浮点数存储
    * 浮点数取回
    * 浮点数计算
* 小于最小非规约正数的正数将当作 0
* 大于最大规约正数的数字将当作正无穷
* 以下仅讨论规约数和非规约数
* 浮点数字符串(a) --> 浮点数二进制(b)
    * 可能无法精确转换(0.1)
* 浮点数二进制(b) --> 浮点数科学计数(c)
    * 无精度损失
* 浮点数科学计数(c) --> 调节幂次(d)
    * 如果, 幂次小于 -1022
        * 将幂次改为 -1022
        * 同时调整小数部分
    * 无精度损失
* 调节幂次(d) --> 存储-52位(e)
    * 整数部分为 1, 表示规约数
    * 整数部分为 0, 表示非规约数
    * 只存储小数部分
    * 前 51 位精确存储
    * 最后一位四舍六入五取偶
    * 注意: 进一的时候可能引发前 51 位变化
* 存储-52位(e) --> 浮点数二进制(f)
    * 无精度损失
* 浮点数二进制(f) --> 浮点数十进制(g)
    * 无精度损失
* 浮点数十进制(g) --> 保留小数位数(h)
    * 默认: 四舍六入五取偶
* 一个精确的浮点数表示的上下限
    * 如果最后一位是 0, 则范围是 [下限, 上限]
    * 如果最后一位是 1, 则范围是 (下限, 上限)

测试: [101-08.cc](./101-08.cc)

### 15 位精度是什么意思?
* 并不是说: 所有数字的前15位可以精确表示(0.1 不能精确表示)
* 而是说计算机能保证的能区分的精度是 15 位, 在指数相同的情况下, 存储的不同数的前 15 位有效数字是不同的
* 超过 15 位也可能能表示

#### 理解
* 符号位, 阶码固定的情况下, 相邻的可表示数的差值是固定的, 可表示数的状态也是固定的
* 52 位二进制能表示 4503599627370496 种状态
* 53 位二进制能表示 9007199254740992 种状态
* 即 能够准确表示十五位状态
* 即 能够保证的精度是十五位数
* 还是不太清楚, 先放下吧,...

测试: [101-09.cc](./101-09.cc)

## 字符存储(内存 二进制文件 文本文件)(建议只使用不带bom的utf-8)
* 编码: 字符 -> 计算机存储
* 解码: 计算机存储 -> 字符
* 字符集:
    * ASCII (和编码规则一一对应)
    * GB2312 => GBK(cp936) => GB18030 (和编码规则一一对应)
    * BIG5
    * Unicode
    * Latin1(ISO-8859-1) 单字节使用完整的八位字节, 所以可以将其他编码当作 Latin1 来传输不会丢失数据
* 编码规则:
   * UTF-8
        * 文本文件: 不需要 BOM, 存在也成(FE FF => EF BB BF)(建议不要)
        * 内存以及二进制文件: 不需要考虑字节序
   * UTF-16
        * 文本文件: 需要 BOM(FE FF 或 FF FE)
        * 内存以及二进制文件: 和主机的字节序相同
   * UTF-32
        * 文本文件: 需要 BOM(00 00 FE FF 或 FF FE 00 00)
        * 内存以及二进制文件: 和主机的字节序相同
   * windows 的 记事本 的 ASCI   : 本地编码
   * windows 的 记事本 的 unicode: 带 BOM 的小端的 UTF-16
   * windows 的 记事本 的 utf-8  : 带 BOM 的 UTF-8
* 文件编码转换: iconv -f gbk -t utf-8 1.txt -o 1.txt
* 文件编码不一定能准确获取
* 在 C++ 中使用(建议只使用 UTF-8)
    * UTF-8 : char, string   ,  ".....", u8"....."
    * UTF-16: char, u16string, u"....."
    * UTF-32: char, u32string, U"....."
    * 字符串常量以 \u 开头的四个十六进制数表示 Unicode
    * 字符串常量以 \U 开头的八个十六进制数表示 Unicode

测试: [101-10.cc](./101-10.cc)

## 查看二进制(内存)
* 使用 gdb
* 在代码中直接读取内存中存储的值

## 查看二进制(文件)
```
xxd -b     1.txt  # 输出二进制而不是十六进制
xxd -e     1.txt  # 使用小端模式
xxd -g ... 1.txt  # 每组的字节数            -- 建议使用, 读取的顺序和存储的顺序相同, 不需要考虑字节序

hd         1.txt # 每组一个字节 显示十六进制+ASCII -- 不建议使用, 得考虑字节序
hexdump -b 1.txt # 每组一个字节 显示八进制
hexdump -c 1.txt # 每组一个字节 显示字符
hexdump -C 1.txt # 每组一个字节 显示十六进制+ASCII
hexdump -d 1.txt # 每组两个字节 显示  十进制
hexdump -o 1.txt # 每组两个字节 显示  八进制
hexdump -x 1.txt # 每组两个字节 显示十六进制

od -t a   1.txt # 每组一个字节, 显示字符(nl) -- 不建议使用, 得考虑字节序
od -t c   1.txt # 每组一个字节, 显示字符(\n)
od -t d4  1.txt # 每组四个字节, 显示有符号的十进制数字
od -t f4  1.txt # 每组四个字节, 显示浮点数
od -t o4  1.txt # 每组四个字节, 显示  八进制数字
od -t u4  1.txt # 每组四个字节, 显示无符号的十进制数字
od -t x4  1.txt # 每组四个字节, 显示十六进制数字
od -t d4z 1.txt # 每组四个字节, 显示十进制数字, 并显示原始字符
od -a     1.txt # 同 -t a
od -b     1.txt # 同 -t o1
od -c     1.txt # 同 -t c
od -d     1.txt # 同 -t u2
od -f     1.txt # 同 -t f
od -i     1.txt # 同 -t dI
od -l     1.txt # 同 -t dL
od -o     1.txt # 同 -t o2
od -s     1.txt # 同 -t d2
od -x     1.txt # 同 -t x2
od --endian={big|little} 1.txt # 指明大小端
```

# 操作系统-用户和组
## 为什么存在用户?
* 要登录一个系统, 肯定需要一个名称, 用以区分不同的用户

## 为什么存在组?
* 为了多个用户之间共享数据

## 用户, 用户名称, 用户ID, 组, 组名称, 组ID之间的关系
* 用户和用户名称一一对应, 组和组名称一一对应
* 一个用户只能对应一个用户ID, 一个组只能对应一个组ID
* 多个用户可以对应一个用户ID, 多个组可以对应一个组ID
* 一个用户可以对应多个组, 但只能有一个主组

## 用户名称和组名称有什么限制?
* 只能包含 大小写字母 数字 下划线 短横线 小数点, 末尾可以有 $
* 短横线不能在开头, 用以区分可选项和名称
* . 和 .. 不允许
* 不能重复
* 不能是纯数字, 因为一些命令同时接受 ID 和名称的形式
* 长度最多 32 位

## 为什么存在用户ID和组ID?
* 节省空间
* 提高比较的效率

## 用户ID和组ID有什么限制
* 必须大于等于 0
* 0 一般是 root 使用

## 用户的属性
* 用户名称, 用户ID, 组名称, 组ID, 附属组ID
* 主目录, 主目录模板
* 默认 shell
* 用户过期日期
* 锁定用户, 解锁用户
* 密码过期到临时不可用的时间
* 密码修改的最小最大间隔, 警告天数
* UID GID 的值一般默认即可, 不需要特殊设置

## 当前终端的登录用户
* 经过终端或伪终端登录后, 不会再变化

## 当前终端的有效用户
* 经过终端或伪终端登录后, 通过 su 可再变化

## 配置文件
```
/etc/passwd          # 用户基本信息
/etc/shadow          # 用户密码信息
/etc/group           # 组基本信息
/etc/gshadow         # 组密码信息
/etc/default/useradd # useradd 默认配置
/etc/skel/           # 默认主目录模板
/etc/subgid          # 用户隶属的 GID
/etc/subuid          # 用户隶属的 UID
/etc/login.defs      # 有关登录的配置信息
```

## 相关命令
```
useradd           # 添加用户或修改默认配置
useradd -c ...    #   指定关于用户的一段描述
useradd -e ...    #   指定用户过期日期, YYYY-MM-DD
useradd -f ...    #   指定用户密码过期到账户临时不可用的天数
useradd -g ...    #   指定主组, 主组必须存在
useradd -G ...    #   指定附属组, 附属组必须存在, 可以多个, 以逗号分割
useradd -k ...    #   指定主目录模板, 如果主目录由 useradd 创建, 模板目录中的文件将拷贝到新的主目录中
useradd -K ...    #   修改默认参数
useradd -s ...    #   指定shell
useradd -D        #   查看默认配置
useradd -D ...    #   修改默认配置
useradd    -b ... #   指明主目录的父目录, 父目录必须存在
useradd -m -b ... #   指明主目录的父目录, 父目录不必存在, 会自动新建
useradd    -d ... #   指明主目录, 主目录可以不存在, 不存在的话不会新建
useradd -m -d ... #   指明主目录, 主目录可以不存在, 不存在的话会自动新建
useradd -m ...    #   用户主目录不存在的话自动新建
useradd -M ...    #   用户主目录不会新建
useradd -N ...    #   不创建和用户同名的组
useradd -o ...    #   允许 UID 重复
useradd -r ...    #   创建系统用户
useradd -u ...    #   指定 UID 的值
useradd -U ...    #   创建和用户同名的组

userdel    ...    # 删除用户
userdel -r ...    #   删除用户及其主目录

usermod           # 修改用户
usermod -a -G ... #   添加附属组
usermod -m ...    #   移动主目录
usermod -l ...    #   修改登录名
usermod -L ...    #   锁定用户
usermod -U ...    #   解锁用户
                  #   其他选项同 useradd

newusers          # 批量新增用户

passwd            # 修改 root 密码
passwd -stdin     # 修改 root 密码, 从标准输入读取
passwd        lyb # 修改 lyb  密码

chage            # 修改密码相关信息
chage -d ... lyb # 设置上次密码修改的日期
chage -d 0   lyb # 下次登录必须修改密码
chage -E ... lyb # 设置密码过期的日期
chage -I ... lyb # 设置密码过期到账户被锁的天数
chage -m ... lyb # 设置密码修改的最小间隔
chage -M ... lyb # 设置密码修改的最大间隔
chage -W ... lyb # 设置密码过期前的警告的天数
chage -l     lyb # 列出密码相关信息

chfn             # 修改个人信息, 手机号之类
chsh -s ...      # 修改默认的 shell
chsh -l          # 列出所有支持的 shell

groups    # 列出用户所属的组名称
groupadd  # 添加组
groupmod  # 修改组信息, 包括组的ID和组名称
groupdel  # 删除组
groupmems # 管理当前用户的主组, 新增或删除成员
gpasswd   # 管理组, 新增或删除成员, 删除密码, 设置组管理人员等
newgrp    # 切换组
sg        # 使用其他组执行命令

su        # 切到 root
su -      # 切到 root, 更新主目录, 环境变量等, 相当于重新登录
su   lyb  # 切到 lyb

sudo                                          # 权限管理文件: /etc/sudoers, 使用 visudo 编辑
sudo -u USERNAME COMMAND                      # 指定用户执行命令
sudo -S date -s "20210722 10:10:10" <<< "123" # 脚本中免密码使用

sudoedit ...                                  # 编辑文件

users  # 列出所有登陆用户

w      # 列出谁登录, 以及目前在干什么
who    # 列出谁登录
who -m # 列出当前终端登录的用户
whoami # 列出当前终端的有效用户

id        # 输出实际或有效的用户和组信息

last      # 列出最近保存的登录的信息
lastb     # 列出最近保存的登录的信息, 包括失败情况

lastlog           # 列出最近一次的登录信息
lastlog -b 10     # 最近一次的登录在 10 天前的信息
lastlog -t 10     # 最近一次的登录在 10 天内的信息
lastlog -C -u lyb # 清除 lyb 最近一次的登录信息
lastlog -S -u lyb # 设置 lyb 最近一次的登录信息
lastlog    -u lyb # 查看 lyb 最近一次的登录信息
```


## 文件时间
* atime # 内容读取时间, 更新可能不及时
* mtime # 内容修改时间
* ctime # 状态修改时间: 内容 名称 权限 所属者 所属组

## 文件权限
* 读, 写, 执行
* SUID:
    * 文件执行时, 拥有此文件所有者的权限
    * 只对二进制有效
* SGID:
    * 二进制文件: 文件执行时, 拥有此文件所属组的权限
    * 目录: 新增的文件所属的组是此目录所属的组
* SBIT: 此目录下的文件只有文件或目录所有者才可以删除
* 权限判断: 依次判断所属用户, 所属组和其他权限
    * 前者失败时, 不判断后者
    * 假如 1.cc 的权限为 0070,
    * 所属主无权限, 所属组有权限时,
    * 对所属主也将判断为无权限
* 在目录下新增或删除文件时, 至少拥有此目录的写和执行权限


                  # 文件如果是符号链接, 将使用符号链接对应的文件
cat               # 输出 标准输入 的内容
cat          -    # 输出 标准输入 的内容
cat    1.txt      # 输出 1.txt 的内容, 文件支持多个
cat    1.txt -    # 输出 1.txt 和 标准输入 的内容
cat -n 1.txt      # 显示行号
cat -b 1.txt      # 显示行号, 行号不包括空行, 将覆盖参数 -n
cat -s 1.txt      # 去掉多余的连续的空行
cat -T 1.txt      # 显示 TAB
cat -E 1.txt      # 使用 $ 标明行结束的位置

chattr +i 1.c # 设置文件不可修改
chattr -i 1.c # 取消文件不可修改

chmod  755    1.c # 设置权限, 不足四位时, 补前缀 0
chmod  644 -R 1.c # 递归
chmod 4755    1.c # 设置 SUID(4)
chmod 2755    1.c # 设置 SGID(2)
chmod 1755    1.c # 设置 SBIT(1)

chown lyb:lyb 1.c # 修改文件所属的组和用户

column -t # 列对齐

                                                       # 文件如果是符号链接, 将使用符号链接对应的文件
comm                        1.c 2.c                    # 要求文件已排序, 以行比较
comm --check-order          1.c 2.c                    #   检测文件是否已排序
comm --nocheck-order        1.c 2.c                    # 不检测文件是否已排序
comm --output-delimiter=... 1.c 2.c                    # 指定列分割, 默认是 TAB
comm                        1.c 2.c       | tr -d '\t' # 全集
comm                        1.c 2.c -1 -2 | tr -d '\t' # 交集
comm                        1.c 2.c -3    | tr -d '\t' # B - A 和 A - B
comm                        1.c 2.c -1 -3              # B - A
comm                        1.c 2.c -2 -3              # A - B

cp    123 456      # 拷贝文件时, 使用符号链接所指向的文件
                   # 拷贝目录时, 目录中的符号链接将使用符号链接本身
                   # 456 只使用符号链接所指向的文件
cp -r 123 456      # 递归复制
cp -P 123 456      # 总是拷贝符号链接本身
cp -L 123 456      # 总是拷贝符号链接所指的文件
cp --parents a/b t # 全路径复制, 将生成 t/a/b

cut                        -b 2   1.c # 按字节切割, 输出第 2 个字节
cut                        -c 2-  1.c # 按字符切割, 输出 [2, 末尾] 字符
cut                        -f 2-5 1.c # 按列切割,   输出 [2,5] 列
cut -d STR                 -f 2,5 1.c # 设置输入字段的分隔符, 默认为 TAB, 输出 第 2 列和第 5 列
cut -s                     -f  -5 1.c # 不输出不包含字段分隔符的列, 输出 [开头, 5] 的列
cut --output-delimiter=STR -f  -5 1.c # 设置输出的字段分隔符, 默认使用输入的字段分隔符

diff    1.txt 2.txt # 比较两个文件的不同
diff -u 1.txt 2.txt # 一体化输出, 比较两个文件的不同


# 操作系统-日期和时间
## 基础概念
* 地球自转一圈为一天
* 地球公转一圈为一年
* 地球公转一圈时, 地球自转了 365.24219 圈, 所以, 一年等于 365.24219 天
* 为了修正误差, 区分了平年和闰年
* 规则(这样算完还有误差, 但误差就比较小了)
    * 如果遇到不是整百年, 且能被四  整除, 是闰年
    * 如果遇到  是整百年, 且能被四百整除, 是闰年
* 为什么不把一年直接定义为 365 天, 为了保证夏天始终热, 冬天始终冷, 否则就乱了
* 闰年的参照物是太阳
* 闰月的参照物是月亮
* 时间戳:
    * 距离 1970-01-01 00:00:00 +0000 的秒数, 不包括闰秒
    * 不受时区的影响, 所有时区都相同
    * 有的系统允许使用负数, 有的系统不允许

## GMT(格林威治时间)(已过时)
* 太阳经过格林威治天文台的时间为中午12点
* 这里说的一天不受地球自转速度的影响
* 地球转的快了, 一天就短, 一秒也变短, 慢了, 一天就长, 一秒也变长

## UTC(正在用)
* 原子时间: 一秒是精确的, 一天也是精确的(原子时间有误差, 但很小)
* 由于, 地球自转速度的变化, 导致和 GMT 的时间对不上, 由此, 产生了闰秒
* 好消息是: 2035 年要取消闰秒了

## 夏令时
* 进夏令时的那一天只有 23 个小时
* 出夏令时的那一天只有 25 个小时
* 其他日期都有 24 个小时
* 可以节约能源

## 时区
* 每 15 个经度一个时区
* 总共 24 个时区
* 相邻时区相差一个小时

## 配置
* /etc/default/locale -- 修改系统显示

## 常用函数
```
* time(time_t*)                                                 获取基于 1970-01-01 00:00:00 +0000 的时间戳
* struct tm*    gmtime(const time_t*)                           时间戳   --> 时间元组, +0000 utc
* struct tm* localtime(const time_t*)                           时间戳   --> 时间元组, 本地时间
* char *         ctime(const time_t*)                           时间戳   --> 字符串
* char *  asctime(const struct tm *tm)                          时间元组 --> 字符串
* size_t strftime(char*, size_t, const char*, const struct tm*) 时间元组 --> 字符串, 可以指定格式
* time     mktime(struct tm *tm)                                时间元组 --> 字符戳
* char *strptime(const char*, const char*, struct tm*)          字符串   --> 时间元组
* double difftime(time_t time1, time_t time0);                  两个时间戳的差值

time() => localtime() => strftime(): 时间戳 => 时间元组 => 字符串形式
strptime() => mktime()             : 字符串形式 => 时间元组 => 时间戳
```

## 常用命令
```
* ntpdate -s time-b.nist.gov          # 使用时间服务器更新时间

* date "+%Y-%m-%d %H:%M:%S %z"        # 输出: 年-月-日 时-分-秒 时区
* date "+%F %T %z"                    # 输出: 年-月-日 时-分-秒 时区
* date "+%j"                          # 输出: 一年中的第几天
* date "+%u"                          # 输出: 一周中的第几天(1..7), 1 为周一
* date "+%U"                          # 输出: 一年中的第几周(00..53), 从周一开始
* date "+%w"                          # 输出: 一周中的第几天(0..6), 0 为周末
* date "+%W"                          # 输出: 一年中的第几周(00..53), 从周末开始
* date "+%s"                          # 输出: 时间戳
* date -d "2020-02-02 01:01:01 +0800" # 指定输入日期和时间, 秒数不能为 60
* date -d "@...."                     # 使用: 时间戳
* date -d "next sec"                  # 下一秒
* date -d "next secs"                 # 下一秒
* date -d "next second"               # 下一秒
* date -d "next seconds"              # 下一秒
* date -d "next min"                  # 下一分钟
* date -d "next mins"                 # 下一分钟
* date -d "next minute"               # 下一分钟
* date -d "next minutes"              # 下一分钟
* date -d "next hour"                 # 下一小时
* date -d "next hours"                # 下一小时
* date -d "next day"                  # 明天
* date -d "next days"                 # 明天
* date -d "next mon"                  # 下周一
* date -d "next monday"               # 下周一
* date -d "next month"                # 下个月
* date -d "next months"               # 下个月
* date -d "next year"                 # 下年
* date -d "next years"                # 下年
* date -d "next year  ago"            # 去年, 除年外, 其他也可以
* date -d "next years ago"            # 去年, 除年外, 其他也可以
* date -d "10year"                    # 十年以后, 除年外, 其他也可以
* date -d "10years"                   # 十年以后, 除年外, 其他也可以
* date -d "10   year"                 # 十年以后, 除年外, 其他也可以
* date -d "10   years"                # 十年以后, 除年外, 其他也可以
* date -d "10   year  ago"            # 十年以前, 除年外, 其他也可以
* date -d "10   years ago"            # 十年以前, 除年外, 其他也可以
* date -d "tomorrow"                  # 明天
* date -d "now"                       # 现在
* date -s "2020-02-02 10:10:10"       # 更新系统时间, 需要 root, 格式见 -d 选项
* date -r 1.c                         # 使用: 文件的 mtime

       %A        %a
星期日 sunday    sun
星期一 monday    mon
星期二 tuesday   tue
星期三 wednesday wed
星期四 thursday  thu
星期五 friday    fri
星期六 saturday  sat

       %B         %b
一月   january    jan
二月   february   feb
三月   march      mar
四月   april      apr
五月   may        may
六月   june       jun
七月   july       jul
八月   august     aug
九月   september  sep
十月   october    oct
十一月 november   nov
十二月 december   dec
```


# 计算机网络-内网穿透
指的是位于 NAT 之后的机器, 相互连接的问题(P2P)

## NAT 用途
* 子网机器 => NAT => 互联网或其他网络
* 可以解决 IPv4 地址短缺的问题(使用一个IP地址可以让子网内的用户都可以上网)
* 可以使得访问更安全(通过 NAT 过滤)

## NAT 类型
### 基础NAT(只修改 IP)(基本不用)
### NAPT(修改IP和端口号)
* 完全圆锥形NAT(Full cone NAT)
    1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
    2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
    3. 任何外网机器的任何端口号都可通过NAT(D:X1)向内网机器(A:X)发送数据(任意IP, 任意端口号)
* 受限圆锥形NAT(Address-Restricted cone NAT)
    1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
    2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
    3. 外网机器(B)的任何端口号都可通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 任意端口号)
* 端口受限圆锥形NAT(port-Restricted cone NAT)
    1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
    2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
    3. 外网机器(B:Y)才可以通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 同端口号)
* 对称NAT(Symmetric NAT)
    1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
    2. 那么, 内网机器(A:X)通过NAT(D:X2)发送数据给公网机器(B:Z), X1 != X2 (IP 相同, 端口号不同)
    3. 那么, 内网机器(A:X)通过NAT(D:X3)发送数据给公网机器(C:Y), X1 != X3 (IP 不同, 端口号相同)
    4. 那么, 内网机器(A:X)通过NAT(D:X4)发送数据给公网机器(C:Z), X1 != X4 (IP 不同, 端口号不同)
    5. 外网机器(B:Y)才可以通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 同端口号)
    6. 外网机器(B:Z)才可以通过NAT(D:X2)向内网机器(A:X)发送数据(同IP, 同端口号)
    7. 外网机器(C:Y)才可以通过NAT(D:X3)向内网机器(A:X)发送数据(同IP, 同端口号)
    8. 外网机器(C:Z)才可以通过NAT(D:X4)向内网机器(A:X)发送数据(同IP, 同端口号)

## 检测NAT的类型(需要公网机器(B:Y), 公网机器(C:Z))
0. 内网机器(A:X)给公网机器(B:Y)发送数据
1. 公网机器(B:Y)返回内网机器(A:X)的地址: D:X1
2. 如果 D == A && X1 == X, 则为公网 IP
3. 否则, 公网机器(C:Z)通过NAT(D:X1)给内网机器(A:X)发送消息(IP和端口号都不同)
4. 如果内网机器(A:X)可以收到消息，则为 完全圆锥形 NAT
5. 否则, 公网机器(B:Z)通过NAT(D:X1)给内网机器(A:X)发送消息(IP相同, 端口号不同)
6. 如果内网机器(A:X)可以收到消息，则为 受限圆锥形 NAT
7. 否则, 内网机器(A:X)给公网机器(C:Z)发送数据
8. 公网机器(C:Z)返回内网机器的地址: D:X2
9. 如果 X1 == X2, 则为 端口受限圆锥形 NAT, 否则为对称 NAT

## P2P 通信
### 通过公共机器直接通信(不受任何NAT类型的限制, 但效率比较低, 会给服务器造成很大的消耗)
* 内网机器(A)与公网机器器(C)相连
* 内网机器(B)与公网机器器(C)相连
* 内网机器(A)将数据发给公网机器(C), 公网机器(C)再将数据发送给内网机器(B)
* 内网机器(B)将数据发给公网机器(C), 公网机器(C)再将数据发送给内网机器(A)

### 机器(A:X)和机器(B:Y)都是公网IP
两个机器可以直接相连

### 机器(A:X)或机器(B:Y)只有一个是公网IP
* 假设, 机器(A:X)有公网IP
* 通过 机器(B:Y) => NAT(E:Q) => 机器(A:X) 发送数据, 因为机器(A:X)为公网IP
* 此时 机器(A:X) => NAT(E:Q) => 机器(B:Y) 也通了

### 机器(A:X)和机器(B:Y)位于不同 NAT, 有一个公网机器(C:Y)
1. 机器(A:X)或机器(B:Y)所属的 NAT 为完全锥形 NAT
    * 假定机器(A:X)所属的 NAT 为完全锥形 NAT
    * 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
    * 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
    * 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送数据NAT(D:P)
    * 通过 机器(B:Y) => NAT(E:R) => NAT(D:P) => 机器(A:X) 发送数据(完全锥形 NAT)
    * 此时 机器(A:X) => NAT(D:P) => NAT(E:R) => 机器(B:Y) 也通了
2. 机器(A:X)或机器(B:Y)所属的 NAT 为受限锥形 NAT
    * 假定机器(A:X)所属的 NAT 为受限锥形 NAT
    * 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
    * 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
    * 通过 公网机器(C:Z) => NAT(D:P) => 机器(A:X) 发送数据NAT(E:Q)
    * 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送数据NAT(D:P)
    * 通过 机器(A:X) => NAT(D:P) => NAT(E:Q) 发送数据, 会被丢弃
        * 因为NAT(E:Q) 不知道数据要发往哪里
        * 但 NAT(E) => NAT(D:P) => 机器(A:X) 这条路已经通了,
        * 此时, NAT(E)的任何端口号都通过 NAT(D:P)=>机器(A:X) 发送数据(受限锥形 NAT)
    * 通过 机器(B:Y) => NAT(E:R) => NAT(D:P) => 机器(A:X) 发送数据, 会成功,
        * 因为NAT(E) => NAT(D:P) => 机器(A:X) 是通的
    * 此时, 机器(A:X) => NAT(D:P) => NAT(E:R) => 机器(B:Y) 也通了
3. 机器(A:X)和机器(B:Y)所属的 NAT 均为端口受限锥形 NAT
    * 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
    * 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
    * 通过 公网机器(C:Z) => NAT(D:P) => 机器(A:X) 发送数据NAT(E:Q)
    * 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送数据NAT(D:P)
    * 通过 机器(A:X) => NAT(D:P) => NAT(E:Q) 发送数据, 会被丢弃
        * 因为NAT(E:Q) 不知道数据要发往哪里
        * 但 NAT(E:Q) => NAT(D:P) => 机器(A:X) 这条路已经通了(端口受限锥形 NAT)
    * 通过 机器(B:Y) => NAT(E:Q) => NAT(D:P) => 机器(A:X) 发送数据, 会成功,
        * 因为机器NAT(E:Q) => NAT(D:P) => 机器(A:X) 是通的
    * 此时, 机器(A:X) => NAT(D:P) => NAT(E:Q) => 机器(B:Y)  也通了
4. 机器(A:X)和机器(B:Y)所属的 NAT 均为对称 NAT
    * 无法穿透
    * 可以考虑通过公网机器发送数据
5. 机器(A:X)和机器(B:Y)所属的 NAT 一个为对称 NAT，一个为端口受限的 NAT
    * 无法穿透
    * 可以考虑通过公网机器发送数据

# 计算机网络
## 基础知识
```
硬盘: 1T = 1000G = 1000 * 1000 * 1000 * 1000B = ... / 1024 / 1024 /1024 GB = 931GB
网卡: 1000M = 1000Mbps = 125MB (网速也一样)

  带宽: 网速, 上限由网卡控制
吞吐量: 有效数据的速度, 速度小于带宽
  延时: 客户端发送数据到收到数据的时差

kmg(1000), KMG(1024), B(字节), b(位)

## 网络接口层(帧)(以太网)
### 为什么不能去掉MAC(48位, 一般无法改变)
1. 网络协议分层, 不同层实现不同的功能, 交换机会使用其传递数据
2. 直接使用IP其实也可以, 这个就是历史原因了

### 集线器: 无脑转发数据到所有出口(很少使用了)
* 机器收到不是自己的数据将丢弃

### 交换机: 将指定数据直接发送到目标机器
* 利用MAC地址表发送数据到指定机器, 找不到时, 将发送数据给所有机器
* 到达的数据需要知道目标的MAC地址
* 机器数量过大时, 会很难处理

### 通过MAC可以区分是单播还是(组播或广播)

## 网络层(数据包)
###为什么不能去掉IP(32位)
1. 为了划分子网, 方便路由, 传送数据到子网

* 主机号都为 0 表明网络地址
* 主机号都为 1 表明广播地址
* 互联网上只能使用公有IP
* 子网: 由 IP 和子网掩码(主机号都为0)确定
* 默认网关: 用于路由
* ARP: IP => MAC (ARP 缓存表)

### ICMP(不使用端口号, 和 TCP UDP IGMP处于同一级)
* 传输控制协议
* ping 实现

IGMP

1.0.0.0~126.255.255.255   -- a类
128.0.0.0~191.255.255.255 -- b类
192.0.0.0~223.255.255.255 -- c类
224.0.0.0~239.255.255.255 -- 组播地址
240.0.0.0~255.255.255.254 -- 保留
10.0.0.0/8                -- a类私有
172.16.0.0/12             -- b类私有
192.168.0.0/16            -- c类私有
127.0.0.0/8               -- 本机使用
224.0.0.0/24              -- 本网络组播
239.0.0.0/8               -- 私有组播

0.0.0.0                   -- 使用 DHCP 获取 IP 时, 填的源 IP
255.255.255.255           -- 使用 DHCP 获取 IP 时, 填的目标 IP

路由器: 将指定数据直接发送到目标(可能需要再次转发)
* 利用路由表发送数据到指定机器, 找不到将发送到路由器的默认网关
* 到达的数据需要知道目标的 IP 地址

单播(一般的网络服务都是单播)
1. 源IP和目标IP属于同一个子网时, 利用arp获取目标的MAC, 然后利用交换机发送数据到指定机器
2. 否则, 利用arp获取默认网关的MAC, 然后利用交换机发送数据到默认网关
3. 默认网关会修改源MAC, 然后再查找下一跳或指定机器

数据传输过程中, 原 IP 和目标 IP 一般不变, 除了, NAT 等

组播(IGMP 直播 电视)
1. 组播源注册: 服务器(组播源IP)向中介机构(RP)注册组播IP(2.2.2.2)
2. 客户端向中介机构(RP)申请加入组播IP: 生成基于中介机构(RP)的树(RPT), 同时获取组播源IP
3. 客户端向服务器(组播源IP)申请加入组播IP: 生成基于源的树(SPT), 废弃掉 RPT(SPT路径更优)
4. 服务器通过SPT, 向所有的注册组播IP的用户发送数据
    * 源IP和MAC填自己的数据
    * 目的IP为组播地址
    * 目的MAC为: 01:00:5e + 组播IP 地址低 23 bit(区分单播 组播 广播)
    * 由于目的IP为组播IP, 无法获取确切的MAC, 指定某一机器, 所以只能采用广播向所有机器发送数据
5. 客户端或者路由器通过接收到的数据的组播地址来确定是不是自己所需要的数据

广播(ARP, 使用DHCP申请IP地址时)
利用集线器发送所有数据到当前网络的所有机器

任播: 最近或最合适的客户

### 传输层(段)(TCP UDP)
端口号(16位)
* [0, 1024)      公认端口号, 需要 root 启动, 比如 80
* [1024, 32768)  注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
                 可通过文件 /proc/sys/net/ipv4/ip_local_port_range 获取
* [60990, 65535) 可能有特殊用途

TCP 有广播和组播一说吗?

TCP
* 三次握手
    1. 客户端将随机的序列号发送给服务端(SYN)(CLOSED -> SYN-SENT)
    2. 服务端收到数据后, 知道了客户端的序列号
       服务端将自己随机的序列号以及客户端序列号加一返回给客户端(SYN ACK)(LISTEN -> SYN-RCVD)
    3. 客户端收到数据后, 认为连接已经建立成功了
       客户端将服务端的序列号加一发送给服务端(ACK)(SYN-SENT -> ESTABLISHED)
       此时客户端就可以发送数据了
    4. 服务端收到数据后, 认为连接已经建立成功了, 可以发送数据了(SYN-RCVD -> ESTABLISHED)
* 四次挥手(服务端也可以先发起)
    1. 客户端发送 FIN(ESTABLISHED -> FIN-WAIT-1)
    2. 服务端收到 FIN(ESTABLISHED -> CLOSE-WAIT
       服务端向客户端发送确认
       客户端收到确认(FIN-WAIT-1 -> FIN-WAIT-2)
       此时, 客户端不能再向服务端发送数据, 但服务端可以向客户端发送数据
    3. 服务端发送 FIN(CLOSE-WAIT -> LAST-ACK)
    4. 客户端收到 FIN(FIN-WAIT-2 -> TIME-WAIT)
       向服务端发送确认
       等待 2MSL, 客户端(TIME-WAIT -> CLOSED)
       (为了处理服务端可能收不到确认的情况, 也为了让游离在外的包尽可能消亡)
       服务端收到确认(LAST-ACK -> CLOSED)
* 为什么需要序列号(32位):
    * 数据包需要被确认, 而包可能会被拆, 需要使用序列号来判断确认到哪个数据包了
    * 数据包可能会丢失, 需要使用序列号来判断需要重发哪个数据包
    * 数据包可能会重复, 需要使用序列号来丢弃重复的数据包
    * 数据包到达的时间, 顺序可能不同, 需要使用序列号排序
* 初始序列号为什么随机生成:
    * 随机序列号很难猜测, 为了避免其他人冒充对方报文, 或 伪造reset报文, 影响正常的使用
    * 为了避免旧数据影响新连接, 例如
        客户端连接服务端
        客户端向服务端发送一个数据包(由于网络问题, 数据包发了两次, 有游离包在网络中)
        客户端向服务端发送 reset, 立刻退出(没有经过正常的四次挥手)
        此时, 客户端使用相同的IP和端口号重新连服务端, 并成功
        此时, 游离的包到达服务端,
        如果初始话序列号相同, 此游离包  在服务端的接收窗口内, 会被误认为是新的数据包, 而返回确认
        如果初始话序列号不同, 此游离包不在服务端的接收窗口内, 会被丢弃(极大概率)
* 序列号回绕:
    初始化序列号每4微妙增长一个, 即, 每秒增长 250000 个, 循环一次需要 4 个多小时
    远大于数据包的最大分段的时间(MSL)(一般两分钟)
    所以不会对数据造成影响, 而发送的数据大小不受序列号的限制
* 所有有数据的报文都需要ack, 也可能会重传
* 报文类型
    *   SYN: 三次握手(需要确认, 可能会重传)
    *   FIN: 四次挥手(需要确认, 可能会重传)
    *  data: 数据报文(需要确认, 可能会重传)
    * reset: 重置(不需要确认,   不会重传)(发送重置后, 内核会销毁掉所有的连接信息, 对方的确认没意义)
    *   ACK: 确认(不需要确认,   不会重传)(如果确认的话就死循环了)(不包含数据)(下一个期望的序列号)
    *   ACK: 确认(  需要确认, 可能会重传)(如果确认的话就死循环了)(  包含数据)(下一个期望的序列号)
* SYN 和 FIN 为什么占一个序列号: 为了处理可能的重传
* reset 发送场景:
    * 客户端连接服务端, 而服务端的此端口没有被监听, 会返回 rst
    * 客户端连接服务端, 被防火墙连接(不一定, 可能收到 ICMP 错误)
    * 当接收缓冲区内还有数据, 但关闭了改 socket, 会向对方发送 rst
    * 向已关闭的 socket 发送数据, 对方会返回 rst
* 为什么需要三次握手:
    1. 一次握手: 客户端发送连接, 即认为连接成功, 服务端收到连接, 即认为连接成功
                 由于客户端无法知道服务端的序列号, 也就没有序列号这一说了,
                 TCP 的包不能拆分了(无法确认数据包的先后), 也就没有确认机制了(无法确认),
                 直接相当于 UDP 了
    2. 两次握手: 客户端发送连接
                 服务端收到连接, 并返回确认, 此时, 服务端认为连接成功了
                 客户端收到确认, 认为连接成功了
                 * 如果客户端的连接包丢失了, 由于无法收到确认包, 所以会重新发送连接包
                 * 如果服务端的确认包丢失了, 服务端感知不到这种情况,
                     由于客户端接收不到确认包, 所以客户端仍然会重新发送连接包
                 * 旧的连接包会影响服务端的使用, 例如,
                        客户端连接服务端(由于网络问题, 连接包发了两次, 有一个游离包在网络中)
                        服务端返回确认
                        客户端收到确认, 向服务端发送 reset, 立刻退出(没有经过正常的四次挥手)
                        此时, 游离的包到达服务端, 服务端认为是新的连接, 向客户端发送确认
                        客户端收到子虚乌有的确认直接丢弃了
                        (客户端可以考虑发送 reset 让服务端释放资源也成, 客户端不存在或不可达也还是有问题)
                        服务端直到发送数据, 才能知道连接不成功(不发送的话, 一直浪费)
    3. 三次握手: 客户端发送连接
                 服务端收到连接, 并返回确认
                 客户端收到确认, 并返回确认, 认为连接成功了
                 服务端收到确认, 认为连接成功了
                 * 如果客户端的连接包丢失了, 由于无法收到确认包, 所以会重新发送
                 * 如果服务端的确认包丢失了, 由于无法收到确认包, 所以会重新发送
                 * 旧的连接包不会影响服务端的使用, 例如,
                        客户端连接服务端(由于网络问题, 连接包发了两次, 有一个游离包在网络中)
                        服务端返回确认
                        客户端收到确认, 向服务端发送 reset, 立刻退出(没有经过正常的四次挥手)
                        此时, 游离的包到达服务端, 服务端认为是新的连接, 向客户端发送确认
                        客户端收到子虚乌有的确认直接丢弃了(客户端也可以考虑发送 reset)
                        服务端没收到确认消息, 会多次发送, 最终放弃, 释放资源
    4. 其实, 两次握手也能成功, 兼顾效率和可靠性, 选择三次握手(主要是网络出问题的情况)
      * 三次握手保证双方都知道对方是可收可发的(保证是可用的, 不一定是可靠的)


UDP

### 应用层(消息)(HTTP DNS SSH DHCP)
DHCP(广播, UDP)
1. 新机器(IP: 0.0.0.0)发送信息给当前网络(IP: 255.255.255.255)的所有机器(不会跨网关)
2. 包含 DHCP 服务器的机器发送新的 IP 给新机器(IP: 255.255.255.255)
3. 新机器(IP: 新IP)发送确认信息给 DHCP 服务器

### 浏览器输入 https://www.bing.com 后的行为
1. 解析 www.bing.com. 找到域名 bing.com. 查找对应 IP, 顺序查找,
    * DNS cache
    * 本地 host 文件
    * DNS 服务器(8.8.8.8, 找不到的话, 会递归查找, 直到根域名服务器)
2. 使用目标 IP 和端口号三次握手
3. TLS 商讨密钥的方案
4.

### 防火墙
包过滤防火墙: 过滤某些不必要的流量, 依靠 IP 端口号 协议类型(ICMP)
代理防火墙: http 代理
            socks 代理

真正的路由器应该只有路由的功能

### NAT(Network Address Translation)
主要目的是解决 IPv4 地址短缺的问题以及安全

分类
* 基础NAT: 只修改 IP
* NAPT: 修改IP和端口号
	1. 完全圆锥形NAT(Full cone NAT)
		1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
		2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
		3. 任何外网机器的任何端口号都可通过NAT(D:X1)向内网机器(A:X)发送数据(任意IP, 任意端口号)
	2. 受限圆锥形NAT(Address-Restricted cone NAT)
		1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
		2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
		3. 外网机器(B)的任何端口号都可通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 任意端口号)
	3. 端口受限圆锥形NAT(port-Restricted cone NAT)
		1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
		2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
		3. 外网机器(B:Y)才可以通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 同端口号)
	4. 对称NAT(Symmetric NAT)
		1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
		2. 那么, 内网机器(A:X)通过NAT(D:X2)发送数据给公网机器(B:Z), X1 != X2 (IP 相同, 端口号不同)
		3. 那么, 内网机器(A:X)通过NAT(D:X3)发送数据给公网机器(C:Y), X1 != X3 (IP 不同, 端口号相同)
		4. 那么, 内网机器(A:X)通过NAT(D:X4)发送数据给公网机器(C:Z), X1 != X4 (IP 不同, 端口号不同)
		5. 外网机器(B:Y)可以通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 同端口号)
		6. 外网机器(B:Z)可以通过NAT(D:X2)向内网机器(A:X)发送数据(同IP, 同端口号)
		7. 外网机器(C:Y)可以通过NAT(D:X3)向内网机器(A:X)发送数据(同IP, 同端口号)
		8. 外网机器(C:Z)可以通过NAT(D:X4)向内网机器(A:X)发送数据(同IP, 同端口号)

检测NAT的类型
0. 内网机器(A:X)给公网机器(B:Y)发送数据
1. 公网机器(B:Y)返回内网机器(A:X)的地址: D:X1
2. 如果 D == A && X1 == X, 则为公网 IP
3. 否则, 公网机器(C:Z)通过NAT(D:X1)给内网机器(A:X)发送消息(IP和端口号都不同)
4. 如果内网机器(A:X)可以收到消息，则为 完全圆锥形 NAT，
5. 否则, 公网机器(B:Z)通过NAT(D:X1)给内网机器(A:X)发送消息(IP相同, 端口号不同)
6. 如果内网机器(A:X)可以收到消息，则为 受限圆锥形 NAT,
7. 否则, 内网机器(A:X)给公网机器(C:Z)发送数据
8. 公网机器(C:Z)返回内网机器的地址: D:X2
9. 如果 X1 == X2, 则为 端口受限圆锥形 NAT, 否则为对称 NAT

## p2p 通信
### 机器(A:X)和机器(B:Y)都是公网IP
两个机器可以直接相连

### 机器(A:X)或机器(B:Y)只有一个是公网IP
* 假设, 机器(A:X)有公网IP
* 通过 机器(B:Y) => NAT(E:Q) => 机器(A:X) 发送数据, 因为机器(A:X)为公网IP
* 此时 机器(A:X) => NAT(E:Q) => 机器(B:Y) 也通了

### 机器(A:X)和机器(B:Y)位于不同 NAT, 有一个公网机器(C:Y)
1. 机器(A:X)或机器(B:Y)所属的 NAT 为完全锥形 NAT
	* 假定机器(A:X)所属的 NAT 为完全锥形 NAT
	* 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
	* 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
	* 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送NAT(D:P)数据
	* 通过 机器(B:Y) => NAT(E:R) => NAT(D:P) => 机器(A:X) 发送数据(完全锥形 NAT)
	* 此时 机器(A:X) => NAT(D:P) => NAT(E:R) => 机器(B:Y) 也通了
2. 机器(A:X)或机器(B:Y)所属的 NAT 为受限锥形 NAT
	* 假定机器(A:X)所属的 NAT 为受限锥形 NAT
	* 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
	* 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
	* 通过 公网机器(C:Z) => NAT(D:P) => 机器(A:X) 发送NAT(E:Q)数据
	* 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送NAT(D:P)数据
	* 通过 机器(A:X) => NAT(D:P) => NAT(E:Q) => 机器(B:Y) 发送数据, 会失败
		* 因为机器(B:Y) => NAT(E:Q) => NAT(D:P) => 机器(A:X) 未发送过消息
		* 但 NAT(E) => NAT(D:P) => 机器(A:X) 这条路已经通了,
		* 此时, NAT(E)的任何端口号都通过 NAT(D:P)=>机器(A:X) 发送数据(受限锥形 NAT)
	* 通过 机器(B:Y) => NAT(E:R) => NAT(D:P) => 机器(A:X) 发送数据, 会成功,
		* 因为机器(A:X) => NAT(D:P) => NAT(E) 路是通的
	* 此时, 机器(A:X) => NAT(D:P) => NAT(E:R) => 机器(B:Y) 也通了
3. 机器(A:X)和机器(B:Y)所属的 NAT 均为端口受限锥形 NAT
	* 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
	* 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
	* 通过 公网机器(C:Z) => NAT(D:P) => 机器(A:X) 发送NAT(E:Q)数据
	* 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送NAT(D:P)数据
	* 通过 机器(A:X) => NAT(D:P) => NAT(E:Q) => 机器(B:Y) 发送数据, 会失败,
		* 因为机器(B:Y) => NAT(E:Q) => NAT(D:P) 未发送过消息
		* 但 NAT(E:Q) => NAT(D:P) => 机器(A:X) 这条路已经通了(端口受限锥形 NAT)
	* 通过 机器(B:Y) => NAT(E:Q) => NAT(D:P) => 机器(A:X) 发送数据, 会成功,
		* 因为机器NAT(E:Q) => NAT(D:P) => 机器(A:X) 是通的
	* 此时，机器(A:X) => NAT(D:P) => NAT(E:Q) => 机器(B:Y)  也通了
4. 机器(A:X)和机器(B:Y) 所属的 NAT 均为对称 NAT: 无法穿透
5. 机器(A:X)和机器(B:Y)所属的 NAT 一个为对称 NAT，一个为端口受限的 NAT: 无法穿透


p2p 通信(客户端(A)位于NAT(a)后, 客户端(B)位于NAT(b)后, 服务器(C)位于公网, 客户端(A)和客户端(B)要通信)
1. 通过服务器(c)直接通信:(不受任何NAT类型的限制, 但效率比较低, 会给服务器造成很大的消耗)(TCP)
	客户端(A)通过NAT(a)与服务器(C)相连
	客户端(B)通过NAT(b)与服务器(C)相连
	客户端(A)将数据发给服务器(C), 服务器(C)再将数据发送给客户端(B)
	客户端(B)将数据发给服务器(C), 服务器(C)再将数据发送给客户端(A)

UDP-打洞(客户端A位于局域网a, 客户端B位于局域网b, 服务器C位于公网, 客户端A和客户端B要通信)
1. 全锥形NAT

	假设, 内网机器(A:X), 公网机器(B:Y), 公网机器(C:Z)
如果内网机器(A:X)发送数据给公网机器(B:Y), 则映射的公网接口(D:X1)
如果内网机器(A:X)发送数据给公网机器(C:Z), 则映射的公网接口(D:X2)

## UDP hole punching
	### 方法
假设有两个客户 A:X B:Y 位于不同的 NAT 中，还有一个处于公网的服务器 C:Z

假设: X:x(私有) -> X1:x1(NAT) -> Y1:y1(公有)
此时, 如果, 新连接: X:x(私有) -> X2:x2(NAT) -> Y2:y2(公有)(X1 == X2)
1. 对于任何 Y1:y1 和 Y2:y2, X1:x1 都等于 X2:x2, 即: X:x 发向任何地址的数据都使用 NAT 的 X1:x1 (任何地址)
2. 如果 Y1 == Y2, 则 X1:x1 == X2:x2, 即: X:x 只有发往 Y1 的数据才使用 NAT 的 X1:x1 (IP 相同)
3. 如果 Y1:y1 == Y2:y2, 则 X1:x1 == X2:x2, 即: X:x 只有发往 Y1:y1 的数据才使用 NAT 的 X1:x1 (IP 和 端口号都相同)
此时, 如果, Y3:y3(私有) -> X1:x1(NAT) -> X:x(私有)
1. 对于任何 Y3:y3, 都可以发送成功(全锥形NAT)(任意)
2. 只要 Y3 == Y1, 就可以发送成功(受限圆锥形NAT)(IP相同)
3. 只有 Y3:y3 == Y1:y1, 才可以发送成功(端口受限圆锥形NAT)(IP和端口号都相同)
4.

链路层广播

MTU 最大传输单元 (链路层)

p2p

网络层:

强主机模式: 数据包必须和对应网络接口对上
弱主机模式: 数据包和任一网络接口对上即可


## 网络
* [0, 1024)      公认端口号, 需要 root 启动, 比如 80
* [1024, 32768)  注册端口, 可以自己注册一些常用服务
* [32768, 60990) 动态端口, 进程未指定端口号时, 将从这个范围内获取一个端口号
                 可通过文件 /proc/sys/net/ipv4/ip_local_port_range 获取
* [60990, 65535)


防火墙:
包过滤防火墙: 过滤某些不必要的流量, 依靠 IP 端口号 协议类型(ICMP)
代理防火墙: http 代理
            socks 代理

真正的路由器应该只有路由的功能

# NAT
## NAT(Network Address Translation)
主要目的是解决 IPv4 地址短缺的问题

## 分类
* 基础NAT: 只修改 IP
* NAPT: 修改IP和端口号
	1. 完全圆锥形NAT(Full cone NAT)
		1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
		2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
		3. 任何外网机器的任何端口号都可通过NAT(D:X1)向内网机器(A:X)发送数据(任意IP, 任意端口号)
	2. 受限圆锥形NAT(Address-Restricted cone NAT)
		1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
		2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
		3. 外网机器(B)的任何端口号都可通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 任意端口号)
	3. 端口受限圆锥形NAT(port-Restricted cone NAT)
		1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
		2. 那么, 内网机器(A:X)发往任何机器的任何端口号的数据都会通过NAT(D:X1)发送
		3. 外网机器(B:Y)才可以通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 同端口号)
	4. 对称NAT(Symmetric NAT)
		1. 如果内网机器(A:X)通过NAT(D:X1)发送数据给公网机器(B:Y)
		2. 那么, 内网机器(A:X)通过NAT(D:X2)发送数据给公网机器(B:Z), X1 != X2 (IP 相同, 端口号不同)
		3. 那么, 内网机器(A:X)通过NAT(D:X3)发送数据给公网机器(C:Y), X1 != X3 (IP 不同, 端口号相同)
		4. 那么, 内网机器(A:X)通过NAT(D:X4)发送数据给公网机器(C:Z), X1 != X4 (IP 不同, 端口号不同)
		5. 外网机器(B:Y)可以通过NAT(D:X1)向内网机器(A:X)发送数据(同IP, 同端口号)
		6. 外网机器(B:Z)可以通过NAT(D:X2)向内网机器(A:X)发送数据(同IP, 同端口号)
		7. 外网机器(C:Y)可以通过NAT(D:X3)向内网机器(A:X)发送数据(同IP, 同端口号)
		8. 外网机器(C:Z)可以通过NAT(D:X4)向内网机器(A:X)发送数据(同IP, 同端口号)

## 检测NAT的类型
0. 内网机器(A:X)给公网机器(B:Y)发送数据
1. 公网机器(B:Y)返回内网机器(A:X)的地址: D:X1
2. 如果 D == A && X1 == X, 则为公网 IP
3. 否则, 公网机器(C:Z)通过NAT(D:X1)给内网机器(A:X)发送消息(IP和端口号都不同)
4. 如果内网机器(A:X)可以收到消息，则为 完全圆锥形 NAT，
5. 否则, 公网机器(B:Z)通过NAT(D:X1)给内网机器(A:X)发送消息(IP相同, 端口号不同)
6. 如果内网机器(A:X)可以收到消息，则为 受限圆锥形 NAT，否则,
7. 内网机器(A:X)给公网机器(C:Z)发送数据
8. 公网机器(C:Z)返回内网机器的地址: D:X2
9. 如果 X1 == X2, 则为 端口受限圆锥形 NAT, 否则为对称 NAT

## p2p 通信
### 机器(A:X)和机器(B:Y)都是公网IP
两个机器可以直接相连

### 机器(A:X)或机器(B:Y)只有一个是公网IP
* 假设, 机器(A:X)有公网IP
* 由于, 机器(A:X)有公网IP, 所以机器(B:Y) => NAT(E:Q) => 机器(A:X) 可以发送数据
* 由于, 机器(B:Y) => NAT(E:Q) => 机器(A:X) 连接过, 所以, 机器(A:X) => NAT(E:Q) => 机器(B:Y) 也通了

### 机器(A:X)和机器(B:Y)位于不同 NAT, 有一个公网机器(C:Y)
1. 机器(A:X)或机器(B:Y)所属的 NAT 为完全锥形 NAT
	* 假定机器(A:X)所属的 NAT 为完全锥形 NAT
	* 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
	* 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
	* 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送NAT(D:P)数据
	* 此时 机器(B:Y) => NAT(E:R) => NAT(D:P) => 机器(A:X) 就通了(完全锥形 NAT)
	* 此时 机器(A:X) => NAT(D:P) => NAT(E:R) => 机器(B:Y) 也通了
2. 机器(A:X)或机器(B:Y)所属的 NAT 为受限锥形 NAT
	* 假定机器(A:X)所属的 NAT 为受限锥形 NAT
	* 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
	* 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
	* 通过 公网机器(C:Z) => NAT(D:P) => 机器(A:X) 发送NAT(E:Q)数据
	* 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送NAT(D:P)数据
	* 通过 机器(A:X) => NAT(D:P) => NAT(E:Q) => 机器(B:Y) 发送数据, 会失败
		* 因为机器(B:Y) => NAT(E:Q) => NAT(D:P) 未发送过消息
		* 但 NAT(E) => NAT(D:P) => 机器(A:X) 这条路已经通了,
		* 此时, NAT(E)的任何端口号都通过 NAT(D:P)=>机器(A:X) 发送数据(受限锥形 NAT)
	* 通过 机器(B:Y) => NAT(E:R) => NAT(D:P) => 机器(A:X) 发送数据, 会成功,
		* 因为机器(A:X) => NAT(D:P) => NAT(E) 路是通的
		* 此时, 机器(A:X) => NAT(D:P) => NAT(E:R) => 机器(B:Y) 也通了
3. 机器(A:X)和机器(B:Y)所属的 NAT 均为端口受限锥形 NAT
	* 通过 机器(A:X) => NAT(D:P) => 公网机器(C:Z) 发送数据
	* 通过 机器(B:Y) => NAT(E:Q) => 公网机器(C:Z) 发送数据
	* 通过 公网机器(C:Z) => NAT(D:P) => 机器(A:X) 发送NAT(E:Q)数据
	* 通过 公网机器(C:Z) => NAT(E:Q) => 机器(B:Y) 发送NAT(D:P)数据
	* 通过 机器(A:X) => NAT(D:P) => NAT(E:Q) => 机器(B:Y) 发送数据, 会失败,
		* 因为机器(B:Y) => NAT(E:Q) => NAT(D:P) 未发送过消息
		* 但 NAT(E:Q) => NAT(D:P) => 机器(A:X) 这条路已经通了(端口受限锥形 NAT)
	* 通过 机器(B:Y) => NAT(E:Q) => NAT(D:P) => 机器(A:X) 发送数据, 会成功,
		* 因为机器NAT(E:Q) => NAT(D:P) => 机器(A:X) 是通的
	* 此时，机器(A:X) => NAT(D:P) => NAT(E:Q) => 机器(B:Y)  也通了
4. 机器(A:X)和机器(B:Y) 所属的 NAT 均为对称 NAT: 无法穿透
5. 机器(A:X)和机器(B:Y)所属的 NAT 一个为对称 NAT，一个为端口受限的 NAT: 无法穿透


1. 客户 A:X 通过 D:P 多次发送数据给 C:Z
2. 客户 B:Y 通过 E:Q 多次发送数据给 C:Z
3. 服务器 C:Z 将 A:X 的映射的 D:P 多次发送给 B:Y
4. 服务器 C:Z 将 B:Y 的映射的 E:Q 多次发送给 A:X
5. 客户 A:X 多次发送数据给 E:Q
6. 在此之后，客户 B:Y   可以通过 E:Q --> D:P 给客户 A:X 发送消息
7. 在此之后，客户 A:X 也可以通过 D:P --> E:Q 给客户 B:Y 发送消息



p2p 通信(客户端(A)位于NAT(a)后, 客户端(B)位于NAT(b)后, 服务器(C)位于公网, 客户端(A)和客户端(B)要通信)
1. 通过服务器(c)直接通信:(不受任何NAT类型的限制, 但效率比较低, 会给服务器造成很大的消耗)(TCP)
	客户端(A)通过NAT(a)与服务器(C)相连
	客户端(B)通过NAT(b)与服务器(C)相连
	客户端(A)将数据发给服务器(C), 服务器(C)再将数据发送给客户端(B)
	客户端(B)将数据发给服务器(C), 服务器(C)再将数据发送给客户端(A)


UDP-打洞(客户端A位于局域网a, 客户端B位于局域网b, 服务器C位于公网, 客户端A和客户端B要通信)
1. 全锥形NAT

	假设, 内网机器(A:X), 公网机器(B:Y), 公网机器(C:Z)
如果内网机器(A:X)发送数据给公网机器(B:Y), 则映射的公网接口(D:X1)
如果内网机器(A:X)发送数据给公网机器(C:Z), 则映射的公网接口(D:X2)

## UDP hole punching
	### 方法
假设有两个客户 A:X B:Y 位于不同的 NAT 中，还有一个处于公网的服务器 C:Z

假设: X:x(私有) -> X1:x1(NAT) -> Y1:y1(公有)
此时, 如果, 新连接: X:x(私有) -> X2:x2(NAT) -> Y2:y2(公有)(X1 == X2)
1. 对于任何 Y1:y1 和 Y2:y2, X1:x1 都等于 X2:x2, 即: X:x 发向任何地址的数据都使用 NAT 的 X1:x1 (任何地址)
2. 如果 Y1 == Y2, 则 X1:x1 == X2:x2, 即: X:x 只有发往 Y1 的数据才使用 NAT 的 X1:x1 (IP 相同)
3. 如果 Y1:y1 == Y2:y2, 则 X1:x1 == X2:x2, 即: X:x 只有发往 Y1:y1 的数据才使用 NAT 的 X1:x1 (IP 和 端口号都相同)
此时, 如果, Y3:y3(私有) -> X1:x1(NAT) -> X:x(私有)
1. 对于任何 Y3:y3, 都可以发送成功(全锥形NAT)(任意)
2. 只要 Y3 == Y1, 就可以发送成功(受限圆锥形NAT)(IP相同)
3. 只有 Y3:y3 == Y1:y1, 才可以发送成功(端口受限圆锥形NAT)(IP和端口号都相同)

链路层广播

MTU 最大传输单元 (链路层)

p2p

网络层:

traceroute: 查看数据包经过的路径

强主机模式: 数据包必须和对应网络接口对上
弱主机模式: 数据包和任一网络接口对上即可

DHCP:

```

