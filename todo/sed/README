
## 简介
* sed 是一个流编辑器
* 模式空间：默认使用，每次读取都会刷新
* 保持空间：默认包含一个换行符，可以使用其做一些复杂操作

## 基本流程
1. 读取一行, 存入模式空间
2. 对模式空间的内容执行脚本
3. 输出模式空间的内容
4. 如果还有下一行，调到第一步，否则，退出

## 常用命令
sed    script            1.txt
sed -e script            1.txt
sed -e script  -e script 1.txt # 多个脚本
sed -f 1.sed             1.txt # 从文件中读取脚本
sed -n script            1.txt # 不输出模式空间的内容
sed -i script            1.txt # 直接在原文件上修改
sed -r script            1.txt # 使用扩展的正则表达式，默认使用基础的正则表达式

## 脚本说明
* script 有无引号，单双引号都行，有空格的时候必须有引号
* script 可以使用 {} 包成块， 方便嵌套
* script 可以使用多个命令，用分号分割
* 脚本可以操作的范围
    * addr1       指定某一行
    * addr2,addr3 指定某几行, 操作 [addr2,addr3] 行，addr 超出范围 或 未匹配时，默认为文件末尾
        * 1,10000p 输出全文, 假设文件少于 10000 行
        * 3,1p     输出第三行
        * 3,5p     输出 [3,5] 行
    * 上述地址后加 ! 表示不操作, 此时需要转义 或 使用 单引号， 因为 bash 会对 ！特殊解释
        * 1!p   不输出 第一行
        * 1,5!p 不输出 [1,5] 行
    * addr  可以是数字
        * 1p  输出第一行
    * addr  可以是模式匹配(正则表达式)
        * /11*/p                     输出匹配到的行
        * \c11*cp（c可以是任意字符） 输出匹配到的行
    * addr1 可以使用 n~m 的形式，表示每 m 行处理第 n 行，-- 感觉一般用不上
        * 0~2p   每两行打印第二行, 将打印第 2 4 6 ... 行
        * 1~2p   每两行打印第一行，将打印第 1 3 5 ... 行
        * 2~2p   每两行打印第二行, 将打印第 2 4 6 ... 行
        * 3~2p   每两行打印第三行，将打印第 3 5 7 ... 行
    * addr3 可以使用 +n 的形式，表示相对位置
        * 1,+4p 表示输出 第一行以及接下来四行
    * addr3 可以使用 ~n 的形式，表示匹配直到第 N 行，N 为 n 的整数倍 -- 很复杂, 感觉一般用不上
        * 1,~0p 输出第一行
        * 1,~1p 输出第一行，第二行 -- 不知为啥
        * 1,~2p 输出第一行，第二行
        * 1,~3p 输出第一行，第二行, 第三行
    * addr3 可以是 $, 表示文件末尾
        * 注意此处需要用单引号或转义 $，因为 没引号或使用双引号时，Bash 会解析 $ 符号
    * addr3 使用模式匹配时，addr2 和 addr3 不能匹配同一行
        * 如果允许的话，将始终只匹配一行
        * 使用数字时可以指定同一行
        * 1,1p   打印 [1,1] 行
    * addr3 使用模式匹配时，addr2 可以为 0, 表示起始位置从文件开头算
        * 0,addr3 如果 addr3 可以匹配第一行，将输出第一行
        * 1,addr3 如果 addr3 可以匹配第一行，也不会匹配，只会将第一行作为起始行

## 命令说明
* : ... 定义标签
* =     输出行号
* a ... 行后插入
    * 1a123     在第一行(即第二行)后插入123
    * 1ai\123   在第一行(即第二行)后插入123
    * 1a    123 在第一行(即第二行)后插入123, 将忽略空格
    * 1a\   123 在第一行(即第二行)后插入"    123"
* b ... 调到标签处，如果标签未指定时，跳到脚本末尾
* c ... 取代所选择的行, 使用和行后插入(a)类似
* d 删除模式空间的内容, 并进入下一循环
* D 删除模式空间的第一行内容, 如果此时模式空间为空，开始下一循环，否则，跳到脚本开始处继续
* e
* f
* g 将保持空间复制到模式空间
* G 将保持空间附加到模式空间
* h 将模式空间复制到保持空间
* H 将模式空间附加到保持空间
* i ... 行前插入, 使用和行后插入(a)类似
* j
* k
* l 列出当前行，标明不可见字符
* m
* n 读取下一行到模式空间
* N 将下一行添加到模式空间内容后
* o
* p 打印模式空间的内容
* P 打印模式空间的第一行内容
* q 退出, sed "2q" 1.txt 输出第一行，第二行后退出
* Q 退出, sed "2Q" 1.txt 输出第一行后退出
* r 添加文件的内容, 貌似无法在文件开头添加另一文件的内容
    * sed "r2.txt" 1.txt # 每一行后插入 2.txt 的内容
* R 行后添加文件中的一行
    * sed "R2.txt" 1.txt # 第一行后插入 2.txt 的第一行, 第二行后插入 2.txt 的第二行， 如果 2.txt 已读完，则不插入
* s 取代
    * sed    "s/123/456/"        1.txt # 替换第一处
    * sed    "s/123/456/2"       1.txt # 替换第二处
    * sed    "s/123/456/2g"      1.txt # 替换第二处及以后
    * sed    "s/123/456/g"       1.txt # 替换所有
    * sed -n "s/123/456/gp"      1.txt # 打印替换后的结果
    * sed -n "s/123/456/gw2.txt" 1.txt # 替换后的结果写入文件 2.txt
    * sed    "s|123|456|"        1.txt # 使用不同的分割符
    * sed    "s/.*/[&]/"         1.txt # & 用于表示所匹配到的内容
    * sed    "s/\(1\)/[\1]/"     1.txt # \1 表示第一个字串
    * sed -r "s/(1)/[\1]/"       1.txt # \1 表示第一个字串
    * sed    "s/1/a \t b/"       1.txt # 可以包含 \n \t
* t abc 前一个 s 命令成功会跳转到指定标签   -- 这个有点儿复杂, 感觉一般用不上
* T abc 前一个 s 命令未成功会跳转到指定标签 -- 这个有点儿复杂，感觉一般用不上
* w ... 写模式空间的内容到文件
    * sed     "1w1.c"      1.txt # 第一行行保存到文件
* W ... 写模式空间的第一行的内容到文件
* x 交换模式空间和保持空间的内容
* y 字符替换, 可以指定操作的行，无法指定替换一行中的第几个
    * sed "y/123/456/" 1.txt
    * sed "y/1-3/456/" 1.txt
    * sed "y/123/4-6/" 1.txt
    * sed "y/1-3/4-6/" 1.txt
* z

## 特别说明
* a i r R 插入的内容不在模式空间，所以后续的 d 或 D 不会对插入的内容有影响
* 如果脚本中命令使用了 ! 或 $, 需要进行转义 或 使用单引号，因为 Bash 对其有特殊处理

## 使用例子
* sed -n '1!G; h; $p'                      1.txt 逆序输出文件的内容, 可以用 tac     代替
* sed    '=' 1.txt | sed -n "N; s/\n/ /; p"      添加行号，          可以用 cat  -n 代替
* sed    ':start; $q; N; 4,$D; b start'    1.txt 输出最后的三行      可以用 tail -3 代替
* sed    '/./,/^$/!d'                      3.txt 删除连续的空行      可以用 cat  -s 代替
* sed    '/./,$!d'                         3.txt 删除文件开头的空行
* sed    ':start; /^\n*$/{$d; N; b start}' 3.txt 删除文件末尾的空行
* sed    's/<[^>]*>//g; /^$/d'             3.txt 删除 html 标签

## 感悟
* 会使用基本命令就足够了，太复杂的一般也用不到
* 建议直接使用扩展的正则表达式，也不在乎这么点儿效率

