
# 目录
* 信号
* 进程
* 僵尸进程
* 孤儿进程
* 孤儿进程组
* 进程组
* 会话

# 信号(用于进程间通信)
## 信号阻塞
### 说明
* SIGKILL 和 SIGSTOP 无法被阻塞
* SIGCONT 可以被阻塞, 但好像没啥用

### 测试
1. 阻塞所有信号
2. 此时, 可以看到除 SIGKILL 和 SIGSTOP 外, 其他信号都被阻塞了
3. 向自身发送除了 SIGKILL 和 SIGSTOP 外的所有信号, 这两个信号不能被捕获, 而且会导致进程退出或暂停, 所以跳过
4. 此时, 可以看到除 SIGKILL SIGSTOP 和 SIGCONT 外, 其他信号都处于待决状态

测试文件: 01.cc

## 信号优先级
### 说明
* 有多个信号处于未决状态(信号发送后, 处理前)时, 进程处理的顺序

### 测试
1. 为所有信号注册信号处理函数, 并设置信号处理过程中阻塞其他信号
2. 阻塞所有信号
3. 向自身发送除了 SIGKILL 和 SIGSTOP 外的所有信号, 这两个信号不能被捕获, 而且会导致进程退出或暂停, 所以跳过
4. 解阻塞所有信号
5. 此时, 可以看到信号捕获的顺序
    *  4-SIGILL
    *  5-SIGTRAP
    *  7-SIGBUS
    *  8-SIGFPE
    * 11-SIGSEGV
    * 31-SIGSYS
    * 其他信号按数字的从小到大顺序处理

测试文件: 02.cc

## 信号不可靠
### 相同的信号处于待决状态时, 只记录一个, 其他信号会丢失
1. 设置 SIGUSR1 的信号处理函数
2. 阻塞信号 SIGUSR1
3. 向自身发送信号 SIGUSR1 五次
4. 解除信号 SIGUSR1 阻塞
5. 可以看到 SIGUSR1 只捕获到一次

测试文件: 03.cc

### 信号处理后, 信号处理函数可能会被重置
1. 设置 SIGUSR1 的信号处理函数
2. 设置信号触发后被重置
3. 发送信号 SIGUSR1 第 1 次, 正常捕获
4. 发送信号 SIGUSR1 第 2 次, 进程直接退出

测试文件: 04.cc

## 信号处理
### 第一种: 忽略信号
### 第二种: 默认处理(忽略, 退出, 退出产生core, 暂停, 继续)
### 第三种: 捕获信号, 信号处理过程中, 相同的信号来了会被阻塞, 此时, 如果再来相同的信号将被抛弃
1. 设置信号 SIGUSR1 处理函数, 处理函数休眠 2 秒，便于观察
2. 产生子进程
3. 子进程空循环
4. 父进程向子进程发送信号 SIGUSR1 第一次
5. 此时, 观察到子进程正在执行信号处理函数
6. 父进程向子进程发送信号 SIGUSR1 第二次
7. 父进程向子进程发送信号 SIGUSR1 第三次
8. 此时, 观察到子进程继续执行之前的信号处理函数，直到完成
9. 然后, 处理第二次信号
10. 不会处理第三次信号, 这个信号丢失了

测试文件: 05.cc

### 第四种: 捕获信号, 信号处理过程中, 不同的信号来了会被直接执行, 执行完之后, 再继续执行之前的函数
1. 设置信号 SIGUSR1 和 SIGUSR2 处理函数, 处理函数休眠 2 秒，便于观察
2. 产生子进程
3. 子进程空循环
4. 父进程向子进程发送信号 SIGUSR1
5. 此时, 观察到子进程正在执行信号处理函数
6. 父进程向子进程发送信号 SIGUSR2
7. 此时, 观察到子进程直接处理信号 SIGUSR2，直到完成
8. 然后, 继续处理 SIGUSR1, 直到完成

测试文件: 06.cc

### 第五种: 使用 sigaction() 可以选择阻塞的信号集
1. 设置信号 SIGUSR1 和 SIGUSR2 处理函数, 处理函数休眠 2 秒, 便于观察，并设置信号处理过程中阻塞 SIGUSR2
2. 产生子进程
3. 子进程空循环
4. 父进程向子进程发送信号 SIGUSR1
5. 此时, 观察到子进程正在执行信号处理函数
6. 父进程向子进程发送信号 SIGUSR2
7. 此时, 观察到子进程继续执行之前的信号处理函数，直到完成
8. 然后, 开始处理 SIGUSR2, 直到完成

测试文件: 07.cc

## 常见信号
 1) SIGHUP  # 终端断开时, 向会话首进程发送
 2) SIGINT  # 键盘中断, 由 ctrl+c 产生
 3) SIGQUIT # 键盘退出, 由 ctrl+\ 产生
 4) SIGILL  # 非法指令, 可执行文件有错误
 5) SIGTRAP # 由 debug 产生
 6) SIGABRT # 由 abort() 产生时
            #   默认处理, 进程退出 -- 08.cc
            #   忽略信号, 进程退出 -- 09.cc
            #   捕获信号, 并从信号处理函数返回, 进程退出 -- 10.cc
            #   捕获信号, 不从信号处理函数返回, 进程继续 -- 11.cc
 7) SIGBUS  # 指针非法地址, 比如, 不符合对齐要求
 8) SIGFPE  # 浮点数异常, 比如整数除以0
            #   忽略信号, 进程退出
            #   默认处理, 进程退出
            #   捕获信号, 并从信号处理函数返回, 将继续触发此信号 -- 12.cc
            #   捕获信号, 不从信号处理函数返回, 进程继续运行
 9) SIGKILL # 退出, 不能被阻塞, 捕获, 忽略
10) SIGUSR1 # 用户自定义信号
11) SIGSEGV # 指针地址合法, 但无权限访问, 比如, 空指针, 除非跳过异常的行, 否则, 将反复触发
12) SIGUSR2 # 用户自定义信号
13) SIGPIPE # 写文件描述符时, 对方已退出, 比如 socket, 管道
14) SIGALRM # 由 alarm() 产生的超时
15) SIGTERM # 退出信号, kill 默认信号
16) SIGSTKFLT # 栈错误, 未使用
17) SIGCHLD # 子进程暂停或继续时, 会向父进程发送此信号
            #   父进程设置默认处理后, 会忽略此信号
            #   父进程设置忽略信号后, 会忽略此信号
            #   父进程设置捕获信号后, 会调用信号处理函数处理  -- 13.cc
            #   父进程使用 sigaction 设置 SA_NOCLDSTOP 后, 不再接收此信号 -- 14.cc
            # 子进程退出时, 会向父进程发送此信号
            #   父进程设置 sigaction 的 SA_NOCLDWAIT 后, 不会产生僵尸进程
            #   父进程设置默认处理,   会产生僵尸进程
            #   父进程设置忽略信号, 不会产生僵尸进程
            #   父进程设置捕获信号, 并调用 waitpid() 类函数一次, 可能会产生僵尸进程
            #   父进程设置捕获信号, 并调用 waitpid() 类函数循环,   不会产生僵尸进程
18) SIGCONT # 继续
19) SIGSTOP # 暂停, 不能被阻塞, 捕获, 忽略
20) SIGTSTP # 暂停
21) SIGTTIN # 后台进程读取终端输入
22) SIGTTOU # 后台进程输出到终端
23) SIGURG  # 带外数据
24) SIGXCPU # cpu 使用超出限制
25) SIGXFSZ # 文件大小超出限制
26) SIGVTALRM # 虚拟的超时信号
27) SIGPROF   # setitimer 到期
28) SIGWINCH  # 终端大小发生变化
29) SIGIO     # 异步IO就绪
30) SIGPWR    # 电池问题
31) SIGSYS    # 非法的系统调用

## 常用函数
* abort()  # 解锁信号 SIGABRT, 然后向自身发送 SIGABRT
* raise()  # 向自己发送信号
* kill()   # 发送信号, 向某一进程 或 进程组
* pause()  # 休眠, 直到不被忽略的信号发生
* sleep()  # 休眠n秒, 或者一个未被忽略的信号到达
* signal() # 设置信号处理函数
           # 信号处理函数不会被重置
           # 被中断系统调用会自动重启
           # 信号处理时, 自身会被阻塞, 其他信号不会
* sigaction() # 设置信号处理函数
              # 可以选择是否自动重启被中断的系统调用
              # 可以选择第一次调用以后, 信号处理函数是否恢复成默认值
              # 可以选择信号处理过程中, 是否阻塞自身, 或这阻塞指定信号集
              # 可以指明对子进程状态变化的处理
              # 可以获取到发送信号一端的一些信息
* longjmp(), setjmp() # 跨函数 goto
* sigemptyset() # 将信号集置空
* sigfillset()  # 填充所有信号
* sigaddset()   # 添加信号到信号集
* sigdelset()   # 从信号集删除信号
* sigismember() # 判断信号是否处于信号集
* sigprocmask() # 阻塞 或 解阻塞 或 查看信号
* sigpending()  # 处于待决状态的信号

## 信号测试(忽略所有信号, 用于测试)
测试文件: 15.cc

# 进程(PID)(任务控制的基本单位)
## 新建进程
* fork(): 父子进程的执行顺序不确定
* vfork(): 在子进程退出或执行exec之前, 父进程处于不可被信号打断的休眠状态
* 将继承父进程的进程组, 会话

## 修改进程
* PID 无法变化

## 销毁进程
* 将向父进程发送信号 SIGCHLD, 内核会保存退出状态
* 如果此进程是该进程组的最后一个进程, 此进程退出后, 该进程组消失
* 如果此进程是该会话的最后一个进程, 此进程退出后, 该会话消失

## 其他特性
* 启动命令: 完整的启动命令, 包括路径和参数, 如果是符号链接, 只会记录和展示符号本身
* 进程名称: 启动名称去掉路径和参数, 有时查找或输出时, 只会使用前 15 位
* 一个进程只能属于一个父进程
* 一个父进程可以有多个子进程
* 一个进程只能属于一个进程组
* 一个进程只能属于一个会话
* 实际用户和组
* 有效用户和组
* 保存用户和组
* 文件用户和组, 一般和有效的用户相同
* 附属组
* 优先级

## 进程状态及改变
* 就绪
* 运行(R)
* 休眠(S)(可被信号打断)(指被捕获的信号)
    * pause() 只有收到未忽略的信号才返回
    * sleep() 只有收到未忽略的信号 或 到达指定秒数才返回 -- 16.cc
* 休眠(D)(不可被信号打断)(指被捕获的信号)
   * 调用 vfork() 后的父进程  -- 17.cc
   * 此时，SIGSTOP 也会被阻塞 -- 18.cc
   * 此时，SIGKILL 不会被阻塞 -- 19.cc
* 暂停(T)(作业控制)
    * 收到信号 SIGSTOP
    * 收到信号 SIGTSTP, 可由 ctrl+z 产生
    * 收到信号 SIGTTIN, 处于后台进程时读终端
    * 收到信号 SIGTTOT, 处于后台进程时写终端, 这个得看设置是否允许后台进程写终端
    * 继续, 收到信号 SIGCONT -- 20.cc
* 暂停(t)(由于 DEBUG 产生)
* 空闲(I)
    * 处于不可被打断的休眠状态时, 有时 CPU 是空闲的
* 僵尸(Z)
    * 子进程已退出, 父进程还未处理
* 退出(X)

## proc 文件
/proc/loadavg     # 系统负载
/proc/cpuinfo     # cpu 信息
/proc/uptime      # 运行时间
/proc/sys

/proc/PID/cmdline # 完整的启动命令
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/comm    # 进程名称, 不包含路径名称, 最多 15 位
                  # 如果以符号链接启动, 将存储符号链接本身
/proc/PID/cwd     # 进程当前的目录
/proc/PID/exe     # 符号链接, 指向运行的进程
/proc/PID/environ # 进程使用的环境变量
/proc/PID/fd      # 进程所打开的文件描述符
/proc/PID/limits  # 进程对各种资源的限制
/proc/PID/task    # 进程使用的线程情况

## 常用命令
                             # 多个命令之间取或
ps -U RUID -G RGID           # 实际的用户和组
ps -u EUID -g EGID           # 有效的用户和组
ps -p PID                    # 进程ID, 多个进程可以重复使用 -p 或者参数以分号分割 -- 常用
ps -s SID                    # 会话ID
ps --ppid PPID               # 父进程ID
ps -t ...                    # 终端
ps -C vim                    # 进程名称, 全名称 或 前 15 位

ps -o ruid,ruser,rgid,rgroup # 实际的用户和组
ps -o euid,euser,egid,egroup # 有效的用户和组
ps -o suid,suser,sgid,sgroup # 保存的用户和组
ps -o fuid,fuser,fgid,fgroup # 文件的用户和组, 一般和有效的相同
ps -o supgid,supgrp          # 附属组ID
ps -o pid,ppid,pgid,sid      # 进程ID, 父进程ID, 进程组ID, 会话ID
ps -o ouid                   # 会话ID所属用户ID
ps -o tty                    # 终端
ps -o tpgid                  # 输出前台进程的ID
ps -o luid,lsession          # 终端登录的用户ID和会话ID
ps -o stat,state             # 进程状态
                             # R 正在运行
                             # S 正在休眠
                             # T 后台暂停的作业
                             # t debug 调试中
                             # Z 僵尸进程
ps -o pmem,rsz,vsz           # 内存百分比,内存,内存(含交换分区)
ps -o pcpu,c,bsdtime,cputime # cpu: 百分比,百分比整数,user+system,system
ps -o lstart,etime,etimes    # 启动时间,运行时间,运行时间(秒), 无法对 etimes 进行排序
ps -o nice,pri,psr,rtprio    # 优先级
ps -o wchan                  # 进程休眠, 返回当前使用的内核函数
                             # 进程运行, 返回 -
                             # 列出线程, 返回 *
ps -o cmd                    # 启动命令
ps -o comm                   # 进程名称
ps -o fname                  # 进程名称的前 8 位

ps -e           # 所有进程
ps -H           # 输出进程树
ps -ww          # 不限制输出宽度
ps --no-headers # 不输出列头部
ps --headers    #   输出列头部
ps --sort -pcpu # cpu 使用率逆序

ps -o lwp,nlwp # 线程ID, 线程数
ps -L          # 列每一个线程

pstree     [PID] # 以进程 PID 为根画进程树, 默认为 1
pstree  -c [PID] # 展示所有子树
pstree  -p [PID] # 展示进程ID
pstree  -g [PID] # 展示进程组ID
pstree  -n [PID] # 使用 PID 排序而不是 进程名称
pstree  -l [PID] # 使用长行, 方便写入文件

              # 多个命令之间取且
pgrep         # 使用进程名称查找, 使用扩展的正则表达式
pgrep -f  ... # 使用启动命令匹配, 默认使用进程名称匹配(最多15位)
pgrep -c  ... # 输出匹配到的进程数目
pgrep -d，... # 设置输出的分割符，默认是换行符 -- 常用
pgrep -i  ... # 忽略大小写
pgrep -l  ... # 列出进程名称(最多15位)
pgrep -a  ... # 列出启动命令
pgrep -n  ... # 仅列出最新的进程
pgrep -o  ... # 仅列出最旧的进程
pgrep -g  ... # 指定进程组ID
pgrep -G  ... # 指定实际组ID
pgrep -P  ... # 指定父进程ID
pgrep -s  ... # 指定会话ID
pgrep -t  ... # 指定终端
pgrep -u  ... # 指定有效用户ID
pgrep -U  ... # 指定实际用户ID
pgrep -v  ... # 反转结果
pgrep -x  ... # 精确匹配，默认不需要完全匹配
pgrep -w  ... # 列出线程ID

pidof    # 进程名称 => PID, 精确匹配, 没有长度限制
pwdx pid # 列出进程的当前工作目录

kill         pid # 通过进程ID发送信号给进程或进程组
kill -signal pid # 指定信号，默认值为 SIGTERM
kill -l          # 列出所有信号

killall             # 通过进程名称发送信号给进程或进程组, 进程名称精确匹配
killall -l          # 列出所有信号
killall -o 2m a.out # 发给 2 分钟前启动的 a.out
killall -y 2m a.out # 发给 2 分钟内启动的 a.out
killall -w    a.out # 等待进程结束

pkill         ... # 杀死进程, 扩展的正则表达式，参数和 pgrep 类似
pkill -signal ... # 指定信号，默认值为 SIGTERM

## 建议
* 使用 pgrep 获取进程ID, 使用 ps 列出详细信息
* 使用 etimes 可以方便计算出启动时间, 并格式化 年-月-日 时-分-秒
* 一般使用进程的前 15 位即可
* 使用 pkill 发送信号

# 僵尸进程
## 产生的原因
* 子进程退出时, 会向父进程发送 SIGCHLD, 同时内核会保留子进程退出的状态信息
* 但父进程未正确处理此信号, 导致内核一直保留子进程退出的状态信息

## 存在的意义
* 父进程可以获取子进程退出的状态信息

## 存在的危害
* 数量较少时没有过大的负作用
* 但大量僵尸进程会占用大量的 PID 以及其他系统资源, 影响系统正常使用

## 查看僵尸进程
* 使用 top 查看是否存在僵尸进程
* 获取僵尸进程的进程号:

ps --no-header -fe -o state,pid | awk '$1 == "Z" {print $2}'

## 模拟僵尸进程的产生
### 场景一: 父进程未处理子进程退出的状态信息
1. 父进程产生子进程
2. 子进程空循环
3. 此时, 可以看到子进程处于运行状态
4. 杀死子进程
5. 此时, 可以看到子进程处于僵尸状态

测试文件: 21.cc

### 场景二: 父进程未正确处理子进程退出的状态信息
1. 父进程设置捕捉 SIGCHLD 时, 调用一次 waitpid()
2. 父进程阻塞信号 SIGCHLD
3. 父进程产生五个子进程, 每次子进程都退出, 父进程休眠一秒, 保证子进程已退出
4. 父进程解除信号 SIGCHLD 阻塞
5. 此时, 由于有的 SIGCHLD 信号丢失, 所以有的子进程处于僵尸状态

测试文件: 22.cc

## 预防僵尸进程
### 方法一: 父进程设置忽略 SIGCHLD

测试文件: 23.cc

### 方法二: 父进程设置捕捉 SIGCHLD 时, 循环调用 waitpid(...WNOHANG)

测试文件: 24.cc

### 方法三: 父进程设置捕捉 SIGCHLD 时, 使用 sigaction() 设置 `SA_NOCLDWAIT`, 表示不产生僵尸进程

测试文件: 25.cc

### 方法四: 父进程退出, 使子进程变成孤儿进程, 子进程的父进程将变为 systemd, 后者会处理僵尸进程
1. 进程产生子进程作为测试的父进程
2. 测试的父进程产生测试的子进程
3. 测试的父进程产生测试的控制进程
4. 通过测试的控制进程杀死测试的父进程
5. 通过测试的控制进程杀死测试的子进程
6. 通过测试的控制进程可以看到测试的子进程并未处于僵尸状态

测试文件: 26.cc

## 销毁僵尸进程
### 方法
* 只能杀死僵尸进程的父进程, 僵尸进程的父进程将变为 systemd, 后者将处理僵尸进程

### 测试
1. 进程产生子进程作为测试的父进程
2. 测试的父进程产生测试的子进程
3. 测试的父进程产生测试的控制进程
4. 通过测试的控制进程可以看到测试的子进程处于运行状态
5. 通过测试的控制进程杀死测试的子进程
6. 通过测试的控制进程可以看到测试的子进程处于僵尸状态
7. 通过测试的控制进程杀死测试的父进程
8. 通过测试的控制进程可以看到测试的子进程消失了

测试文件: 27.cc

## 其他测试文件
### 产生僵尸进程不退出
1. 父进程产生子进程
2. 子进程退出
3. 此时, 可以看到子进程处于僵尸状态
4. 父进程死循环

测试文件: 28.cc

## 注意事项
1. 设置 SIGCHLD 为 SIG_IGN 和 SIG_DFL(默认会忽略信号), 是不同的, 前者不会产生僵尸进程, 后者会
2. 发送 SIGCHLD 的子进程与 waitpid() 得到的子进程不一定相同

# 孤儿进程
## 产生的原因
* 子进程未退出, 父进程已退出时, 此时子进程是孤儿进程

## 重现产生的场景
1. 进程产生子进程作为测试的父进程
2. 测试的父进程产生测试的子进程
3. 测试的父进程空循环
4. 此时, 可以看到测试的子进程的父进程是测试的父进程
5. 杀死测试的父进程
6. 此时, 可以看到测试的子进程的父进程变为 systemd

测试文件: 29.cc

## 后续处理
* 孤儿进程的父进程将变为 systemd

## 处理的意义
* 保证所有进程都有父进程, 保证进程退出时的资源都能被释放

## 注意事项
* 孤儿进程只是一个临时状态, 马上就会有新的父进程
* 孤儿进程只有父进程发生变化, 其他属性不会变化

# 孤儿进程组
## 产生的原因
* 该进程组内所有进程的父进程, 要么属于该进程组, 要么不属于该进程组所属的会话

## 临界状态
* 如果进程组的某个进程的父进程退出导致该进程所属组变成孤儿进程组
* 且该进程组内有进程处于暂停状态
* 0 号进程将发送 SIGCONT 和 SIGHUP 给该孤儿进程组的每一个成员

## 重现临界状态
1. 进程产生子进程作为测试的父进程
2. 测试的父进程新建新的进程组
3. 测试的父进程产生测试的第一个子进程
4. 测试的第一个子进程使自己暂停
5. 测试的父进程产生测试的第二个子进程
6. 此时新的进程组只包含测试的父进程, 测试的第一个子进程和测试的第二个子进程
7. 测试的父进程的父进程和上述三个进程属于同一会话
8. 杀死测试的父进程
9. 此时新的进程组只包含测试的第一个子进程和测试的第二个子进程
10. 上述两个进程的父进程变为 systemd
11. systemd 和 两个测试的子进程不在同一个会话
12. 新的进程组变成一个孤儿进程组, 第一个测试的子进程处于暂停状态
13. 所以 0 号进程将发送 SIGCONT 和 SIGHUP 给该孤儿进程组的每一个成员

测试文件: 30.cc

## 临界状态处理的意义
* 出现临界状态一般都是程序有问题, 系统相当于加了一层保险, 避免系统资源浪费

## 注意事项
* 会话首进程所在的进程组也属于孤儿进程组
* 孤儿进程所在的进程组不一定是孤儿进程组

# 进程组
## 存在意义
*  为了作业控制, 为了便于向一批进程发送信号

## 新建进程组
* 只能新建值为对应的 PID 的进程组, 并将对应进程加入该进程组
* 如果新建的进程组的值与原进程组的值相同, 则忽略
* 可以为自身新建进程组 -- 31.cc
    1. 父进程新建值为对应的 PID 进程组(PID == PGID)
    2. 父进程产生子进程
    3. 子进程新建值为对应的 PID 进程组(PID != PGID)
* 不能新建父进程的进程组 -- 32.cc
    1. 进程产生测试的父进程
    2. 测试的父进程产生测试的子进程
    3. 此时, 测试的父进程的进程ID和进程组ID不同
    4. 测试的子进程为测试的父进程新建值为对应PID的进程组, 失败
* 新建子进程的进程组(子进程属于不同的会话, 失败) -- 33.cc
    1. 父进程产生子进程
    2. 子进程新建会话
    3. 此时, 子进程的进程ID和进程组ID相同, 父子进程属于不同的会话
    4. 父进程新建子进程对应的进程组, 失败
* 新建子进程的进程组(子进程调用exec之后, 失败) -- 34.cc
    1. 父进程产生子进程
    2. 子进程调用exec函数
    3. 此时, 父进程新建子进程对应的进程组, 失败
* 新建子进程的进程组(其他情况, 成功) -- 35.cc
    1. 父进程产生子进程
    2. 此时, 子进程的进程ID和进程组ID不同, 父子进程属于相同的会话
    3. 此时, 父进程新建子进程对应的进程组, 成功
* 不能新建孙进程对应的进程组 -- 36.cc
    1. 父进程新建管道
    2. 父进程产生子进程
    3. 子进程产生孙进程, 并将孙进程的PID发送给父进程
    4. 此时, 父进程, 子进程, 孙进程属于同一个会话, 同一个进程组
    5. 父进程新建孙进程对应的进程组, 失败
* 不能新建会话首进程对应的的进程组 -- 37.cc
    1. 父进程产生子进程
    2. 子进程建立新会话
    3. 此时, 子进程的 PIG, PGID, SID 相同
    4. 子进程新建自身对应的进程组, 失败

## 修改进程组
* 目标进程组必须存在
* 目标进程组和原进程组必须属于同一个会话 -- 38.cc
    1. 父进程产生子进程
    2. 子进程建立新会话
    3. 此时, 子进程的 PIG, PGID, SID 相同
    4. 此时, 父子进程属于不同的会话
    5. 父进程修改自身的进程组为子进程的进程组, 失败
* 其他情况与新建进程组相同

## 销毁进程组
* 创建进程组的进程退出或修改进程组时, 只要原进程组还有其他进程, 原进程组就不会消失
* 当该进程组的最后一个进程退出或所属的进程组被修改时, 原进程组消失
* 可以向同一进程组内的所有成员统一发送信号

## 与进程和会话的关系
* 一个进程组包含一个或多个进程
* 一个进程组只能属于一个会话

# 会话
## 存在意义
* 为了终端的作业控制
* 为了建立守护进程

## 新建会话
* 新的会话ID是当前进程的ID, 新的进程组ID也是当前进程的ID
* 新会话和新进程组里将只包含当前进程
* 新的会话将脱离终端的控制
* 当前进程是进程组的首进程时, 不能新建会话, 避免出现同一进程组的进程属于不同的会话的情况 -- 39.cc
    1. 当前进程的进程ID和进程组ID相同, 即是进程组的首进程
    2. 新建会话, 失败
* 当前进程不能是进程组的首进程时, 可以新建会话 -- 40.cc
    1. 当前进程产生子进程
    2. 子进程的进程ID和进程组ID不同, 即不是进程组的首进程
    2. 子进程新建会话, 成功

## 销毁会话(会话不和终端绑定)
* 会话首进程退出时, 不会对会话内的其他进程有影响 -- 41.cc
    1. 父进程产生子进程
    2. 子进程新建会话
    3. 子进程产生孙进程
    4. 此时, 子孙进程属于同一会话, 子进程是会话首进程
    5. 杀死子进程(会话首进程)
    6. 孙进程可以正常运行, 只是变成孤儿进程

## 和进程 进程组 终端的关系
* 一个会话包含一个或多个进程
* 一个会话包括一个或多个进程组
* 一个会话最多和一个终端绑定

## 终端
* 用户登录时, 系统将一个会话与终端绑定, 此会话进程即为控制进程
* 终端退出时, 将发送 SIGHUP 给控制进程, 控制进程将向此会话中的所有进程组发送信号 SIGHUP
    * 对于暂停的作业将先发送 SIGCONT 和 SIGTERM 信号
* 此会话有且只有一个前台进程组, 有零个或多个后台进程组
* 终端的输入将发送到前台进程组, 前台和后台进程组的输出都将发送到终端
* 新建会话可以脱离终端
* 脱离终端的进程的父进程不一定是 1, 也可能是其他脱离终端的进程
* 脱离终端可以忽略 SIGHUP 或 新建会话

## 守护进程
1. 产生子进程, 然后父进程退出, 保证子进程不是进程组的首进程
2. 新建会话, 保证子进程脱离终端的控制
3. 关闭所有的文件描述符, 文件描述符继承自父进程
4. 设置权限掩码, 避免受到父进程掩码的影响
5. 切换到根目录, 因为当前目录可能会被卸载或删除

