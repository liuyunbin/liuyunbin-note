
## 基础概念
* 地球自转一圈为一天
* 地球公转一圈为一年

## GMT(格林威治时间)(已过时)
* 太阳经过格林威治天文台的时间为中午12点
* 这里说的一天不受地球自转速度的影响
* 地球转的快了, 一天就短, 一秒也变短, 慢了, 一天就长, 一秒也变长

## UTC(正在用)
* 原子时间: 一秒是精确的, 一天也是精确的(有误差, 但很小)
* 由于, 地球自转速度的变化, 导致和 GMT 的时间对不上, 由此, 产生了闰秒
* 好消息是: 2035 年要取消闰秒了

## 时间戳
* 距离 1970-01-01 的秒数, 不包括闰秒

## 闰年 闰月
* 地球公转一圈时, 地球自转了 365.24219 圈
* 所以, 一年等于 365.24219 天
* 为什么不把一年直接定义为 365 天, 为了保证夏天始终热, 冬天始终冷, 否则就乱了
* 为了修正误差, 区分了平年和闰年
* 规则:(这样算完还有误差, 但误差就比较小了)
    * 如果遇到不是整百年, 且能被四  整除, 是闰年
    * 如果遇到  是整百年, 且能被四白整除, 是闰年
* UTC 精确了定义一秒
* 闰年的参照物是太阳
* 闰月的参照物是月亮

## 夏令时
* 进夏令时的那一天只有 23 个小时
* 出夏令时的那一天只有 25 个小时
* 其他日期都有 24 个小时
* 可以节约能源

## 时区
* 每 15 个经度一个时区
* 总共 24 个时区
* 相邻时区相差一个小时





/etc/default/locale -- 修改系统显示


ntpdate -s time-b.nist.gov # 使用时间服务器更新时间
date "+%Y-%m-%d %H:%M:%S"   # 输出: 年-月-日 时-分-秒
date "+%Y-%m-%d %H:%M"      # 输出: 年-月-日 时-分
date "+%s"                  # 输出: 时间戳
date -d "20200202 01:01:01" # 使用: 指定输入日期
date -d "@...."             # 使用: 时间戳
date -r 1.c                 # 使用: 文件的 mtime
date -s "20200202 10:10:10" # 更新系统时间, 需要 root


### 基本函数
* time(time_t*) 计算 基于 1970-01-01 00:00:00 +0000 utc 的时间戳
* struct tm*    gmtime(const time_t*)                           时间戳   --> 时间元组, +0000 utc
* struct tm* localtime(const time_t*)                           时间戳   --> 时间元组, 本地时间
* char *         ctime(const time_t*)                           时间戳   --> 字符串
* char *  asctime(const struct tm *tm)                          时间元组 --> 字符串
* size_t strftime(char*, size_t, const char*, const struct tm*) 时间元组 --> 字符串, 可以指的格式
* time     mktime(struct tm *tm)                                时间元组 --> 字符戳
* char *strptime(const char*, const char*, struct tm*)          字符串   --> 时间元组




double difftime(time_t time1, time_t time0);
