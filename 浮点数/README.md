
## 说明
* 使用 double, 探索浮点数的一些问题

## TODO
* 16 位精度究竟是什么意思?

## 浮点数的格式
* 1-符号位
* 11-阶码-偏移量-1023
* 52-尾码

## 大小端
* 浮点数区分大小端
* 大端存储:
    * 浮点数的高字节存储在内存的低字节
    * 看起来直观
    * 方便判断正负
* 大端存储:
    * 浮点数的高字节存储在内存的高字节
    * 方便 int 转为 short 等
* 网络字节使用大端存储

## 浮点数类型
* 正负零:
    * 阶码都为 0
    * 尾码都为 0
* 正负无穷:
    * 阶码都为 1
    * 尾码都为 0
* 非数字:
    * 阶码都为 1
    * 尾码不都为 0
* 规约数:
    * 阶码不都为 0 或 1
    * 阶码的偏移量为 1023
    * 尾码整数部分为 1
* 非规约数:
    * 阶码都为 0
    * 尾码不都为 1
    * 阶码的偏移量为 1022
    * 尾码整数部分为 0
* 查看浮点数类型: pclassify(...)

## 浮点数的舍入模式
* 向下舍入: std::floor
* 向上舍入: std::ceil
* 向零舍入:
    * std::trunc
    * 浮点数-->整数
* 最近舍入:
    * 四舍六入五取偶
    * 默认舍入模式,
* 四舍五入: std::round
* 由舍入模式决定
    * std::rint, std::nearbyint,
    * 保留几位小数
    * 浮点数的存储
* 查看舍入模式: fegetround()
* 设置舍入模式: fesetround(...)

## 浮点数异常
* 除以 0
* 结果不准确
* 参数非法
* 上溢
* 下溢
* 清空浮点数异常: feclearexcept(...)
* 测试浮点数异常: fetestexcept(...)
* 可能会引发浮点数异常的场景:
    * 浮点数的四则运算
    * 绝大部分函数
* 不会引发浮点数异常的场景:
    * isless 系列 TODO -- 待定
    * nearbyint 系列

## 浮点数精度损失
* 可能会损失精度
    * 浮点数的存储
    * 浮点数的计算
    * 浮点数字符串 --> 浮点数二进制
* 不会损失精度
    * 浮点数二进制 --> 浮点数字符串

## 阶码为什么使用移码? 不使用补码?
* 方便比较大小
    * 符号位特殊
    * 其他位直接比较即可
* 使用补码还需要判断阶码的符号位

## 非规约数的偏移量为什么是 1022, 不是 1023?
* 设 a 为最大正非规约数的上一可表示数
* 设 b 为最大正非规约数
* 设 c 为最小正规约数
* 设 d 为最小正规约数的下一可表示数
* 如果 非规约数的偏移量是 1022
    * d - c: 2 的 -1074 次
    * c - b: 2 的 -1074 次
    * b - a: 2 的 -1074 次
* 如果 非规约数的偏移量是 1022
    * d - c: 2 的 -1074 次
    * c - b: 2 的 -1075 次 + 2 的 -1023 次
    * b - a: 2 的 -1075 次
* 使用 1022, 从规约数到非规约数能够相对连续

## 相邻可表示的浮点数的差值是不是一定的
* 不是
* 离零越近, 差值越小

