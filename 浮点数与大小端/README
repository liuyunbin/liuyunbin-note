
## 说明
* 大小端的使用与判断
* 使用 double, 探索浮点数的存储以及精度的损失

## 大小端
### 说明
* 大端存储(网络字节序)
    * 高字节存储在内存的低字节
    * 看起来直观, 手写的计算机存储和真实的存储一致
    * 方便判断正负
* 大端存储(Linux)
    * 高字节存储在内存的高字节
    * 方便 int 转为 short 等

### 适用的类型
* short, int, long, long long
* float, double, long double

测试: 01.cc

## 浮点数
以 double 为例, 探讨浮点数的一些问题

### 浮点数的格式
* 1-符号位
* 11-阶码
* 52-尾码

### 浮点数类型
* 正负  零: 阶码都为 0, 尾码  都为 0
* 非规约数: 阶码都为 0, 尾码不都为 0, 阶码的偏移量为 1022, 尾码整数部分为 0 (特别小的数字)
* 正负无穷: 阶码都为 1, 尾码  都为 0
*   非数字: 阶码都为 1, 尾码不都为 0
*   规约数: 阶码不都为 0, 也不都为 1, 阶码的偏移量为 1023, 尾码整数部分为 1
* 查看浮点数类型: pclassify(...)

* 设 a 为最大正非规约数的上一可表示数: 0 00000000000 (0)1111111111111111111111111111111111111111111111111110
* 设 b 为最大正非规约数              : 0 00000000000 (0)1111111111111111111111111111111111111111111111111111
* 设 c 为最小正规约数                : 0 00000000001 (1)0000000000000000000000000000000000000000000000000000
* 设 d 为最小正规约数的下一可表示数  : 0 00000000001 (1)0000000000000000000000000000000000000000000000000001

非规约数的偏移量为什么是 1022, 不是 1023?, 非规约数的整数位为什么是 0, 不是 1?
* 如果非规约数的偏移量是 1022, 非规约数的整数位是 0
    * a 为: -1022次 - -1074次 - -1074次 (-1022 - 52)
    * b 为: -1022次 - -1074次
    * c 为: -1022次
    * d 为: -1022次 + -1074次
    * b - a: -1074次
    * c - b: -1074次
    * d - c: -1074次
* 如果非规约数的偏移量是 1023, 非规约数的整数位是 0 (非规约数 => 规约数, 变化差值不太连续)
    * a 为: -1023次 - -1075次 - -1075次 (-1023 - 52)
    * b 为: -1023次 - -1075次
    * c 为: -1022次 == -1023次 + -1023次
    * d 为: -1022次 + -1074次
    * b - a: -1075次
    * c - b: -1075次 + -1023次
    * d - c: -1074次
* 如果非规约数的偏移量是 1022, 非规约数的整数位是 1(最大非规约数 大于 最小规约数, 不行)
    * a 为: -1022次 + -1022次 - -1074次 - -1074次 (-1022 - 52)
    * b 为: -1022次 + -1022次 - -1074次
    * c 为: -1022次
    * d 为: -1022次 + -1074次
    * b - a: -1074次
    * c - b: -1074次 - -1022次 (小于 0)
    * d - c: -1074次
* 如果非规约数的偏移量是 1023, 非规约数的整数位是 1(相比较, 第一种能表达更贴近 0 的数)
    * a 为: -1023次 + -1023次 - -1075次 - -1075次 (-1023 - 52)
    * b 为: -1023次 + -1023次 - -1075次
    * c 为: -1022次 == -1023次 + -1023次
    * d 为: -1022次 + -1074次
    * b - a: -1075次
    * c - b: -1075次
    * d - c: -1074次

测试: 02.cc

### 浮点数的舍入模式
* 范围:
    * 浮点数存储(二进制)
    * 保留小数位数(十进制)
    * 如果不能精确处理, 是舍弃还是进一
* 向下舍入:
    * 正数: 舍弃
    * 负数: 进一
    * std::floor
* 向上舍入:
    * 正数: 进一
    * 负数: 舍弃
    * std::ceil
* 向零舍入:
    * 正数: 舍弃
    * 负数: 舍弃
    * std::trunc
    * 浮点数-->整数
* 四舍五入:
    * 只用于保留小数位数
    * 剩余部分第一位小于 5: 舍弃
    * 剩余部分第一位大于等于 5: 进一
    * std::round
* 最近舍入:
    * 四舍六入五取偶
    * 保留小数
        * 剩余部分第一位小于 5: 舍弃
        * 剩余部分第一位大于 5: 进一
        * 剩余部分第一位 5 后  存在非 0 位: 进一
        * 剩余部分第一位 5 后不存在非 0 位: 进一
            * 精确存储的的最后一位为奇数: 进一
            * 精确存储的的最后一位为偶数: 舍弃
    * 存储
        * 剩余部分第一位为 0: 舍弃
        * 剩余部分第一位为 1 且后  存在 非 0 位: 进一
        * 剩余部分第一位为 1 且后不存在 非 0 位
            * 精确存储的的最后一位为 1: 进一
            * 精确存储的的最后一位为 0: 舍弃
    * 是认舍入模式,
* 由舍入模式决定:
    * std::rint
    * std::nearbyint
* 查看舍入模式: fegetround()
* 设置舍入模式: fesetround(...)

测试: 03.cc

### 浮点数异常(这个比较乱, 一般不重要)
* 范围:
    * 四则运算
    * 调用函数
    * 参数不合法 或者 结果不准确的问题
* 类型:
    * 除以 0
    * 结果不准确
    * 参数非法
    * 上溢
    * 下溢
* 清空浮点数异常: feclearexcept(...)
* 测试浮点数异常: fetestexcept(...)
* 可能会引发浮点数异常的场景:
    * 浮点数的四则运算
    * 绝大部分函数
* 不会引发浮点数异常的场景:
    * isless 只对 signaling NaN 抛出异常
    * nearbyint 系列

测试: 04.cc

### 阶码为什么用移码? 不用补码?
* 方便比较大小
    * 符号位特殊
    * 其他位直接比较即可
* 使用补码还需要判断阶码的符号位

### 相邻可表示的浮点数的差值是不是一定的?
* 不是
* 离零越近, 差值越小
* 非规约数:
    * 差值: 2 的 (0-1022-52) 次
    * 即: 2 的 -1074 次
* 最大非规约正数 --> 最小规约正数
    * 差值: 2 的 (0-1022-52) 次
    * 即: 2 的 -1074 次
* 阶码相同时
    * 差值: 2 的 (阶码-1023-52) 次
* 阶码相邻时
    * 差值: 2 的 (小的阶码-1023-52) 次

## 浮点数最多可以表示的小数点后的位数
* 最小非规约正数的最后一位非 0 位
* 1074 位

测试: 05.cc

### 浮点数精度损失
* 范围
    * 浮点数存储
    * 浮点数取回
    * 浮点数计算
* 小于最小非规约正数的正数将当作 0
* 大于最大规约正数的数字将当作正无穷
* 以下仅讨论规约数和非规约数
* 浮点数字符串(a) --> 浮点数二进制(b)
    * 可能无法精确转换(0.1)
* 浮点数二进制(b) --> 浮点数科学计数(c)
    * 无精度损失
* 浮点数科学计数(c) --> 调节幂次(d)
    * 如果, 幂次小于 -1022
        * 将幂次改为 -1022
        * 同时调整小数部分
    * 无精度损失
* 调节幂次(d) --> 存储-52位(e)
    * 整数部分为 1, 表示规约数
    * 整数部分为 0, 表示非规约数
    * 只存储小数部分
    * 前 51 位精确存储
    * 最后一位四舍六入五取偶
    * 注意: 进一的时候可能引发前 51 位变化
* 存储-52位(e) --> 浮点数二进制(f)
    * 无精度损失
* 浮点数二进制(f) --> 浮点数十进制(g)
    * 无精度损失
* 浮点数十进制(g) --> 保留小数位数(h)
    * 默认: 四舍六入五取偶
* 一个精确的浮点数表示的上下限
    * 如果最后一位是 0, 则范围是 [下限, 上限]
    * 如果最后一位是 1, 则范围是 (下限, 上限)

测试: 06.cc

# TODO
## 15 位精度是什么意思?
* 符号位, 阶码固定的情况下
* 相邻的可表示数的差值是固定的
* 52 位二进制能表示 4503599627370496 个数
* 53 位二进制能表示 9007199254740992 个数
* 共 16 位, 即 能够保证存储 15 位数
* 并不是说: a 的前 15 位可以精确表示
* 即: a 和 g 的前 15 位完全相同
* 而是说: a 与 g 的差值小于 f 的幂次
* 还是不太清楚, 先放下吧,...

