
## 说明
* 大小端的使用与判断
* 使用 double, 探索浮点数的存储以及精度的损失

## 大小端
### 说明
* 大端存储(网络字节序)
    * 高字节存储在内存的低字节
    * 看起来直观, 手写的计算机存储和真实的存储一致
    * 方便判断正负
* 大端存储(Linux)
    * 高字节存储在内存的高字节
    * 方便 int 转为 short 等

### 适用的类型
* short, int, long, long long
* float, double, long double

测试: 01.cc

## 浮点数的格式
* 1-符号位
* 11-阶码
* 52-尾码


## 浮点数类型
* 正负零:
    * 阶码都为 0
    * 尾码都为 0
* 正负无穷:
    * 阶码都为 1
    * 尾码都为 0
* 非数字:
    * 阶码都为 1
    * 尾码不都为 0
* 规约数:
    * 阶码不都为 0 或 1
    * 阶码的偏移量为 1023
    * 尾码整数部分为 1
* 非规约数:
    * 阶码都为 0
    * 尾码不都为 1
    * 阶码的偏移量为 1022
    * 尾码整数部分为 0
* 查看浮点数类型: pclassify(...)

## 浮点数的舍入模式
* 范围:
    * 浮点数存储(二进制)
    * 保留小数位数(十进制)
    * 如果不能精确处理, 是舍弃还是进一
* 向下舍入:
    * 正数: 舍弃
    * 负数: 进一
    * std::floor
* 向上舍入:
    * 正数: 进一
    * 负数: 舍弃
    * std::ceil
* 向零舍入:
    * 正数: 舍弃
    * 负数: 舍弃
    * std::trunc
    * 浮点数-->整数
* 四舍五入:
    * 只用于保留小数位数
    * 剩余部分第一位小于 5: 舍弃
    * 剩余部分第一位大于等于 5: 进一
    * std::round
* 最近舍入:
    * 四舍六入五取偶
    * 保留小数
        * 剩余部分第一位小于 5: 舍弃
        * 剩余部分第一位大于 5: 进一
        * 剩余部分第一位 5 后存在 非 0 位: 进一
        * 精确存储的的最后一位为奇数: 进一
        * 精确存储的的最后一位为偶数: 舍弃
    * 存储
        * 剩余部分第一位为 0: 舍弃
        * 剩余部分第一位 1 后存在 非 0 位: 进一
        * 精确存储的的最后一位为 1: 进一
        * 精确存储的的最后一位为 0: 舍弃
    * 默认舍入模式,
* 由舍入模式决定:
    * std::rint
    * std::nearbyint
* 查看舍入模式: fegetround()
* 设置舍入模式: fesetround(...)

## 浮点数异常
* 范围:
    * 四则运算
    * 调用函数
    * 参数不合法 或者 结果不准确的问题
* 类型:
    * 除以 0
    * 结果不准确
    * 参数非法
    * 上溢
    * 下溢
* 清空浮点数异常: feclearexcept(...)
* 测试浮点数异常: fetestexcept(...)
* 可能会引发浮点数异常的场景:
    * 浮点数的四则运算
    * 绝大部分函数
* 不会引发浮点数异常的场景:
    * isless 只对 signaling NaN 抛出异常
    * nearbyint 系列

## 阶码为什么用移码? 不用补码?
* 方便比较大小
    * 符号位特殊
    * 其他位直接比较即可
* 使用补码还需要判断阶码的符号位

## 非规约数的偏移量为什么是 1022, 不是 1023?
* 设 a 为最大正非规约数的上一可表示数
* 设 b 为最大正非规约数
* 设 c 为最小正规约数
* 设 d 为最小正规约数的下一可表示数
* 如果 非规约数的偏移量是 1022
    * d - c: 2 的 -1074 次
    * c - b: 2 的 -1074 次
    * b - a: 2 的 -1074 次
* 如果 非规约数的偏移量是 1022
    * d - c: 2 的 -1074 次
    * c - b: 2 的 -1075 次 + 2 的 -1023 次
    * b - a: 2 的 -1075 次
* 使用 1022, 从规约数到非规约数能够相对连续

## 相邻可表示的浮点数的差值是不是一定的?
* 不是
* 离零越近, 差值越小
* 非规约数:
    * 差值: 2 的 (0-1022-52) 次
    * 即: 2 的 -1074 次
* 最大非规约正数 --> 最小规约正数
    * 差值: 2 的 (0-1022-52) 次
    * 即: 2 的 -1074 次
* 阶码相同时
    * 差值: 2 的 (阶码-1023-52) 次
* 阶码相邻时
    * 差值: 2 的 (小的阶码-1023-52) 次

## 浮点数最多可以表示的小数点后的位数
* 最小非规约正数的最后一位非 0 位
* 1074 位

## 浮点数精度损失
* 范围
    * 浮点数存储
    * 浮点数取回
    * 浮点数计算
* 小于最小非规约正数的正数将当作 0
* 大于最大规约正数的数字将当作正无穷
* 以下仅讨论规约数和非规约数
* 浮点数字符串(a) --> 浮点数二进制(b)
    * 可能无法精确转换(0.1)
* 浮点数二进制(b) --> 浮点数科学计数(c)
    * 无精度损失
* 浮点数科学计数(c) --> 调节幂次(d)
    * 如果, 幂次小于 -1022
        * 将幂次改为 -1022
        * 同时调整小数部分
    * 无精度损失
* 调节幂次(d) --> 存储-52位(e)
    * 整数部分为 1, 表示规约数
    * 整数部分为 0, 表示非规约数
    * 只存储小数部分
    * 前 51 位精确存储
    * 最后一位四舍六入五取偶
    * 注意: 进一的时候可能引发前 51 位变化
* 存储-52位(e) --> 浮点数二进制(f)
    * 无精度损失
* 浮点数二进制(f) --> 浮点数十进制(g)
    * 无精度损失
* 浮点数十进制(g) --> 保留小数位数(h)
    * 默认: 四舍六入五取偶

# TODO
## 15 位精度是什么意思?
* 符号位, 阶码固定的情况下
* 相邻的可表示数的差值是固定的
* 52 位二进制能表示 4503599627370496 个数
* 53 位二进制能表示 9007199254740992 个数
* 共 16 位, 即 能够保证存储 15 位数
* 并不是说: a 的前 15 位可以精确表示
* 即: a 和 g 的前 15 位完全相同
* 而是说: a 与 g 的差值小于 f 的幂次
* 还是不太清楚, 先放下吧,...

