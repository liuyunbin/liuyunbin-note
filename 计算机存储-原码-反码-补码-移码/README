
## 本文讨论原码 反码 补码 移码的优缺点以及如何理解它们

## 加减法的所有类型
* 正数+正数:
* 正数-正数:
* 正数+负数: 可以转化为 正数-正数
* 正数-负数: 可以转化为 正数+正数
* 负数+正数: 可以转化为 正数-正数
* 负数+负数: 可以转化为 正数+正数, 然后把正数变成负数
* 负数-正数: 可以转化为 正数+正数, 然后把正数变成负数
* 负数-负数: 可以转化为 正数-负数
*      正数: 可以转化为    0+正数
*      负数: 可以转化为    0-正数

所以我们只需要处理 正数+正数 和 正数-正数 的情况就可以了

## 原码
* 正数: 符号位为 0
* 负数: 符号位为 1
*   +0: 0000
*   -0: 1000
* 最大: 0111(+7)
* 最小: 1111(-7)
* 比较大小:
    * 先比较符号位, 正数大于负数
    * 同为正数, 数越大, 值越大
    * 同为负数, 数越大, 值越小
* 正数+正数: 需要使用加法器处理, 像列竖式一样, 高位直接舍弃
* 正数-正数: 需要使用减法器处理

## 反码
* 正数的反码和原码相同
* 负数的反码在原码的基础上, 把除符号位外的所有位取反(计算)
* 定义: 最高位取负, 值为 2^(w-1) - 1, 其他位取正, 即:
    * -2(1101) == -1*(2^3-1) + 1*2^2 + 1*2^1 + 0*2^0 = -8 + 4 + 2 + 0 = -2
    * +2(0010) == -0*(2^3-1) + 0*2^2 + 1*2^1 + 0*2^0 = -0 + 0 + 2 + 0 = +2
*   +0: 0000
*   -0: 1111
* 最大: 0111(+7)
* 最小: 1000(-7)
* 比较大小(比使用原码好一点, 同号的比较大小可以统一)
    * 先比较符号位, 正数大于负数
    * 同为正数, 数越大, 值越大
    * 同为负数, 数越大, 值越小
* 正数+正数: 无意义
* 正数-正数: 无意义

## 补码
* 正数的补码和原码相同
* 负数的补码在反码的基础上, 在最后一位加一(这个只是计算方法, 不是定义)
* 定义: 最高位取负, 其他位取正, 即:
    * +7(0111) == -0*2^3 + 1*2^2 + 1*2^1 + 1*2^0 = -0 + 4 + 2 + 1 = +7
    * +2(0010) == -0*2^3 + 0*2^2 + 1*2^1 + 0*2^0 = -0 + 0 + 2 + 0 = +2
    * -2(1110) == -1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = -8 + 4 + 2 + 0 = -2
    * -8(1000) == -1*2^3 + 0*2^2 + 0*2^1 + 0*2^0 = -8 + 0 + 0 + 0 = -8
*   +0: 0000
* 最大: 0111(+7)
* 最小: 1000(-8)
* 比较大小(比使用原码好一点, 同号的比较大小可以统一)
    * 先比较符号位, 正数大于负数
    * 同为正数, 位数越大, 值越大
    * 同为负数, 位数越大, 值越大
* 正数+正数: 使用加法器处理
* 正数-正数: 可以转化为 正数 + 负数, 然后使用加法器处理(补码存在的主要目的)
* 补码变符号
    * 正数(+1) => 负数(-1) == 正数的补码(0001)各位取反(1110), 然后加一(1111)
    * 负数(-1) => 正数(+1) == 负数的补码(1111)各位取反(0000), 然后加一(0001)
* 加法器: 像列竖式一样, 从低到高, 一位一位相加, 该进就进, 超过最高位直接舍弃

## 移码
* 在原码的基础上加一个数字, 使得所有的数字都是非负数
* 比较大小: 直接比较即可
* 加法: 无意义
* 减法: 无意义

