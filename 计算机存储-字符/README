
## 总结
* 查看二进制一般使用 xxd 或 xxd -g 即可, 其他经常需要考虑字节序
* 优先使用无 BOM 的 UTF-8 编码, 使用 vim 的 set nobomb 可以去掉 BOM
* 使用 iconv 进行编码规则转换, vim 也可以, 只是没有 iconv 方便
* 文件编码不一定能精确获取

## 生成二进制文件
g++ -0g main.cc
g++ -01 main.cc
g++ -02 main.cc
g++ -03 main.cc
g++ -g  main.cc   # 生成 gdb 的文件

## 查看二进制
xxd        1.txt 2.txt # 字符文件 => 二进制
xxd -r     1.txt 2.txt # 二进制 => 字符文件
xxd -b     1.txt       # 输出二进制而不是十六进制
xxd -e     1.txt       # 使用小端模式
xxd -g ... 1.txt       # 每组的字节数

hd         1.txt # 每组一个字节 显示十六进制+ASCII
hexdump -b 1.txt # 每组一个字节 显示八进制
hexdump -c 1.txt # 每组一个字节 显示字符
hexdump -C 1.txt # 每组一个字节 显示十六进制+ASCII
hexdump -d 1.txt # 每组两个字节 显示  十进制
hexdump -o 1.txt # 每组两个字节 显示  八进制
hexdump -x 1.txt # 每组两个字节 显示十六进制

od -t a   1.txt # 每组一个字节, 显示字符(nl)
od -t c   1.txt # 每组一个字节, 显示字符(\n)
od -t d4  1.txt # 每组四个字节, 显示有符号的十进制数字
od -t f4  1.txt # 每组四个字节, 显示浮点数
od -t o4  1.txt # 每组四个字节, 显示  八进制数字
od -t u4  1.txt # 每组四个字节, 显示无符号的十进制数字
od -t x4  1.txt # 每组四个字节, 显示十六进制数字
od -t d4z 1.txt # 每组四个字节, 显示十进制数字, 并显示原始字符
od -a     1.txt # 同 -t a
od -b     1.txt # 同 -t o1
od -c     1.txt # 同 -t c
od -d     1.txt # 同 -t u2
od -f     1.txt # 同 -t f
od -i     1.txt # 同 -t dI
od -l     1.txt # 同 -t dL
od -o     1.txt # 同 -t o2
od -s     1.txt # 同 -t d2
od -x     1.txt # 同 -t x2
od --endian={big|little} 1.txt # 指明大小端

gdb [a.out] [pid]            # 启动 gdb
gdb> file a.out              # 设置可执行文件
gdb> set args	             # 设置程序启动命令行参数
gdb> show args	             # 查看设置的命令行参数
gdb> run [arguments]         # 运行程序(r)
gdb> attach pid              # gdb 正在运行的程序
gdb> info breakpoints        # 列出断点信息(i)
gdb> break file:line         # 在指定行设置断点(b)
gdb> break function          # 在制定函数设置断点(b)
gdb> break function if b==0  # 根据条件设置断点(b)
gdb> tbreak file:line        # 在指定行设置临时断点(tb)
gdb> disable breakpoints num # 禁用断点 num
gdb>  enable breakpoints num # 启用断点 num
gdb>  delete breakpoints num # 删除断点 num
gdb> clear   line            # 清除指定行的断点
gdb> continue [num]          # 继续运行到指定断点(c)
gdb> until     line          # 运行到指定行(u)
gdb> jump      line          # 跳转到指定行(j), 和 until 的区别是跳过的代码不会执行
gdb> next     [num]          # 继续运行多次(n)
gdb> step                    # 进入函数(s)
gdb> finish                  # 退出函数(fin), 会执行完当前函数
gdb> return ...              # 退出函数, 并指定返回值, 和 finish 的区别是不会继续执行之后的代码, 直接返回
gdb> print v                 # 输出变量的值(p)
gdb> print v=123             # 修改变量的值(p)
gdb> p *pointer              # 输出指针指向的值
gdb> p arr[1]@3              # 输出数组 arr[1] 开始的3个元素
gdb> p/t var                 # 按  二进制格式显示变量
gdb> p/o var                 # 按  八进制格式显示变量
gdb> p/d var                 # 按  十进制格式显示变量
gdb> p/u var                 # 按  十进制格式显示无符号整型
gdb> p/x var                 # 按十六进制格式显示变量
gdb> p/a var                 # 按十六进制格式显示地址
gdb> p/c var                 # 按字符格式显示变量
gdb> p/f var                 # 按浮点数格式显示变量
gdb> p/s var                 # 字符串
gdb>         display v       # 和 p 类似, 但后续会自动输出变量的值
gdb> disable display num     # 暂时取消输出
gdb>  enable display num     # 恢复输出
gdb>  delete display num     # 删除自动输出变量的值的编号
gdb>       undisplay num     # 删除自动输出变量的值的编号
gdb> info    display         # 列出自动打印变量的值
gdb> x/8xb &v                # 输出 double 的二进制表示
gdb> x/nfu  v                # n 表示打印多少个内存单元
                             # f 打印格式, x d u o t a c f(默认8位)
                             # u 内存单元, b=1 h=2 w=4 g=8
                             # x 和 p 的区别
                             #   * p 的参数是变量的值, x 的参数是变量的地址
                             #   * p 打印的单位长度即是变量的长度, x 可以指定单位长度
                             #   * x 可以打印连续的多个单位长度(这个可以方便看 double 的每一个字节的内容)
gdb> list                    # 显示当前行之后的源程序(l)
gdb> list -                  # 显示当前行之前的源程序
gdb> list 2,10               # 显示 2 - 10 行的源程序
gdb>  set listsize 20        # 设置列出源码的行数
gdb> show listsize           # 输出列出源码的行数
gdb> set  print elements 0   # 设置打印变量长度不受限制
gdb> show print elements
gdb> backtrace               # 显示堆栈信息(bt)
gdb> frame     n             # 查看指定层的堆栈信息(f)
gdb> thread	                 # 切换到指定线程
gdb> watch	                 # 监视某一个变量的值是否发生变化
gdb> ptype	                 # 查看变量类型

## 字符
BOM(Byte Order Mark), 字节序标识

编码: 字符串 -> 计算机存储
解码: 计算机存储 -> 字符串
字符集: ASCII (和编码规则一一对应)
        GB2312 => GBK(cp936) => GB18030 (和编码规则一一对应)
        BIG5
        Unicode
        Latin1(ISO-8859-1) 单字节使用完整的八位字节, 所以可以将其他编码当作 Latin1 来传输不会丢失数据
编码规则:
        UTF-8  -- 不需要 BOM, 存在也成(FE FF => EF BB BF)
        UTF-16 --   需要 BOM(FE FF 或 FF FE)
        UTF-32 --   需要 BOM(00 00 FE FF 或 FF FE 00 00)

        windows 的 记事本 的 ASCI   : 本地编码
        windows 的 记事本 的 unicode: 带 BOM 的小端的 UTF-16
        windows 的 记事本 的 utf-8  : 带 BOM 的 UTF-8

file  1.txt   # 查看文件编码规则, 并不准确

iconv -f gbk -t utf-8 1.txt -o 1.txt # gbk => utf-8
iconv -t gbk -f utf-8 1.txt -o 1.txt # utf-8 => gbk

